
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SDK</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
        }
        h1 {
            color: #007acc;
        }
    </style>
</head>

<body>

====================
FILE PATH: .\com.stibo.assetdownload.domain-sources\com\stibo\assetdownload\domain\home\AssetDownloadHome.java
====================
package com.stibo.assetdownload.domain.home;

/**
 *Asset Download home
 */
public abstract interface AssetDownloadHome {
  
  /**
   *Download the file from the URL specified and upload it to the asset passed in (i.e. replace the
   * asset content).
   *
   * @param asset The asset to download the URL contents to.
   * @param url The URL address to download from.
   * @throws com.stibo.core.domain.ImageParserException Thrown if STEP fails to parse image found at URL.
   * @throws java.io.IOException Thrown if the action fails due to a failure to open a connection to the URL or can fail with
   *                     a runtime exception if the url contents can't be uploaded to the asset. The socket open and read
   *                     timeouts are set by default to 50 seconds but can be specified by setting the relevant values in
   *                     the users and groups asset download settings.
   */
  public abstract void downloadAssetContent(com.stibo.core.domain.Asset asset,java.net.URL url) throws com.stibo.core.domain.ImageParserException,java.io.IOException;
  
}


====================
FILE PATH: .\com.stibo.assetimporter.domain-sources\com\stibo\assetimporter\domain\configuration\AssetImporterConfiguration.java
====================
package com.stibo.assetimporter.domain.configuration;

/**
 *The asset importer configuration as displayed in a system setup node in a setup group.
 */
public abstract interface AssetImporterConfiguration extends com.stibo.core.domain.setupentity.SetupEntity {
  
  /**
   *Upload new content to the asset. The content of the asset is given in the input stream.
   *
   * @param assetID Upload the content to this asset
   * @param assetContents The content of the asset as a stream
   * @param orgFileName The name of the file containing the asset content.
   */
  public abstract void upload(java.lang.String assetID,java.io.InputStream assetContents,java.lang.String orgFileName);
  
}


====================
FILE PATH: .\com.stibo.barcodes.tools.server-sources\com\stibo\barcodes\tools\server\javascript\Barcodes.java
====================
package com.stibo.barcodes.tools.server.javascript;

public class Barcodes {
  
  /**
   *@param asset            the asset where the generated barcode will be stored
   * @param code             the EAN/GTIN code to generate. The length of the code determines the format (EAN-8, UPC-A, EAN-13, ITF or CODE-128)
   * @param height           the pixel height of the barcode lines. A value of 100 seems to generate a good result. Resolution of PNG is fixed at 96 DPI.
   * @param marginHorizontal the amount of whitespace to each side of the barcode lines (in pixels). Shouldn't be less than 15.
   * @param marginVertical   the amount of whitespace above and below the barcode lines (in pixels).
   * @throws java.io.IOException thrown if barcode cannot be converted to an image
   */
  public void generateBarcodeByCodeLength(com.stibo.core.domain.Asset asset,java.lang.String code,int height,int marginHorizontal,int marginVertical) throws java.io.IOException {}
  
  /**
   *@param asset            the asset where the generated barcode will be stored
   * @param code             the EAN-128 code (variable number of characters)
   * @param height           the pixel height of the barcode lines. A value of 100 seems to generate a good result. Resolution of PNG is fixed at 96 DPI.
   * @param marginHorizontal the amount of whitespace to each side of the barcode lines (in pixels). Shouldn't be less than 15.
   * @param marginVertical   the amount of whitespace above and below the barcode lines (in pixels).
   * @throws java.io.IOException thrown if barcode cannot be converted to an image
   */
  public void generateEAN128(com.stibo.core.domain.Asset asset,java.lang.String code,int height,int marginHorizontal,int marginVertical) throws java.io.IOException {}
  
  /**
   *@param asset            the asset where the generated barcode will be stored
   * @param code             the EAN-13 code (13 digits)
   * @param height           the pixel height of the barcode lines. A value of 100 seems to generate a good result. Resolution of PNG is fixed at 96 DPI.
   * @param marginHorizontal the amount of whitespace to each side of the barcode lines (in pixels). Shouldn't be less than 15.
   * @param marginVertical   the amount of whitespace above and below the barcode lines (in pixels).
   * @throws java.io.IOException thrown if barcode cannot be converted to an image
   */
  public void generateEAN13(com.stibo.core.domain.Asset asset,java.lang.String code,int height,int marginHorizontal,int marginVertical) throws java.io.IOException {}
  
  /**
   *@param asset            the asset where the generated barcode will be stored
   * @param code             the EAN-8 code (8 digits)
   * @param height           the pixel height of the barcode lines. A value of 100 seems to generate a good result. Resolution of PNG is fixed at 96 DPI.
   * @param marginHorizontal the amount of whitespace to each side of the barcode lines (in pixels). Shouldn't be less than 15.
   * @param marginVertical   the amount of whitespace above and below the barcode lines (in pixels).
   * @throws java.io.IOException thrown if barcode cannot be converted to an image
   */
  public void generateEAN8(com.stibo.core.domain.Asset asset,java.lang.String code,int height,int marginHorizontal,int marginVertical) throws java.io.IOException {}
  
  /**
   *@param asset            the asset where the generated barcode will be stored
   * @param code             the ITF code (14 digits)
   * @param height           the pixel height of the barcode lines. A value of 100 seems to generate a good result. Resolution of PNG is fixed at 96 DPI.
   * @param marginHorizontal the amount of whitespace to each side of the barcode lines (in pixels). Shouldn't be less than 15.
   * @param marginVertical   the amount of whitespace above and below the barcode lines (in pixels).
   * @throws java.io.IOException thrown if barcode cannot be converted to an image
   */
  public void generateITF14(com.stibo.core.domain.Asset asset,java.lang.String code,int height,int marginHorizontal,int marginVertical) throws java.io.IOException {}
  
  /**
   *@param asset                the asset where the generated QR code will be stored
   * @param qrCodeText           the QR code
   * @param size                 the size (heigh & width) in pixels. Resolution of PNG is 96 DPI.
   * @param margin               the minimum amount of white space to be included in the size above. A value of 4 seems a good figure
   * @param errorCorrectionLevel Must be in an integer between 1 and 4 corresponding to ~ 7%, 15%, 25% or 30% correction. Otherwise, 7% will be used.
   * @throws com.google.zxing.WriterException thrown is QR code cannot be encoded
   * @throws java.io.IOException     thrown if QR code cannot be converted to an image
   */
  public void generateQRcode(com.stibo.core.domain.Asset asset,java.lang.String qrCodeText,int size,int margin,int errorCorrectionLevel) throws com.google.zxing.WriterException,java.io.IOException {}
  
  /**
   *@param asset            the asset where the generated barcode will be stored
   * @param code             the UPC-A code (12 digits)
   * @param height           the pixel height of the barcode lines. A value of 100 seems to generate a good result. Resolution of PNG is fixed at 96 DPI.
   * @param marginHorizontal the amount of whitespace to each side of the barcode lines (in pixels). Shouldn't be less than 15.
   * @param marginVertical   the amount of whitespace above and below the barcode lines (in pixels).
   * @throws java.io.IOException thrown if barcode cannot be converted to an image
   */
  public void generateUPC12(com.stibo.core.domain.Asset asset,java.lang.String code,int height,int marginHorizontal,int marginVertical) throws java.io.IOException {}
  
  /**
   *Constructor
   *
   * @param node the current object in JS bind
   */
  public Barcodes(com.stibo.core.domain.Node node) {}
  
}


====================
FILE PATH: .\com.stibo.basicesignature.domain-sources\com\stibo\basicesignature\domain\BasicEsignature.java
====================
package com.stibo.basicesignature.domain;

/**
 *This interface represents values that should be populated for BasicEsignature implementation
 */
public abstract interface BasicEsignature {
  
  /**
   *Returns a timestamp representing the time of action execution.
   * @return information about time of action execution
   */
  public abstract java.util.Date getTimestamp();
  
}


====================
FILE PATH: .\com.stibo.blobstorage.domain-sources\com\stibo\blobstorage\domain\BlobStorage.java
====================
package com.stibo.blobstorage.domain;

/**
 *Service interface enabling access to external blob storage provider.
 * For instance Microsoft Azure Blob Storage or Amazon S3.
 */
public abstract interface BlobStorage {
  
  /**
   *Will check if blob storage is connectable, if not a runtime exception is raised.
   *
   * In terms of blobstorage connectivity this means we check if the client
   * configuration to access blobstorage is valid. So an example here would be
   * Azure Blob Storage where we check if ConnectionString and ContainerName is
   * valid and connectable from the driver.
   *
   * @throws RuntimeException if unable to connect.
   */
  public abstract void checkConnectivity();
  
}


====================
FILE PATH: .\com.stibo.completenessscore.domain-sources\com\stibo\completenessscore\domain\CompletenessMetric.java
====================
package com.stibo.completenessscore.domain;

/**
 *Interface representing a completeness metric via which it is possible to calculate the metric specific
 * completeness for a node. Completeness metric objects are modeled as setup entities and can be obtained
 * via the SetupEntityHome.getSetupEntityByID(String id) method.
 */
public abstract interface CompletenessMetric extends com.stibo.core.domain.setupentity.SetupEntity {
  
  /**
   *Calculates the node completeness for this metric.
   * @param node The node to calculate the completeness for.
   * @return a CompletenessMetricResult from which the completeness can be obtained as an int.
   */
  public abstract com.stibo.completenessscore.domain.CompletenessMetricResult calculateCompleteness(com.stibo.core.domain.Node node);
  
}


====================
FILE PATH: .\com.stibo.completenessscore.domain-sources\com\stibo\completenessscore\domain\CompletenessMetricResult.java
====================
package com.stibo.completenessscore.domain;

/**
 *Result of calculating the completeness of a node against a specific metric.
 */
public abstract interface CompletenessMetricResult {
  
  /**
   *Returns the completeness score of the node - a percentage that indicates how complete the node is.
   *
   * @return completeness score of a node as a percentage of the actual score related to the max score,
   * 0 if the max score is 0.
   */
  public abstract int getCompletenessScore();
  
}


====================
FILE PATH: .\com.stibo.completenessscore.domain-sources\com\stibo\completenessscore\domain\aggregatorinput\AggregatorMetricInput.java
====================
package com.stibo.completenessscore.domain.aggregatorinput;

/**
 *Class for holding the data send to an aggregator metric function. The class is constructed by the aggregator metric if a score calculator function is
 * configured for the metric. The results of each of the child metrics is converted to an AggregatorMetricInput object and parsed to the score calculator function.
 */
public class AggregatorMetricInput {
  
  /**
   *Get the ID of the child metric with the score contained in this class.
   * The metric ID may be used in the score calculation function to determine how the
   * score of a given metric should be used when calculation the final score.
   *
   * @return The ID of the child metric that has resulted in the included score
   */
  public java.lang.String getMetricID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the score if a child metric.
   *
   * @return The score of a child metric.
   */
  public int getScore() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.completenessscore.domain-sources\com\stibo\completenessscore\domain\metricresult\MetricBusinessFunctionResult.java
====================
package com.stibo.completenessscore.domain.metricresult;

/**
 *Support for return type as a score and messages from the Business Function.
 * Messages included may either be simple String messages or localized messages configured as a Message bind for the
 * business function in the JavaScript editor.
 * <p>
 * If the setNotApplicable() method is used then the result from the Business Function would be ignored if the metric result
 * is used by e.g. a aggregator completeness metric or in a Data Quality and Sufficiency configuration.
 * <p>
 * Example:
 * <p>
 * A business function that returns a score of 42 and a localized message containing a reason for the score
 * <p>
 * Variable "node" from function input parameter
 * Message from localized messages defined for business function in the JavaScript editor
 *
 * <pre>{@code
 *     var result = new com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult();
 *
 *     result.withScore(42);
 *     result.withMessage(node, new Message());
 *     return result;
 *
 * }</pre>
 * <p>
 * Example:
 * <p>
 * A business function that is not applicable to the node that is parsed in. The score is 0 and a
 * localized message is added.
 * <p>
 * Variable "node" from function put parameter
 * Message from localized messages defined for business function in the JavaScript editor
 *
 * <pre>{@code
 *     var result = new com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult();
 *
 *     result.setNotApplicable();
 *     result.withScore(0).withMessage(node, new Message());
 *
 *     return result;
 *
 * }</pre>
 */
public class MetricBusinessFunctionResult implements java.io.Serializable {
  
  /**
   *Gets a builder for a message with data types and values to be included in the result.
   *
   * @param node    The node that the message describes
   * @param message The message for the node
   * @return MetricBusinessFunctionResultBuilder The builder
   */
  public com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResultBuilder getMessageBuilder(com.stibo.core.domain.Node node,java.lang.Object message) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Gets the score of the metric
   *
   * @return The score
   */
  public int getScore() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns true/false if metric is applicable/not applicable for the node. If metric is not applicable then the result of the metric will
   * be ignored if the metric is used in a aggregator completeness metric or in a Data Quality and Sufficiency configuration.
   *
   * @return True if metric is applicable, otherwise false is returned
   */
  public boolean isApplicable() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets that the metric is not applicable for the node. This means that the result of the metric will
   * be ignored if the metric is used in a aggregator completeness metric or in a Data Quality and Sufficiency configuration.
   *
   * @return This MetricBusinessFunctionResult
   */
  public com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult setNotApplicable() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets a message to be included in the result
   *
   * @param node     The node that the message describes
   * @param dataType The data type that the message describes, ie. an Attribute
   * @param message  The message for the node
   * @return This MetricBusinessFunctionResult
   */
  public com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult withMessage(com.stibo.core.domain.Node node,com.stibo.core.domain.DataType dataType,java.lang.Object message) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets a message to be included in the result
   *
   * @param node    The node that the message describes
   * @param value   The value that the message describes, ie. the Value of an attribute
   * @param message The message for the node
   * @return This MetricBusinessFunctionResult
   */
  public com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult withMessage(com.stibo.core.domain.Node node,com.stibo.core.domain.Value value,java.lang.Object message) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets a message to be included in the result.
   *
   * @param node    The node that the message describes
   * @param message The message for the node
   * @return This MetricBusinessFunctionResult
   */
  public com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult withMessage(com.stibo.core.domain.Node node,java.lang.Object message) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets the score of the metric
   *
   * @param score The score of the metric
   * @return This MetricBusinessFunctionResult
   */
  public com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult withScore(int score) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Empty constructor for a return type with a score and messages. Sets the initial score to 0.
   */
  public MetricBusinessFunctionResult() {}
  
}


====================
FILE PATH: .\com.stibo.completenessscore.domain-sources\com\stibo\completenessscore\domain\metricresult\MetricBusinessFunctionResultBuilder.java
====================
package com.stibo.completenessscore.domain.metricresult;

/**
 *A builder for a message with data types and values to be included in the MetricBusinessFunctionResult.
 */
public abstract interface MetricBusinessFunctionResultBuilder {
  
  /**
   *Add data type to the message to be included in the MetricBusinessFunctionResult.
   *
   * @param dataType The data type
   * @return The builder
   */
  public abstract com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResultBuilder add(com.stibo.core.domain.DataType dataType);
  
  /**
   *Add value to the message to be included in the MetricBusinessFunctionResult.
   *
   * @param value The Value
   * @return The builder
   */
  public abstract com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResultBuilder add(com.stibo.core.domain.Value value);
  
  /**
   *Return the MetricBusinessFunctionResult with a message with data types and values.
   *
   * @return MetricBusinessFunctionResult
   */
  public abstract com.stibo.completenessscore.domain.metricresult.MetricBusinessFunctionResult build();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Asset.java
====================
package com.stibo.core.domain;

/**
 *A node containing a digital asset such as an image or a document.
 */
public abstract interface Asset extends com.stibo.core.domain.Node, com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.WorkflowableNode, com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode, com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.WorkspaceRevisableNode {
  
  /**
   *Link a Classification onto this asset.
   * @param classification The Classification to link the Asset into.
   * @throws UniqueConstraintException Thrown if an Asset has already been linked to the Classification.
   */
  public abstract void addClassification(com.stibo.core.domain.Classification classification) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *<p>Writes asset content to OutputStream supplied as parameter.
   * Remember to close the outputstream.</p>
   * <p>Example:</p>
   * <pre>{@code
   * OutputStream outputStream = new FileOutputStream(new File("fileName"));<br/>
   * asset.download(outputStream);<br/>
   * outputStream.close();
   * }</pre>
   * @param outputStream the outputStream to write asset content to (remember to close it)
   * @throws IOException in case something goes wrong while content is written to stream
   */
  public abstract void download(java.io.OutputStream outputStream) throws java.io.IOException;
  
  /**
   *<p>Writes asset content with applied conversion to OutputStream supplied as parameter.
   * Functionality is not supported for old revisions of assets.
   * System preferably should be configured so that the conversions are already cached.
   * Remember to close the outputstream!</p>
   * <p>Example:</p>
   * <pre>{@code
   * try (OutputStream outputStream = new FileOutputStream(new File("fileName"))) {<br/>
   * asset.download(outputStream, 'conversionId');<br/>
   * }
   * @param outputStream the outputStream to write asset content to (remember to close it)
   * @param imageConversionConfigurationID existing image conversion configuration id
   * @throws IOException in case something goes wrong while content is written to stream
   * @throws RuntimeException when provided image conversion configuration is invalid or
   * haven't been found
   */
  public abstract void download(java.io.OutputStream outputStream,java.lang.String imageConversionConfigurationID) throws java.io.IOException,java.lang.RuntimeException;
  
  /**
   *Returns the set of Classifications this Asset has been linked into.
   * @return The set of Classifications or the empty set, if none exists.
   */
  public abstract java.util.Set<com.stibo.core.domain.Classification> getClassifications();
  
  /**
   *Returns the file extension of this asset's contents.
   * @return The File extension of this asset's contents or null if no file extension exists.
   */
  public abstract java.lang.String getExtension();
  
  /**
   *Gets the MIME-type of this asset.
   * @return the MIME-type or null if none exists.
   */
  public abstract java.lang.String getMimeType();
  
  /**
   *Get all system Values for this Asset.
   *
   * @return The set of system Value objects or the empty set, if none applies.
   */
  public abstract java.util.Set<com.stibo.core.domain.Value> getSystemValues();
  
  /**
   *Get value of  horisontal resolution xdpi.
   * @return The horisontal resolution, null if asset has no content.
   */
  public abstract java.lang.Float getXdpi();
  
  /**
   *Get value of vertical resolution xdpi.
   * @return The vertical resolution, null if asset has no content.
   */
  public abstract java.lang.Float getYdpi();
  
  /**
   *Checks whether or not the asset have content in current context.
   * @return true if asset has content, false if not.
   */
  public abstract boolean hasContent();
  
  /**
   *Move this asset in the Classification's list of Assets to before the target Asset.
   * @param classification The Classification in which to move this asset.
   * The Asset must presently be linked to the Classification, or nothing will happen.
   * @param target The asset to place this asset before or null if last.
   */
  public abstract void move(com.stibo.core.domain.Classification classification,com.stibo.core.domain.Asset target);
  
  /**
   *Move this asset from the Classification to the new Classification, placing it before the target Asset.
   * @param fromclassification The Classification to move this asset from, asset must presently
   * be linked to this Classification or nothing will happen.
   * @param newclassification The Classification to move this asset to.
   * @param target The Asset to place this Asset before or null if last.
   * @throws UniqueConstraintException if the Asset already exists in new classification
   */
  public abstract void move(com.stibo.core.domain.Classification fromclassification,com.stibo.core.domain.Classification newclassification,com.stibo.core.domain.Asset target) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *Unlink a classification from this asset.
   * @param classification The classification to unlink from the Asset.
   * @throws DetachException Thrown if unlinking the last link to a classifiction from the asset.
   * @throws ObjectNotFoundException Thrown if the Asset isn't linked to the Classification.
   */
  public abstract void removeClassification(com.stibo.core.domain.Classification classification);
  
  /**
   *Set the object type of this asset. Notice that changing the object type bypasses STEPs revision control. The change will not appear in the revision history and cannot be reverted etc.
   * @param objectType - the ObjectType we want the asset to have
   * @throws ObjectTypeConstraintException if object type constraints does not allow the change.
   */
  public abstract void setObjectType(com.stibo.core.domain.ObjectType objectType) throws com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Upload the data content itself of this asset. The content will be visible
   * in the current context only.
   *
   * @param data Input stream providing access to the data content itself.
   * @param orgFileName The original filename (as it was uploaded by the client).
   */
  public abstract void upload(java.io.InputStream data,java.lang.String orgFileName);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\AssetHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for finding assets.
 */
public abstract interface AssetHome {
  
  /**
   *Return an Asset object relating to the identifier supplied
   * @param id The identifier of the Asset object
   * @return the Asset object with the identifier supplied or <code>null</code> if not found
   */
  public abstract com.stibo.core.domain.Asset getAssetByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Assignee.java
====================
package com.stibo.core.domain;

/**
 *Describes a workflow assignee ie. a user or group that has the responsibility of a node in a state in a workflow
 * instances of this type cannot be created - only supplied from a task or looked up using UserHome or GroupHome
 */
public abstract interface Assignee extends com.stibo.core.domain.Node {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Attribute.java
====================
package com.stibo.core.domain;

/**
 *An attribute defines a number of rules that values for this attribute must follow in terms of
 * validation, dimension dependencies, object types that the attributes is valid for, etc
 */
public abstract interface Attribute extends com.stibo.core.domain.ListOfValuesFilter, com.stibo.core.domain.validator.info.ValidatorInfo, com.stibo.core.domain.Node, com.stibo.core.domain.WorkflowableNode, com.stibo.core.domain.DataType {
  
  /**
   *Adds the current attribute to specified attribute group.
   *
   * @param attributeGroup The attribute group that the attribute should be added to
   */
  public abstract void addAttributeGroup(com.stibo.core.domain.AttributeGroup attributeGroup);
  
  /**
   *Get the attribute groups containing this attribute
   * @return The attributeGroups containing this attribute
   */
  public abstract java.util.Set<com.stibo.core.domain.AttributeGroup> getAttributeGroups();
  
  /**
   *Get the difference as a set of strings between the set of attribute links of an incoming source attribute
   * and this attribute.
   * @param sourceAttribute the attribute that this attribute is compared against with respect to attribute links
   * @return if the source attribute has a link to a product that this attribute does not have "ProductLink"
   * is added to the result set, and similar if the source attribute has a link to a classification that this
   * attrubite does not have "ClassificationLink" is added to the result set.
   */
  public abstract java.util.Set<java.lang.String> getAttributeLinkDifferences(com.stibo.core.domain.Attribute sourceAttribute);
  
  /**
   *Return attribute links representing a link between an attribute
   * and a classification or product.
   *
   * @return set of attributeLinks, empty set no links
   * @deprecated Very inefficient, avoid usage if possible at all.
   */
  public abstract java.util.Set<com.stibo.core.domain.AttributeLink> getAttributeLinks();
  
  /**
   *Retrieve the default unit for this attribute (if any). If the attribute is associated with a ListOfValues the
   * default unit will equal the default Unit of the ListOfValues.
   * @return The default unit for this attribute, <code>null</code> if no default unit exists.
   */
  public abstract com.stibo.core.domain.Unit getDefaultUnit();
  
  /**
   *Retrieve the set of dimensions (if any) that this attribute depends on.
   * @return The set of Dimensions that this attribute depends on, the empty set if no such dependencies.
   */
  public abstract java.util.Set<com.stibo.core.domain.Dimension> getDimensionDependencies();
  
  /**
   *Retrieve the associated ListOfValues, if any
   * @return For a medium or a hard domain attribute the associated ListOfValues, for a soft domain attribute null
   */
  public abstract com.stibo.core.domain.ListOfValues getListOfValues();
  
  /**
   *The AttributeLinks of classifications that this attribute is valid for.
   * @return a set of AttributeLinks, the empty set if no links
   * @deprecated Very inefficient, rewritten to non-cached query, please use method queryValidForClassifications, if available.
   * @see Attribute#queryValidForClassifications()
   */
  public abstract java.util.Set<com.stibo.core.domain.AttributeLink> getValidForClassifications();
  
  /**
   *Retrieve the set of ObjectTypes that this attribute is valid for
   * @return The ObjectTypes for which this attribute is valid, empty set if no such ObjectTypes
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getValidForObjectTypes();
  
  /**
   *The AttributeLinks to products that this attribute is valid for
   * @return a list AttributeLinks, the empty set if no links
   * @deprecated Very inefficient, rewritten to non-cached query, please use method queryValidForProducts, if available.
   * @see Attribute#queryValidForProducts()
   */
  public abstract java.util.List<com.stibo.core.domain.AttributeLink> getValidForProducts();
  
  /**
   *Retrieve the set of Units being legal for this attribute (if any)
   * @return set of Units legal for this attribute, the empty set if no such Units
   */
  public abstract java.util.Set<com.stibo.core.domain.Unit> getValidUnits();
  
  /**
   *Investigate whether this attribute is associated with a ListOfValues
   * @return true if the attribute has a ListOfValues associated.
   */
  public abstract boolean hasLOV();
  
  /**
   *Indicates whether or not this attribute is
   * derived (calculated). If derived it makes sense to use the template
   * attribute retrieved via getDerivedAttributeValueTemplate (if available)
   *
   * @return true, if the attribute is derived, false otherwise.
   * @see Attribute#getDerivedAttributeValueTemplate
   */
  public abstract boolean isDerived();
  
  /**
   *Replaces productMode as only two cases are left.
   *
   * @return true if the attribute is descriptive (opposed to specification)
   */
  public abstract boolean isDescription();
  
  /**
   *Investigate whether this attribute is dependent of the language dimension
   * @return true if this attribute is dependent of language, false otherwise
   */
  public abstract boolean isLanguageDependent();
  
  /**
   *The AttributeLinks of classifications that this attribute is valid for.
   * @return non-cached Query of AttributeLinks.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.AttributeLink> queryValidForClassifications();
  
  /**
   *The AttributeLinks to products that this attribute is valid for
   * @return non-cached Query of AttributeLinks.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.AttributeLink> queryValidForProducts();
  
  /**
   *Removes the current attribute from specified attribute group.
   *
   * @param attributeGroup The attribute group to remove the attribute from
   * @throws CannotRemoveAttributeFromLastParentException if an attempt is made to remove the attribute from the only attribute group
   * it is a member of
   */
  public abstract void removeAttributeGroup(com.stibo.core.domain.AttributeGroup attributeGroup) throws com.stibo.core.domain.CannotRemoveAttributeFromLastParentException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\AttributeGroup.java
====================
package com.stibo.core.domain;

/**
 *Domain attribute object that models an attribute group.
 */
public abstract interface AttributeGroup extends com.stibo.core.domain.Node {
  
  /**
   *Notice that in contrast to #getAttributes() there are no ordering of the returned attributes.
   * @return Set of all attributes below this group - including attributes under child attribute groups.
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getAllAttributes();
  
  /**
   *Children that are normal attributes (not attribute groups)
   * @return Set (of Attributes)
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getAttributes();
  
  /**
   *Children of this attributeGroup that are attributeGroups themselves
   * @return Set (of AttributeGroups)
   */
  public abstract java.util.Set<com.stibo.core.domain.AttributeGroup> getChildren();
  
  /**
   *Returns the data container types associated with this attribute group.
   * This does not return types associated with parent attribute groups.
   * @return A set of all data container types associated with this attributegroup, not including types in parent attributegroups.
   */
  public abstract java.util.Set<com.stibo.core.domain.datacontainertype.DataContainerType> getDataContainerTypes();
  
  /**
   *Returns the link/reference types associated with this attribute group.
   * This does not return link/reference types associated with parent attribute groups.
   * @return A set of all link/reference types associated with this attributegroup, not including links in parent attributegroups.
   */
  public abstract java.util.Set<com.stibo.core.domain.LinkType> getLinkTypes();
  
  /**
   *AttributeGroups are organized in a tree (not a dag). Thus all
   * attributeGroups except for the attriGroup root node has only
   * exactly one parent Attribute group.
   * @return parent attribute group (null if this is the root)
   */
  public abstract com.stibo.core.domain.AttributeGroup getParent();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\AttributeGroupHome.java
====================
package com.stibo.core.domain;

/**
 *Home of attribute group. Attributes can be grouped in attribute groups
 * and attribute groups can be contained in other attribute groups
 * forming a tree structure.
 */
public abstract interface AttributeGroupHome {
  
  /**
   *Returns the AttributeGroup object corresponding to the external id passed in
   * @param id - external id of the attributeGroup object e.g. the name of the attribute defintion
   * @return the appropriate AttributeGroup object or null if the external id is invalid
   */
  public abstract com.stibo.core.domain.AttributeGroup getAttributeGroupByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\AttributeHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for finding and creating attributes.
 */
public abstract interface AttributeHome {
  
  /**
   *Returns the Attribute object relating to the identifier supplied.
   * @param id The identifier of the Attribute object.
   * @return The Attribute object with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.Attribute getAttributeByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\AttributeLink.java
====================
package com.stibo.core.domain;

/**
 *A specification attribute can be made valid for a Product either by making an AttributeLink between the Product itself
 * (or one of its parents) to the attribute or by making an an AttributeLink to a Classification (or one of its parents)
 * where the product and classification is further associated via a ClassificationProductLink
 */
public abstract interface AttributeLink extends com.stibo.core.domain.ListOfValuesFilter, com.stibo.core.domain.BaseObject {
  
  /**
   *Delete this AttributeLink. Note: Deleting an attribute link might give rise to the side-effect that values
   * exist on products that are not valid any longer. Such values are denotes as being orphan.
   * @see com.stibo.core.domain.Value#isOrphan()
   */
  public abstract void delete();
  
  /**
   *Retrieve the Attribute of this AttributeLink
   * @return The Attribute of this AttributeLink, should never be null.
   */
  public abstract com.stibo.core.domain.Attribute getAttribute();
  
  /**
   *Get the set of dimension points for this link, if any.
   * Set will contain 1 or more dimension points per dimension dependency of the classification product link edgetype.
   * @return set of DimensionPoints, empty set if no dimension dependencies.
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
  /**
   *Retrieve the Node (Product or Classification) of this AttributeLinke
   * @return The Node (a Product or Classification) of this AttributeLink, should never be <code>null</code>
   */
  public abstract com.stibo.core.domain.WorkspaceRevisableNode getNode();
  
  /**
   *Investigate whether this AttributeLink is mandatory. If the attribute link is mandatory all "child products" of
   * the Node of this AttributeLink must have a value for the Attribute of this link. If the Node is a classification,
   * "child products" includes all products that are linked into the classification
   * or one children of the classification.
   * @return <code>true</code> is this AttributeLink is mandatory, <code>false</code> otherwise.
   */
  public abstract boolean isMandatory();
  
  /**
   *If the attribute link is mandatory all child products of
   * <code>Node</code> must have a value for <code>Attribute</code>
   * 
   * @param value boolean about mandatory
   */
  public abstract void setMandatory(boolean value);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\BaseObject.java
====================
package com.stibo.core.domain;

/**
 *Common interface for objects that can have values. BaseObject subtypes
 * either represent Nodes or relationships between Nodes (Edges).
 */
public abstract interface BaseObject extends com.stibo.core.domain.DomainObject, java.lang.Comparable<com.stibo.core.domain.BaseObject> {
  
  /**
   *Returns the localized Value held by this Node/Edge for a given attribute.
   *
   * @param attribute The attribute we want the value for
   * @return The appropriate Value object.
   * A Value object will be returned regardless of whether a value is set or not and
   * regardless of whether the current user has privileges to see the actual value or not.
   */
  public abstract com.stibo.core.domain.Value getLocalizedValue(com.stibo.core.domain.Attribute attribute);
  
  /**
   *Manager that this object was retrieved from.
   * @return  the manager of this object.
   */
  public abstract com.stibo.core.domain.Manager getManager();
  
  /**
   *Returns the Value held by this Node/Edge for a given attribute.
   * Notice: You should not call this method from Javascript since
   * it does not support method overloading. This means that when calling
   * getValue() with one argument, it will call the getValue() method
   * that takes an attributeID as argument.
   *
   * @param attribute The attribute we want the value for.
   * @return The appropriate Value object.
   * A Value object will be returned regardless of whether a value is set or not and
   * regardless of whether the current user has privileges to see the actual value or not.
   */
  public abstract com.stibo.core.domain.Value getValue(com.stibo.core.domain.Attribute attribute);
  
  /**
   *Returns the Value held by this Node/Edge for the attribute with the given id.
   * @param attributeid The id of the attribute w$e want the value for.
   * @return The appropriate value object.
   * A Value object will be returned regardless of whether a value is set or not and
   * regardless of whether the current user has privileges to see the actual value or not.
   * @throws IllegalArgumentException if the attribute does not exists.
   */
  public abstract com.stibo.core.domain.Value getValue(java.lang.String attributeid);
  
  /**
   *For instances of Product, Asset, Classification, and Entity, the method will return Value objects for all
   * description attributes that are valid for the object type (excluding asset system values like asset.filename).
   * <p>
   * For instances of Product the method will also return Value objects for all specification attributes that are
   * linked in at or above the product, and can potentially have a value (regardless of whether the attribute is
   * valid for the current product object type or not). Furthermore, Value objects for specification attributes
   * that are not linked in at or above the product but do have a value will be returned (Value.isOrphan()
   * will return true for this case).
   * <p>
   * For other instances of BaseObject, the method will return Value objects for all description attributes that
   * are valid for the type.
   *
   * @return set of Value objects
   */
  public abstract java.util.Set<com.stibo.core.domain.Value> getValues();
  
  /**
   *Sets the attribute value with the string specified.
   *
   * @param attribute The defining attribute to set value of.
   * @param attribValue The new value for the attribute, null means that values should be deleted.
   * @throws ValidatorException Thrown if value does not conform to validation of attribute.
   */
  public abstract void setSimpleValue(com.stibo.core.domain.Attribute attribute,java.lang.String attribValue) throws com.stibo.core.domain.ValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\CannotRemoveAttributeFromLastParentException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when removing attribute from attribute group and it is the last link
 * to attribute groups for the attribute (attribute must exist in minimum one attribute group).
 */
public class CannotRemoveAttributeFromLastParentException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Classification.java
====================
package com.stibo.core.domain;

/**
 *A Node representing a Classification in the 'yellow' hierarchy.
 */
public abstract interface Classification extends com.stibo.core.domain.datacontainertypelink.DataContainerTypeLinkable, com.stibo.core.domain.attributelink.AttributeLinkable, com.stibo.core.domain.Node, com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.WorkflowableNode, com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode, com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.translation.TranslatableNode, com.stibo.core.domain.WorkspaceRevisableTreeNode<com.stibo.core.domain.Classification> {
  
  /**
   *Link an Asset into this Classification.
   *
   * @param asset Asset to link in.
   * @throws UniqueConstraintException Thrown if the Asset has already been linked into the Classification.
   */
  public abstract void addAsset(com.stibo.core.domain.Asset asset) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *Creates a new asset with the specified ID and object type and links it to the classification
   * for which the method is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter.<br/>
   * If an asset with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new asset. Can be null or the empty string if auto IDs are configured
   * @param objectType The the object type of the new asset
   * @return The newly created asset
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted asset
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.Asset createAsset(java.lang.String id,com.stibo.core.domain.ObjectType objectType) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Creates a new asset with the specified ID and object type and links it to the classification
   * for which the method is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter.<br/>
   * If an asset with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new asset. Can be null or the empty string if auto IDs are configured
   * @param objectTypeID The ID of the object type of the new asset
   * @return The newly created asset
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted asset
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.Asset createAsset(java.lang.String id,java.lang.String objectTypeID) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Creates a new classification with the specified ID and object type as a child to the
   * classification for which the method is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter.<br/>
   * If a classification with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new classification. Can be null or the empty string if auto IDs are configured
   * @param objectType The object type of the new classification
   * @return The newly created classification
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted classification
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.Classification createClassification(java.lang.String id,com.stibo.core.domain.ObjectType objectType) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Creates a new classification with the specified ID and object type as a child to the
   * classification for which the method is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter.<br/>
   * If a classification with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new classification. Can be null or the empty string if auto IDs are configured
   * @param objectTypeID The ID of the object type of the new classification
   * @return The newly created classification
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted classification
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.Classification createClassification(java.lang.String id,java.lang.String objectTypeID) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Constructs a new ClassificationProductLink object. This will link the Product in question into the Classification at hand.
   * @param product Product part of the link.
   * @param type The type of the new link.
   * @return The ClassificationProductLink created.
   * @throws UniqueConstraintException if the link already exists.
   * @throws LinkTypeNotValidException if the product link type is not valid for the product
   */
  public abstract com.stibo.core.domain.ClassificationProductLink createClassificationProductLink(com.stibo.core.domain.Product product,com.stibo.core.domain.ClassificationProductLinkType type) throws com.stibo.core.domain.UniqueConstraintException,com.stibo.core.domain.LinkTypeNotValidException;
  
  /**
   *Gets the set of assets that are linked into this Classification.
   * List is sorted only if manually sorted, otherwise "random" order is returned.
   * Warning - using this operation loads all child assets into memory.
   * This can cause the application server to run out of memory, as there can be +100.000 assets under some classification.
   * So this method should only be used, if the classification is manually sorted, and you need to get the assets in the
   * manually sorted order. Notice, that it does not make sense to have large number of assets that are manually sorted.
   * If you are do not need the assets in manually sorted order, you should instead use #queryAssets()
   *
   * @return Set of Assets, or the empty set if no assets linked.
   * @see ObjectType#isManuallySorted()
   */
  public abstract java.util.List<com.stibo.core.domain.Asset> getAssets();
  
  /**
   *Returns the List of children for this Classification.
   * Notice that the list is filtered for contexts and view privileges.
   * The list is sorted only if manually sorted, otherwise "random" order is returned.
   * Warning - using this operation loads all child classification into memory.
   * This can cause the application server to run out of memory, as there can be +100.000 child classifications under some classification.
   * So this method should only be used, if the classification is manually sorted, and you need to get the classifications in the
   * manually sorted order. Notice, that it does not make sense to have large number of child classifications that are manually sorted.
   * If you are do not need the child classifications in manually sorted order, you should instead use #queryChildren()
   * @return The List of children for this Classification or an empty list of none exists.
   * @see ObjectType#isManuallySorted()
   */
  public abstract java.util.List<com.stibo.core.domain.Classification> getChildren();
  
  /**
   *Returns all ClassificationProductLinks representing links between the Classification at hand and a product.
   * The list is sorted only if manually sorted, otherwise "random" order is returned.
   *
   * Ownership is not taken into account in this method.
   *
   * @return A List of ClassificationProductLinks or an empty list if none exists.
   * @see ObjectType#isManuallySorted()
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract java.util.List<com.stibo.core.domain.ClassificationProductLink> getClassificationProductLinks();
  
  /**
   *Returns the parent Classification.
   * @return the parent Classification or null if it is the root Classification.
   */
  public abstract com.stibo.core.domain.Classification getParent();
  
  /**
   *Returns the user group associated with this classification, if it is a vendor root classification.
   * <p/>
   * Returns null if it is not a vendor root classification or if there is no associated user group.
   *
   * @return The user group or <code>null</code>
   */
  public abstract com.stibo.core.domain.Group getVendorGroup();
  
  /**
   *Checks whether this Classification is an Index Word or not.
   * @return True is this Classification is an Index Word, false otherwise.
   */
  public abstract boolean isIndexWord();
  
  /**
   *Gets the set of assets that are linked into this Classification.
   * Notice, that the assets are not returned in any particular order, while iterating.
   * So if the classification is "manually sorted", and you need to access the assets in the manually sorted order, you should instead use #getAssets()
   *
   * @return result set that can be iterated.
   * @see ObjectType#isManuallySorted()
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Asset> queryAssets();
  
  /**
   *Query the ClassificationProductLinks between this classification and products.
   *
   * Ownership is not taken into account in this method.
   *
   * @return A Query of ClassificationProductLinks between this classification and products.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.ClassificationProductLink> queryClassificationProductLinks();
  
  /**
   *Unlink an asset from this classification.
   * @param asset Asset to unlink.
   * @throws DetachException Thrown if unlinking the last link to a classifiction from the asset.
   * @throws ObjectNotFoundException Thrown if Asset isn't linked to this Classification
   */
  public abstract void removeAsset(com.stibo.core.domain.Asset asset);
  
  /**
   *Sets a parent on this classification thereby moving the classification itself and it's sub-hierarchy to a new place
   * in the classification hierarchy.
   * This method is not supported on revised classifications, this will trigger a RuntimeException to be thrown.
   * @param parent The new parent, must be a valid non-null classification. This parent cannot be the top-level classification.
   * @throws ObjectTypeConstraintException Thrown if the object-type of this classification is not allowed under the new parent.
   * @throws CycleConstraintException Thrown if attempting to move the product classification itself either directly or indirectly.
   * @throws UnsupportedOperationException Thrown if called on the root classification in the Classification hierarchy.
   * @throws IllegalArgumentException Thrown if parent argument is null.
   */
  public abstract void setParent(com.stibo.core.domain.Classification parent) throws com.stibo.core.domain.ObjectTypeConstraintException,com.stibo.core.domain.CycleConstraintException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ClassificationHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for finding Classifications.
 */
public abstract interface ClassificationHome {
  
  /**
   *Returns a Classification object relating to the identifier supplied.
   * @param id The identifier of the Classification object.
   * @return The Classification object with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.Classification getClassificationByID(java.lang.String id);
  
  /**
   *Gets the root classification in the Classification hierarchy.
   *
   * @return the root classification in the Classification hierarchy.
   */
  public abstract com.stibo.core.domain.Classification getTopClassification();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ClassificationProductLink.java
====================
package com.stibo.core.domain;

/**
 *Via the ClassificationProductLink a product can become member of a classification structure anchored
 * via the related classification. A product inherits lists of legal attributes and table definitions through
 * the classification links. Ownership of a ClassificationProductLink can be set to be either the classification
 * or the product and approval will react accordingly.
 */
public abstract interface ClassificationProductLink extends com.stibo.core.domain.Link {
  
  /**
   *Get the classification of this link.
   * @return the classification of this link
   */
  public abstract com.stibo.core.domain.Classification getClassification();
  
  /**
   *Get the type of this classification product link.
   * @return type of this classification product link.
   */
  public abstract com.stibo.core.domain.ClassificationProductLinkType getLinkType();
  
  /**
   *Get the product of this link.
   * @return the product of this link
   */
  public abstract com.stibo.core.domain.Product getProduct();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ClassificationProductLinkList.java
====================
package com.stibo.core.domain;

/**
 *List  of classification product links  that are characterized by having local origin, an origin inherited by parent
 * or an origin inherited via the product override hierarchy, a specific classification product link type,
 * and a source product being the product from where the links appears.
 */
public abstract interface ClassificationProductLinkList extends com.stibo.core.domain.LinkList<com.stibo.core.domain.ClassificationProductLink> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ClassificationProductLinkMap.java
====================
package com.stibo.core.domain;

/**
 *A map of links classification product links.
 * Use get() and values() to get links grouped by reference type. Using asList you get a flat list of all links.
 */
public abstract interface ClassificationProductLinkMap extends com.stibo.core.domain.LinkMap<com.stibo.core.domain.ClassificationProductLinkType,com.stibo.core.domain.ClassificationProductLinkList,com.stibo.core.domain.ClassificationProductLink> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ClassificationProductLinkType.java
====================
package com.stibo.core.domain;

/**
 *Instances of ClassificationProductLinkType is a node used for holding the definition of a type of link
 * relating products and classifications
 */
public abstract interface ClassificationProductLinkType extends com.stibo.core.domain.LinkType {
  
  /**
   *Returns the Classification ObjectTypes that this ClassificationProductLinkType is valid for.
   * @return Set<ObjectType> The set of Classification ObjectTypes that this ClassificationProductLinkType is valid for.
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getValidClassificationObjectTypes();
  
  /**
   *Returns the Product ObjectTypes that this ClassificationProductLinkType is valid for.
   * @return Set<ObjectType> The set of Product ObjectTypes that this ClassificationProductLinkType is valid for.
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getValidProductObjectTypes();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Context.java
====================
package com.stibo.core.domain;

/**
 *A Context points out a DimensionPoint for each Dimension. Viewing and editing data resolved via the dimensions
 * of a context is what enables STEP users to work with "layers".
 */
public abstract interface Context extends com.stibo.core.domain.Node, com.stibo.core.domain.ReferenceTarget {
  
  /**
   *The dimension point for the context in the given dimension.
   * @param dimension The dimension to get dimension point for.
   * @return the dimension point in the given dimension
   */
  public abstract com.stibo.core.domain.DimensionPoint getDimensionPoint(com.stibo.core.domain.Dimension dimension);
  
  /**
   *Retrieve the dimension points of this context, always being exactly one DimensionPoint from each Dimension
   * of the current STEP system
   * @return set of DimensionPoints associated with this context, cannot be <code>null</code>
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
  /**
   *Get the locale of this context.
   * US locale is returned if no locale has been set for this context.
   * @return Locale configured for this
   */
  public abstract java.util.Locale getLocale();
  
  /**
   *Investigate  whether a set of DimensionPoints is visible in this context.
   * To be visible a least one dimension point for each dimension must be visible.
   * Visibility follow the rules of inheritance that exists among the DimensionPoints of a given
   * Dimension that is a DimensionPoint being a parent is also visible to the children DimensionPoints (if any).
   * @param dimensionPoints the set of DimensionPoints to check visible for
   * @return boolean - true if the set of DimensionPoints given as input is visible, false otherwise
   */
  public abstract boolean isVisible(java.util.Set<com.stibo.core.domain.DimensionPoint> dimensionPoints);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ContextHome.java
====================
package com.stibo.core.domain;

/**
 *Interface used to provide access to read and maintain STEP Contexts.
 */
public abstract interface ContextHome {
  
  /**
   *Returns the context object with the supplied ID
   *
   * @param id The ID of the context to retrieve
   * @return A context object with the supplied ID or null if no such context exists
   */
  public abstract com.stibo.core.domain.Context getContextByID(java.lang.String id);
  
  /**
   *Returns a Set of all Context objects held in the STEP database.
   * @return A Context object for every context registered in the STEP database.
   */
  public abstract java.util.Set<com.stibo.core.domain.Context> getContexts();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\CycleConstraintException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when trying to make cyclic references between Objects,
 * e.g. when trying to make the parent of a product the child of the very same product.
 */
public class CycleConstraintException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DataType.java
====================
package com.stibo.core.domain;

/**
 *Interface for data types in STEP. Current data types are attributes, link types and data container types.
 */
public abstract interface DataType extends com.stibo.core.domain.DimensionDefiningType, com.stibo.core.domain.Node {
  
  /**
   *Is the current DataType inherited?
   *
   * @return true if value is inherited.
   */
  public abstract boolean isInherited();
  
  /**
   *Is the DataType mandatory?
   *
   * @return true if the DataType is mandatory.
   */
  public abstract boolean isMandatory();
  
  /**
   *Whether the attribute is multivalued.
   *
   * @return true if attribute is multivalued
   */
  public abstract boolean isMultiValued();
  
  /**
   *Whether the attribute is under revision control.
   *
   * @return true if Attribute is under revision-control
   */
  public abstract boolean isRevised();
  
  /**
   *Specify if the DataType is mandatory or not.
   *
   * @param value true if mandatory, false if not
   */
  public abstract void setMandatory(boolean value);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DependencyException.java
====================
package com.stibo.core.domain;

/**
 *Thrown when an action cannot be completed due to dependencies,
 *   e.g. when trying to delete a UnitGroup still containing Units
 */
public class DependencyException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Dimension.java
====================
package com.stibo.core.domain;

/**
 *A Dimension represents a dimension along which values can change. Example are language, country and market.
 * Attributes can be declared as being dimension dependent, which means that the values of such
 * attributes will dependent of e.g. language. Also links, references, and even classification hierarchies
 * can be dimension dependent. Dimensions are very fundamental in STEP and any changes done to the
 * configuration of dimensions should be done very carefully only by very privileged STEP administrators.
 */
public abstract interface Dimension extends com.stibo.core.domain.Node {
  
  /**
   *Get all DimensionPoints associated with this Dimension.
   * @return The DimensionPoints associated with this dimension, the empty set if no such DimensionPoints exists.
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getAllDimensionPoints();
  
  /**
   *Get the top dimension point of this dimension
   * @return The top dimension point or null if not created yet
   */
  public abstract com.stibo.core.domain.DimensionPoint getTopDimensionPoint();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DimensionDefiningType.java
====================
package com.stibo.core.domain;

/**
 *Interface for types in STEP, that defines dimension-dependencies of its related data
 * (e.g. ReferenceType and Reference).
 */
public abstract interface DimensionDefiningType {
  
  /**
   *Get the set of dimensions this depends on.
   * @return The Dimensions that this depends on.
   */
  public abstract java.util.Set<com.stibo.core.domain.Dimension> getDimensionDependencies();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DimensionHome.java
====================
package com.stibo.core.domain;

/**
 *Global access to Dimensions, which represents a dimension along which values can change. Example are language, country and market.
 * Attributes can be declared as being dimension dependent, which means that the values of such
 * attributes will dependent of e.g. language. Also links and references can be dimension dependent.
 * Dimension contain DimensionPoints, which are points along a dimension. For example a particular language in the language Dimension.
 * Dimensions are very fundamental in STEP and any changes done to the
 * configuration of dimensions should be done very carefully only by very privileged STEP administrators.
 */
public abstract interface DimensionHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Return a Dimension object relating to the external identifier supplied
   * @param id - The external identifier of the domain object
   * @return the appropriate Dimension object or null if the identifier was not valid
   */
  public abstract com.stibo.core.domain.Dimension getDimensionByID(java.lang.String id);
  
  /**
   *Get all the dimensions in the system. The dimensions are sorted by their priority.
   * If there are no dimensions in the system it will be an empty list returned.
   * @return The dimensions in the system as Dimension objects
   */
  public abstract java.util.List<com.stibo.core.domain.Dimension> getDimensions();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DimensionPoint.java
====================
package com.stibo.core.domain;

/**
 *A point along a dimension. For example a particular language in the language Dimension.
 * DimensionPoints of the same Dimension are arranged in a tree structure with a single top
 * DimensionPoint. The tree structure specifies the inheritance relationship which is very important
 * when considering visibility of values, links, references, and/or context names.
 */
public abstract interface DimensionPoint extends com.stibo.core.domain.Node {
  
  /**
   *Retrieve the set of all first order child DimensionPoints of this DimensionPoint
   * @return The set of all first order child DimensionPoints of this DimensionPoint,
   * the empty set if no such children
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getChildren();
  
  /**
   *Retrieve the contexts referencing this DimensionPoint.
   * @return The contexts referencing this DimensionPoint, the empty Set if no such contexts
   */
  public abstract java.util.Set<com.stibo.core.domain.Context> getContexts();
  
  /**
   *Retrieve the Dimension the DimensionPoint is associated with.
   * @return The Dimension that this DimensionPoint belongs s associated with, cannot be <code>null</code>.
   */
  public abstract com.stibo.core.domain.Dimension getDimension();
  
  /**
   *Retrieve the parent dimension point of this dimension point.
   * @return The parent dimension point of this dimension point, <code>null</code> if this DimensionPoint is the top
   * DimensionPoint of the Dimension.
   */
  public abstract com.stibo.core.domain.DimensionPoint getParent();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DimensionPointHome.java
====================
package com.stibo.core.domain;

/**
 *Interface providing access to dimension points
 */
public abstract interface DimensionPointHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Returns the dimension point with supplied id.
   * @param id The ID of the dimension point to retrieve.
   * @return Dimension point with supplied ID or null if no such dimension point exists.
   */
  public abstract com.stibo.core.domain.DimensionPoint getDimensionPointByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DomainException.java
====================
package com.stibo.core.domain;

/**
 *Base exception for checked domain exceptions
 */
public abstract class DomainException extends java.lang.Exception {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\DomainObject.java
====================
package com.stibo.core.domain;

/**
 *Common denominator for domain objects used in persistent modelling of STEP.
 * Serves to create the top in the interface/class-hierarchy in order to clean
 * up code, and exploit generics better.
 *
 * 
 *
 * So far, there are common traits shared beyond the interface itself.
 */
public abstract interface DomainObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Executor.java
====================
package com.stibo.core.domain;

/**
 *The Executor interface is the main entry point into the domain (business) layer (together with the execute method).
 * Any use of the domain layer should be done inside an Executor.execute() or ThrowsExecutor.execute() implementation.
 *
 * Executor to execute some action with a given manager.
 * @param <T> Object of type T to return.
 */
public abstract interface Executor<T extends java.lang.Object> {
  
  /**
   *The execute method should be implemented to gain client access to the domain layer.
   * @param manager The manager instance that gives the client of the domain layer access to the domain layer
   * @return an object encapsulating the result.
   */
  public abstract T execute(com.stibo.core.domain.Manager manager);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Group.java
====================
package com.stibo.core.domain;

/**
 *A Group is a group of users with certain privileges. Groups can be nested making a tree with the Users as leaf nodes.
 * A User can be member of multiple Groups in which case the privileges of such a user becomes the super set of the
 * privileges attached to the Groups having the User as a member.
 */
public abstract interface Group extends com.stibo.core.domain.Node, com.stibo.core.domain.Assignee {
  
  /**
   *Add a user to this group
   * @param user the user to add
   */
  public abstract void addUser(com.stibo.core.domain.User user);
  
  /**
   *Method for creating a new user group below current.
   *
   * @param id  the ID of the new group
   * @return the created group
   * @throws NodeIdUniqueConstraintException if a user group with the specified ID already exists
   */
  public abstract com.stibo.core.domain.Group createGroup(java.lang.String id) throws com.stibo.core.domain.NodeIdUniqueConstraintException;
  
  /**
   *<p>Create a new user that is initially associated with this group.</p>
   *
   * <p> The user is created without a password which means that unless an alternative identity provider such as LDAP or similar is in effect, it will not be possible to log in using the account until a password has been created.</p>
   *
   * <p> The user id can only contain uppercase characters. Any lowercase characters will be changed to uppercase.</p>
   *
   * @param id the user id
   * @return the new user
   *
   * @throws NodeIdUniqueConstraintException if a user with supplied id already exists.
   * @throws TooManyUsersException if the user could not be created due to the number of named users in the license being exceeded.
   */
  public abstract com.stibo.core.domain.User createUser(java.lang.String id) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.license.TooManyUsersException;
  
  /**
   *<p>Create a new user with a password and optional e-mail address that is initially associated with this group.</p>
   *
   * <p> The user id can only contain uppercase characters. Any lowercase characters will be changed to uppercase.</p>
   *
   * @param id the user id
   * @param password the password
   * @param eMailAddress optional e-mail address
   * @return the new user
   * @throws NodeIdUniqueConstraintException if a user with supplied id already exists.
   * @throws TooManyUsersException if the user could not be created due to the number of named users in the license being exceeded.
   */
  public abstract com.stibo.core.domain.User createUser(java.lang.String id,java.lang.String password,java.lang.String eMailAddress) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.license.TooManyUsersException;
  
  /**
   *Retrieve the collection of first order child Groups of this Group (if any).
   * @return The collection of first order child Groups, the empty collection if no such children exists.
   */
  public abstract java.util.Collection<com.stibo.core.domain.Group> getChildren();
  
  /**
   *The parent Group of this Group
   * @return The parent Group of this Group or <code>null</code> if this Group is a top level Group.
   */
  public abstract com.stibo.core.domain.Group getParent();
  
  /**
   *Get the Users in this Group. Users of child Groups are not considered (no recursion).
   *
   * @return The Collection of Users in this group, the empty collection if no such Users exist.
   * @deprecated Consider using {@link #queryUsers()} instead since the set returned here
   * might be quite large and its capped at 10000 results.
   */
  public abstract java.util.Collection<com.stibo.core.domain.User> getUsers();
  
  /**
   *Get the vendor classification associated with this vendor user group.
   *
   * @return the vendor classification or null if this is not a vendor user group.
   */
  public abstract com.stibo.core.domain.Classification getVendorRoot();
  
  /**
   *Investigate whether a User is a member of this Group or one of the children of this Group.
   * Investigation is done recursively in the sub tree of this Group.
   * @param user User to check the membership for.
   * @return true if the user is a member of this group (or a child group), false otherwise
   */
  public abstract boolean isMember(com.stibo.core.domain.User user);
  
  /**
   *Return whether this group represents a vendor group (with a vendor link either directly or on one of its parents).
   * @return true if vendor group, false if not.
   */
  public abstract boolean isVendor();
  
  /**
   *Queries all users in this group and its nested groups.
   *
   * @return query instance
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.User> queryAllUsers();
  
  /**
   *Query the Users in this Group. Users of child Groups are not considered (no recursion).
   *
   * @return query instance
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.User> queryUsers();
  
  /**
   *Remove a user from this group
   * @param user the user
   */
  public abstract void removeUser(com.stibo.core.domain.User user);
  
  /**
   *Move group to another parent group
   * @param group The new parent group or <code>null</code> to make this group top level.
   */
  public abstract void setParent(com.stibo.core.domain.Group group);
  
  /**
   *Mark this user group as a vendor user group. The items for the vendor is stored under the vendor classification.
   *
   * @param vendor the classification that holds the vendor structure.
   * @throws UniqueConstraintException if vendor root has been already set.
   */
  public abstract void setVendorRoot(com.stibo.core.domain.Classification vendor) throws com.stibo.core.domain.UniqueConstraintException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\GroupHome.java
====================
package com.stibo.core.domain;

/**
 *Interface for creating and finding User Groups.
 */
public abstract interface GroupHome {
  
  /**
   *Return a Group object relating to the identifier supplied.
   * @param id The identifier of the Group object.
   * @return The Group object with the identifier supplied or <code>null</code> if not is found.
   */
  public abstract com.stibo.core.domain.Group getGroupByID(java.lang.String id);
  
  /**
   *Query all user groups in the system
   * @return result query of groups in the system
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Group> queryAllGroups();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ImageParserException.java
====================
package com.stibo.core.domain;

/**
 *Thrown if STEP fails to parse an image
 */
public class ImageParserException extends java.lang.RuntimeException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Link.java
====================
package com.stibo.core.domain;

/**
 *Link - common super interface for Reference and ClassificationProductLink
 */
public abstract interface Link extends com.stibo.core.domain.BaseObject {
  
  /**
   *Delete this link
   */
  public abstract void delete();
  
  /**
   *Delete this link (including all its directly sub-ordinate suppressions if it is not itself suppressed).
   */
  public abstract void deleteIncludingSuppressions();
  
  /**
   *Get the DimensionPoint's determining the visibility of the reference in contexts.
   *
   * @return If the reference in not dimension dependent the empty set,
   * otherwise the relevant set of dimension points
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
  /**
   *Get the type of this link.
   * @return type of this link.
   */
  public abstract com.stibo.core.domain.LinkType getLinkType();
  
  /**
   *Is the classification product link inherited in the current context?
   *
   * @return true if inherited in any dimension, false if local.
   */
  public abstract boolean isDimensionPointInherited();
  
  /**
   *Is this object suppressed?
   * @return true if true, false if not.
   */
  public abstract boolean isSuppressed();
  
  /**
   *Set new set of dimension points. Set must conform to following constraints:
   * At least one dimension point per dimension dependency of the link
   * and dimension points must be unrelated (not inheriting from each other)
   *
   * @param dimensionPoints Set of dimension points to set
   */
  public abstract void setDimensionPoints(java.util.Set<com.stibo.core.domain.DimensionPoint> dimensionPoints);
  
  /**
   *Suppress this un-suppressed object in the dimension-points given.
   * @param dimensionpoints Sets of points to suppress
   * @throws UniqueConstraintException if a suppresion already exists, or will shadow a real link
   */
  public abstract void suppress(java.util.Set<com.stibo.core.domain.DimensionPoint> dimensionpoints) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *Un-suppress this object in the dimension-points given.
   * If no suppresssion exist, or this link is itself a suppression, it will do nothing.
   * If a matching suppression exist, it will be deleted.
   * Further sub-ordinate suppressions will be left alive; notice that this behaviour is different to delete().
   * @param dimensionpoints Sets of points to un-suppress
   */
  public abstract void unSuppress(java.util.Set<com.stibo.core.domain.DimensionPoint> dimensionpoints);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LinkList.java
====================
package com.stibo.core.domain;

/**
 *List  of links (or references) that are characterized by having local origin, an origin inherited by parent
 * or an origin inherited via the product override hierarchy (the latter only possible when the origin is a product),
 * a specific (link/reference) type, and a source node being the node from where the link / reference appears.
 */
public abstract interface LinkList<T extends java.lang.Object> extends java.util.List<T> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LinkMap.java
====================
package com.stibo.core.domain;

/**
 *A map of links (references of classification product links).
 * Use get() and values() to get links grouped by reference type. Using asList you get a flat list of all links.
 */
public abstract interface LinkMap<TTYPE extends com.stibo.core.domain.LinkType,TLIST extends com.stibo.core.domain.LinkList<T>,T extends java.lang.Object> extends java.util.Map<TTYPE,TLIST> {
  
  /**
   *List of all references in map independent of the LinkType
   * @return List of all references in map independent of the LinkType, empty list if no references
   */
  public abstract java.util.List<T> asList();
  
  /**
   *Set of all references in map independent of the LinkType
   * @return Set of all references in map independent of the LinkType, empty set if no references
   */
  public abstract java.util.Set<T> asSet();
  
  /**
   *Get a list of links by type ID
   * @param typeID ID of the type
   * @return List of links.
   */
  public abstract TLIST getByTypeID(java.lang.String typeID);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LinkType.java
====================
package com.stibo.core.domain;

/**
 *Instances of LinkType is a node used for holding the definition of a link/reference type
 */
public abstract interface LinkType extends com.stibo.core.domain.baseobjecttype.BaseObjectType, com.stibo.core.domain.DataType {
  
  /**
   *Adds the current link type to the specified group.
   *
   * @param attributeGroup The group to add current link type to
   * @return true if the current link type was added to the specified group
   */
  public abstract boolean addAttributeGroup(com.stibo.core.domain.AttributeGroup attributeGroup);
  
  /**
   *This method gets the linked attribute groups
   * @return The AttributeGroups using this linktype
   */
  public default java.util.Set<com.stibo.core.domain.AttributeGroup> getAttributeGroups() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Are the links/references of this LinkType accumulative inherited?
   *
   * @return true if value is accumulative inherited.
   */
  public abstract boolean isAccumulated();
  
  /**
   *Removes the current link type from the specified group.
   *
   * @param attributeGroup The group to remove the current link type from
   * @return true if the current link type was removed from the specified group
   */
  public abstract boolean removeAttributeGroup(com.stibo.core.domain.AttributeGroup attributeGroup);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LinkTypeHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for access to LinkTypes.
 */
public abstract interface LinkTypeHome {
  
  /**
   *Get the ClassificationProductLinkType with the supplied identifier.
   * @param id The identifier of the ClassificationProductLinkType object
   * @return  The ClassificationProductLinkType with the identifier supplied or <code>null</code> if not found.
   * @deprecated Use {@link ClassificationProductLinkTypeHome#getLinkTypeByID(String)} instead.
   */
  public abstract com.stibo.core.domain.ClassificationProductLinkType getClassificationProductLinkTypeByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LinkTypeNotValidException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when trying to create a reference/link on/to an object,
 * where source node and/or target node is not valid according to reference/link type definition.
 */
public class LinkTypeNotValidException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ListOfValues.java
====================
package com.stibo.core.domain;

/**
 *A ListOfValue (often just called a LOV) defines a limited set a values to be used with attributes. Attributes
 * associated with a ListOfValues are characterized as being hard or medium domain referring to the fact that
 * the current set of values always are a subset of the possible values held by the ListOfValues, as opposed to soft
 * domain attributes where all values have to be traversed in order to find the values currently in use.
 */
public abstract interface ListOfValues extends com.stibo.core.domain.validator.info.ValidatorInfo, com.stibo.core.domain.DimensionDefiningType, com.stibo.core.domain.Node, com.stibo.core.domain.WorkflowableNode {
  
  /**
   *Create a value for this list of value in current context.
   * Notice that the unit will not be made valid for this LOV automatically.
   *
   * @param value The value to set
   * @param unit  The unit of the value. Is automatic validated
   * @return A newly created ListOfValuesValue object
   * @throws ValueValidatorException                                            if the validator of this LOV violated.
   * @throws TagValidatorException                                              if the value contain invalid tags
   * @throws com.stibo.core.domain.validatorexception.ValueIDValidatorException If passed externalID is not unique in LOV
   */
  public abstract com.stibo.core.domain.ListOfValuesValue createListOfValuesValue(java.lang.String value,com.stibo.core.domain.Unit unit) throws com.stibo.core.domain.ValueValidatorException,com.stibo.core.domain.TagValidatorException,com.stibo.core.domain.validatorexception.ValueIDValidatorException;
  
  /**
   *Create a value for this list of value in current context.
   * Notice that the unit will not be made valid for this LOV automatically.
   * If this is a hard LOV and a valueID is set to null or an empty string
   * an autoid will be set if a valueIDPattern has been defined on this ListOfValues.
   *
   * @param value   The value to set
   * @param unit    The unit of the value. Is automatic validated
   * @param valueID If hard LOV, a value ID for the value. If this is not set or is an empty value and valueIDPattern is set we set an autoid for this instead.
   * @return A ListOfValuesValue object
   * @throws ValueValidatorException                                            if the validator of this LOV violated.
   * @throws TagValidatorException                                              if the value contain invalid tags
   * @throws com.stibo.core.domain.validatorexception.ValueIDValidatorException If passed externalID is not unique in hard LOV
   */
  public abstract com.stibo.core.domain.ListOfValuesValue createListOfValuesValue(java.lang.String value,com.stibo.core.domain.Unit unit,java.lang.String valueID) throws com.stibo.core.domain.ValueValidatorException,com.stibo.core.domain.TagValidatorException,com.stibo.core.domain.validatorexception.ValueIDValidatorException;
  
  /**
   *Returns the default unit for this LOV.
   *
   * @return Default unit for LOV or <code>null</code> if no default has been configured.
   */
  public abstract com.stibo.core.domain.Unit getDefaultUnit();
  
  /**
   *Get the ListOfValuesValue uniquely identified by a given identifier (sometimes called "the external identifier")
   *
   * @param listOfValuesValueID the identifier of the listOfValuesValue of this ListOfValues
   * @return ListOfValuesValue identified by the identifier, null if no listOfValueValue exists for the given identifier
   * @throws ValueValidatorException if ListOfValues does not use identifiers
   */
  public abstract com.stibo.core.domain.ListOfValuesValue getListOfValuesValueByID(java.lang.String listOfValuesValueID) throws com.stibo.core.domain.ValueValidatorException;
  
  /**
   *Investigate whether this ListOfValue has a medium domain which means that new values can be added dynamically. If
   * for instance a value on an LOV based attribute of a given product is set to a value that does not exist in the LOV
   * then that value will be added automatically, while for hard domain LOVs this would give rise to an error.
   *
   * @return <code>true</code> if the edit type of the LOV is medium, false if the domain is hard.
   */
  public abstract boolean isMedium();
  
  /**
   *Checks whether or not the List of Values uses value IDs.
   *
   * @return boolean indicating whether or not value IDs are used.
   */
  public abstract boolean isUsingValueIDs();
  
  /**
   *Returns a Query with the attributes that reference this ListOfValues object.
   * Note that calling asList on this query will be limited to 100 results regardless of limit set as parameter.
   *
   * @return Query<Attribute> containing the attributes referencing this ListOfValues.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Attribute> queryUsedByAttributes();
  
  /**
   *Returns a Query with the ListOfValuesValues valid for this ListOfValues.
   * <p/>
   * Query will contain all ListOfValuesValues regardless of whether these have a value in current context or not.
   * Note that for the returned query, Query.asList(int limit) is limited to returning a maximum of 100 results regardless of the specified limit.
   * Use Query.forEach(QueryConsumer<? super T> consumer) to iterate all valid values.
   *
   * @return a Query with the ListOfValuesValues valid for this ListOfValues.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.ListOfValuesValue> queryValidValues();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ListOfValuesFilter.java
====================
package com.stibo.core.domain;

/**
 *A list of values filter, ie. the ability to limit the amount of valid values for a List Of Values.
 */
public abstract interface ListOfValuesFilter {
  
  /**
   *Adds new value to the value filter for the attribute or attribute link. It also creates new filter when it was not existing previously.
   * @param listOfValuesValue value to be added to the filter
   * @throws IllegalLOVFilterException when ListOfValuesValue cannot be added
   */
  public abstract void addFilterValue(com.stibo.core.domain.ListOfValuesValue listOfValuesValue) throws com.stibo.core.domain.listofvalues.lovfilter.IllegalLOVFilterException;
  
  /**
   *Gets the query allowing to get access to the filter values for the attribute or attribute link
   * @return query with access to filter values
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.ListOfValuesValue> queryFilterValues();
  
  /**
   *Removes value from the value filter for the attribute or attribute link.
   * @param listOfValuesValue value to be removed from the filter
   * @throws IllegalLOVFilterException when ListOfValuesValue cannot be removed
   */
  public abstract void removeFilterValue(com.stibo.core.domain.ListOfValuesValue listOfValuesValue) throws com.stibo.core.domain.listofvalues.lovfilter.IllegalLOVFilterException;
  
  /**
   *Sets the list of values filter for the attribute or attribute link, creating a filter if necessary and deleting it if values is null.
   * @param values the list of values to set the filter to - or null to delete filter.
   * @throws IllegalLOVFilterException when LOVFilter cannot be set
   */
  public abstract void setListOfValuesFilter(java.util.Set<com.stibo.core.domain.ListOfValuesValue> values) throws com.stibo.core.domain.listofvalues.lovfilter.IllegalLOVFilterException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ListOfValuesHome.java
====================
package com.stibo.core.domain;

/**
 *Interface for ObjectFactory
 */
public abstract interface ListOfValuesHome {
  
  /**
   *Return the ListOfValues with the given ID
   * @param id - The ID of the ListOfValues object
   * @return the ListOfValues object or null if not found
   */
  public abstract com.stibo.core.domain.ListOfValues getListOfValuesByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ListOfValuesValue.java
====================
package com.stibo.core.domain;

/**
 *A ListOfValuesValue represents a value in a ListOfValues.
 */
public abstract interface ListOfValuesValue {
  
  /**
   *Get the dimensionpoints of the ListOfValuesValue object
   * @return the dimensionpoints of the ListOfValuesValue object
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
  /**
   *Retrieve the identifier of this ListOfValuesValue (if any)
   * @return The identifier of this ListOfValuesValue , if set, or <code>null</code> either if
   * the identifier has not yet been set or if the LOV is medium domain. (Medium domain LOVs does not currently
   * support external identifiers.)
   */
  public abstract java.lang.String getID();
  
  /**
   *Get the list of values owning this value.
   * @return ListOfValues object owning this value.
   */
  public abstract com.stibo.core.domain.ListOfValues getListOfValues();
  
  /**
   *Retrieve the Unit of this ListOfValuesValue
   * @return the unit of this ListOfValuesValue, <code>null</code> if no such Unit exists.
   */
  public abstract com.stibo.core.domain.Unit getUnit();
  
  /**
   *Get the value of this ListOfValuesValue
   * @return the value of this ListOfValuesValue, might be <code>null</code>
   */
  public abstract java.lang.String getValue();
  
  /**
   *Set the value of an existing ListOfValuesValue.
   * @param value The value
   * @param unit The unit. If null default unit is used if set for LOV
   * @throws ValueValidatorException if the value validation failed for this LOV.
   * @throws TagValidatorException if the value contains invalid tags
   */
  public abstract void setValue(java.lang.String value,com.stibo.core.domain.Unit unit) throws com.stibo.core.domain.ValueValidatorException,com.stibo.core.domain.TagValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LOVMultiValue.java
====================
package com.stibo.core.domain;

/**
 *A LOVMultiValue represents a value for a multivalued attribute (getAttribute().isMultiValued() == true)
 * where the possible attribute values are all taken from a ListOfValues (getAttribute().hasLOV() == true)
 */
public abstract interface LOVMultiValue extends com.stibo.core.domain.LOVValue, com.stibo.core.domain.MultiValue {
  
  /**
   *Adds the lov-value value based on external id of lov-value
   * @param id - the ID of lov-value
   * @throws ValidatorException if value is not valid
   */
  public abstract void addLOVValueByID(java.lang.String id) throws com.stibo.core.domain.ValidatorException;
  
  /**
   *Returns an LOVMultiValueBuilder, using which multiple values can be appended in a single action.
   * @return new LOVMultiValueBuilder
   */
  public abstract com.stibo.core.domain.multivalue.LOVMultiValueBuilder append();
  
  /**
   *Returns an LOVMultiValueBuilder, using which multiple values can be set in a single action overwriting any previously existing values.
   * @return new LOVMultiValueBuilder
   */
  public abstract com.stibo.core.domain.multivalue.LOVMultiValueBuilder replace();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LOVSingleValue.java
====================
package com.stibo.core.domain;

/**
 *A LOVSingleValue represents a value for a single valued attribute (getAttribute().isMultiValued() == false)
 * where the possible attribute values are all taken from a ListOfValues (getAttribute().hasLOV() == true)
 */
public abstract interface LOVSingleValue extends com.stibo.core.domain.LOVValue, com.stibo.core.domain.SingleValue {
  
  /**
   *Get the external ID of the value
   *
   * @return The external ID of the value, if set, or null if not set yet or if underlying list of values has medium domain.
   */
  public abstract java.lang.String getID();
  
  /**
   *Get the "list of values" object of this LOVSingle value. The list-of-value object
   * encapsulates the valueModelPO object, which is the persistent object of the valueModel
   * database table.
   * @return the list-of-value value
   */
  public abstract com.stibo.core.domain.ListOfValuesValue getLOVValue();
  
  /**
   *Set the "list of values" object of this LOVSingle value
   * @param lovValue - list of Values object
   * @throws ValidatorException if validation of value fails
   */
  public abstract void setLOVValue(com.stibo.core.domain.ListOfValuesValue lovValue) throws com.stibo.core.domain.ValidatorException;
  
  /**
   *Sets the value using the ID of a ListOfValuesValue.
   * @param id ListOfValuesValue ID
   * @throws ValidatorException if the validation of the value fails.
   */
  public abstract void setLOVValueByID(java.lang.String id) throws com.stibo.core.domain.ValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\LOVValue.java
====================
package com.stibo.core.domain;

/**
 *A LOVValue is a value having an attribute attached to a ListOfValues (getAttribute().hasLOV() == true)
 */
public abstract interface LOVValue extends com.stibo.core.domain.Value {
  
  /**
   *Tests if current value is valid for the LOV filters. This includes value-filters set on the attribute or on the used attribute-links.
   * @return true if the current value is matching all relevant LOV filters.
   */
  public abstract boolean isValidForLOVFilters();
  
  /**
   *Tests if specified value is valid for the LOV filters. This includes value-filters set on the attribute or on the used attribute-links.
   * @param value the ListOfValuesValue tested for validity
   * @return true if the specified value is matching all relevant LOV filters.
   */
  public abstract boolean isValidValue(com.stibo.core.domain.ListOfValuesValue value);
  
  /**
   *Get the set of valid values for this LOVValue. This method filters for attribute link and attribute filters.
   * @return set of valid values for this LOVValue.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.ListOfValuesValue> queryValidValues();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Manager.java
====================
package com.stibo.core.domain;

/**
 *The Manager is the gateway into the domain model of STEP.
 * <p>
 * All access to data in STEP happens in the context of a Manager instance that determines the User
 * ({@link Manager#getCurrentUser()}), the Context ({@link Manager#getCurrentContext()}) and the Workspace
 * ({@link Manager#getCurrentWorkspace()}).
 * <p>
 * The Manager provides access to various home interfaces, either via dedicated methods like
 * {@link Manager#getAttributeHome()} or via the generic {@link Manager#getHome(Class)} method that can be used for home
 * interfaces that extend {@link com.stibo.core.domain.home.Home} (e.g. {@code Manager.getHome(MailHome.class)} in Java,
 * {@code Manager.getHome(com.stibo.mail.home.MailHome)} in JavaScript).
 * <p>
 * Further, a number of "executors" are accessible via the Manager, allowing code to be executed in a specific
 * Context or Workspace or to be executed with elevated write privileges.
 */
public abstract class Manager {
  
  /**
   *Allows code to be executed in a STEP context different from current.
   * <p>
   * A {@link Manager} based on current but initialized in the STEP context with supplied {@code contextID} is made
   * available to the supplied {@link Executor} as illustrated in the examples below.
   * <p>
   * Be aware that objects in order to be accessed in the desired context must be obtained explicitly using the
   * provided manager.
   * <p>
   * Java example:
   * <pre>
   * final String germanDescription = manager.executeInContext("DE-de", deManager -> {
   *     return deManager.getObjectFromOtherManager(aProduct).getValue("Description").getSimpleValue();
   * });
   * </pre>
   * JavaScript example:
   * <pre>
   * var germanDescription = manager.executeInContext("DE-de", function(deManager) {
   *     return deManager.getObjectFromOtherManager(aProduct).getValue("Description").getSimpleValue();
   * });
   * </pre>
   *
   * @param contextID  the ID of the context for which to obtain a new {@link Manager}
   * @param executor  the {@link Executor} to execute
   * @return the result of the execution
   */
  public <T extends java.lang.Object>T executeInContext(java.lang.String contextID,com.stibo.core.domain.Executor<T> executor) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Allows code to be executed in a workspace different from current.
   * <p>
   * A {@link Manager} based on current but initialized in the workspace with supplied {@code workspaceID} is made
   * available to the supplied {@link Executor} as illustrated in the examples below.
   * <p>
   * Be aware that objects in order to be accessed in the desired workspace must be obtained explicitly using the
   * provided manager.
   * Further, notice that Approved workspace is a terminated workspace in which data cannot be changed.
   * <p>
   * Java example:
   * <pre>
   * final String approvedDescription = manager.executeInWorkspace("Approved", approvedManager -> {
   *     return approvedManager.getObjectFromOtherManager(aProduct).getValue("Description").getSimpleValue();
   * });
   * </pre>
   * JavaScript example:
   * <pre>
   * var approvedDescription = manager.executeInWorkspace("Approved", function(approvedManager) {
   *     return approvedManager.getObjectFromOtherManager(aProduct).getValue("Description").getSimpleValue();
   * });
   * </pre>
   *
   * @param workspaceID  the ID of the workspace for which to obtain a new {@link Manager}
   * @param executor  the {@link Executor} to execute
   * @return the result of the execution
   */
  public <T extends java.lang.Object>T executeInWorkspace(java.lang.String workspaceID,com.stibo.core.domain.Executor<T> executor) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Execute the executor with full write privileges that is ignoring the privileges restrictions of the current user.
   *
   * @param executor The executor to execute holding the block of code to be executed with full write privileges
   * @return The result of the execution.
   * @throws Exception if the executor throws an exception.
   */
  public abstract <T extends java.lang.Object>T executeWritePrivileged(com.stibo.core.domain.PrivilegedExecutor<T> executor) throws java.lang.Exception;
  
  /**
   *Method for obtaining home interfaces that extend com.stibo.core.domain.home.Home and that are not available via a dedicated "getter" method.
   *
   * @param type the type of home to get. E.g. MailHome.class, com.stibo.mail.home.MailHome in JavaScript.
   * @param <T>  type.
   * @return the requested home interface.
   */
  public abstract <T extends com.stibo.core.domain.home.Home>T getHome(java.lang.Class<T> type);
  
  /**
   *Get base object in this manager based on base object from other manager.
   * Notice that even if managers have different privileges associated with the object (different context/workspace/user),
   * the object is returned without checking privileges.
   * @param baseObject The base object to convert to this manager.
   * @return Base object in this manager or null if object is not available in this manager.
   */
  public abstract <T extends com.stibo.core.domain.BaseObject>T getObjectFromOtherManager(T baseObject);
  
  /**
   *Gets the home for retrieving assets
   *
   * @return the home for retrieving assets, never null
   */
  public abstract com.stibo.core.domain.AssetHome getAssetHome();
  
  /**
   *Get the home for attributeGroup domain objects
   *
   * @return the home for attributeGroup domain objects
   */
  public abstract com.stibo.core.domain.AttributeGroupHome getAttributeGroupHome();
  
  /**
   *Get the home for retrieving STEP attributes
   *
   * @return the home for retrieving STEP attributes, newer null
   */
  public abstract com.stibo.core.domain.AttributeHome getAttributeHome();
  
  /**
   *Gets the home for background processes
   *
   * @return the home for background processes.
   */
  public abstract com.stibo.core.domain.backgroundprocess.BackgroundProcessHome getBackgroundProcessHome();
  
  /**
   *Gets the home for business rules.
   *
   * @return Home of business rules.
   */
  public abstract com.stibo.core.domain.businessrule.BusinessRuleHome getBusinessRuleHome();
  
  /**
   *Get the home for retrieving STEP classifications
   *
   * @return the home for retrieving STEP classifications, never null
   */
  public abstract com.stibo.core.domain.ClassificationHome getClassificationHome();
  
  /**
   *Gets the home for retrieving context domain objects.
   *
   * @return The home for context domain objects.
   */
  public abstract com.stibo.core.domain.ContextHome getContextHome();
  
  /**
   *Get the current STEP context of this manager
   *
   * @return the current STEP context of this manager, should never be null
   */
  public abstract com.stibo.core.domain.Context getCurrentContext();
  
  /**
   *Get the current user of this manager.
   *
   * @return current user of this manager, never null.
   */
  public abstract com.stibo.core.domain.User getCurrentUser();
  
  /**
   *Get the current workspace of this manager.
   *
   * @return The current workspace of this manager
   */
  public abstract com.stibo.core.domain.Workspace getCurrentWorkspace();
  
  /**
   *Get the home for retrieving data profiles
   *
   * @return the home for retrieving data profiles, never null
   */
  public abstract com.stibo.core.domain.dataprofile.DataProfileHome getDataProfilingHome();
  
  /**
   *Get the home for retrieving STEP entities
   *
   * @return the home for retrieving STEP entities, never null
   */
  public abstract com.stibo.core.domain.entity.EntityHome getEntityHome();
  
  /**
   *Gets the home for retrieving STEP (user) groups
   *
   * @return he home for retrieving STEP (user) groups, never null
   */
  public abstract com.stibo.core.domain.GroupHome getGroupHome();
  
  /**
   *Gets the home for keys domain objects
   *
   * @return the home for key domain objects
   */
  public abstract com.stibo.core.domain.key.KeyHome getKeyHome();
  
  /**
   *Get the home for retrieving link types being the types of classification product links
   *
   * @return the home for retrieving link types, never null
   */
  public abstract com.stibo.core.domain.LinkTypeHome getLinkTypeHome();
  
  /**
   *Get the home for domain domain objects
   *
   * @return the home for attribute domin domain objects
   */
  public abstract com.stibo.core.domain.ListOfValuesHome getListOfValuesHome();
  
  /**
   *Gets the home for collection domain objects
   *
   * @return the home for collection domain objects
   */
  public abstract com.stibo.core.domain.collection.NodeCollectionHome getNodeCollectionHome();
  
  /**
   *Get node specified by url.
   * Notice that when context and workspace are specified in the URL they will be ignored in favor of the manager's context and workspace.
   *
   * @param url The url as string
   * @return The node or null if node not found
   */
  public com.stibo.core.domain.Node getNodeFromURL(java.lang.String url) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the home for node objects
   *
   * @return the home for node domain objects
   */
  public abstract com.stibo.core.domain.NodeHome getNodeHome();
  
  /**
   *Gets the home for objecttype objects
   *
   * @return the home for object type objects
   */
  public abstract com.stibo.core.domain.ObjectTypeHome getObjectTypeHome();
  
  /**
   *Gets the home for retrieving STEP products
   *
   * @return the home for retrieving STEP products, never null
   */
  public abstract com.stibo.core.domain.ProductHome getProductHome();
  
  /**
   *Get the home for retrieving reference types
   *
   * @return the home for retrieving reference types, nver null
   */
  public abstract com.stibo.core.domain.ReferenceTypeHome getReferenceTypeHome();
  
  /**
   *Get the home for unit group domain objects
   *
   * @return the home for workspace domain objects
   */
  public abstract com.stibo.core.domain.UnitGroupHome getUnitGroupHome();
  
  /**
   *Get the home for unit domain objects
   *
   * @return the home for unit domain objects
   */
  public abstract com.stibo.core.domain.UnitHome getUnitHome();
  
  /**
   *Get the home for retrieving STEP users
   *
   * @return the home for retrieving STEP users, never null.
   */
  public abstract com.stibo.core.domain.UserHome getUserHome();
  
  /**
   *Get home for retrieving STEP Workflows.
   *
   * @return home for retrieving STEP Workflows, never null.
   */
  public abstract com.stibo.core.domain.state.WorkflowHome getWorkflowHome();
  
  /**
   *Get the home for retrieving workspaces.
   *
   * @return The home for workspace objects.
   */
  public abstract com.stibo.core.domain.WorkspaceHome getWorkspaceHome();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\MultiValue.java
====================
package com.stibo.core.domain;

/**
 *Container for values for a multi-valued attribute.
 */
public abstract interface MultiValue extends com.stibo.core.domain.Value {
  
  /**
   *Add the value to the list of values in the multivalued attribute value. Corresponds to addValue(value, null).
   * @param value The value to add.
   * @return The new SingleValue object.
   * @see #addValue(String, Unit)
   * @throws ValidatorException if validation of value fails
   */
  public abstract com.stibo.core.domain.SingleValue addValue(java.lang.String value) throws com.stibo.core.domain.ValidatorException;
  
  /**
   *Add the value to the list of values in the multivalued attribute value.<p>
   * Will return the new inner SingleValue object.<p>
   * Will establish a new local value if isInherited() == false OR (isLOV() AND isDimensionPointInherited()==false),
   * copying the contents of the existing value objects
   * @param value The value to add.
   * @param unit The unit to add.
   * @return The new SingleValue object.
   * @throws ValidatorException if validation of value fails
   */
  public abstract com.stibo.core.domain.SingleValue addValue(java.lang.String value,com.stibo.core.domain.Unit unit) throws com.stibo.core.domain.ValidatorException;
  
  /**
   *Returns a MultiValueBuilder, using which multiple values can be appended in a single action.
   * @return new MultiValueBuilder
   */
  public abstract com.stibo.core.domain.multivalue.MultiValueBuilder append();
  
  /**
   *Get the List of singleValues of this MultiValue ordered by ValNoCopy. In LOV case the List will consist
   * of LOVSingleValue values, in Soft case just SingleValue values.
   * @return The Set of values of this MultiValue, empty set if not values.
   */
  public abstract java.util.List<com.stibo.core.domain.SingleValue> getValues();
  
  /**
   *Returns a MultiValueBuilder, using which multiple values can be set in a single action overwriting any previously existing values.
   * @return new MultiValueBuilder
   */
  public abstract com.stibo.core.domain.multivalue.MultiValueBuilder replace();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Node.java
====================
package com.stibo.core.domain;

/**
 *The basic building block in the domain model that has an identity on its own. This is
 * in contrast to edges that represent relationships between nodes.
 */
public abstract interface Node extends com.stibo.core.domain.BaseObject {
  
  /**
   *Returns the identifier of the Node.
   *
   * @return The Node identifier.
   */
  public abstract java.lang.String getID();
  
  /**
   *Returns the name of the Node in the current context and workspace.
   * Return <code>null</code> if no name is visible in this context and workspace.
   *
   * @return The name of the Node.
   */
  public abstract java.lang.String getName();
  
  /**
   *Return the title of the node in the current context, workspace.
   *
   * @return The title.
   */
  public abstract java.lang.String getTitle();
  
  /**
   *Returns the unique URL that identifies this Node.
   * @see  #getUniqueURL()
   * @return A Unique URL identifying this Node.
   */
  public abstract java.lang.String getURL();
  
  /**
   *Is the name dimension point inherited?
   * @return true if name dimension point is inherited.
   */
  public default boolean isNameDimensionPointInherited() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets the name on the node. The name will be set/updated in the current
   * context and workspace. For setup Nodes the name is set/updated in all workspaces.
   * Calling the method with a <code>null</code> value means deletion.
   * 
   * @param name The new name that may contain tags defined on the system.
   * @throws ValueValidatorException Thrown if the name is more than 2000 bytes long, UTF-8 encoded
   * or contains leading/trailing spaces.
   * @throws TagValidatorException Thrown if the name contains invalid tags.
   */
  public abstract void setName(java.lang.String name) throws com.stibo.core.domain.TagValidatorException,com.stibo.core.domain.ValueValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\NodeHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for the node object. Defines a set of methods
 * to obtain domain node objects through.
 */
public abstract interface NodeHome {
  
  /**
   *Get the node identified by a value of a key. Null is returned if no node is found for the
   * given key value.
   *
   * @param keyID Look for a node with the value in this key
   * @param key The value of the key
   * @return The node found or null
   */
  public abstract <T extends com.stibo.core.domain.Node>T getObjectByKey(java.lang.String keyID,java.lang.String key);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\NodeIdUniqueConstraintException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when insertion of a node fails because a node of the given type (actually nodetype) does already exist with the supplied id.
 */
public class NodeIdUniqueConstraintException extends com.stibo.core.domain.UniqueConstraintException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\NodeTranslationStatus.java
====================
package com.stibo.core.domain;

/**
 *Node Translation Status is an enum with the statuses like Dirty, Started, Up to Date and None.
 */
public enum NodeTranslationStatus {
  
  /**
   *Dirty: Translated content in the source language has changed since the most recent translation completed.
   */
  Dirty, 
  /**
   *Started: Translation has been started.
   */
  Started, 
  /**
   *Up to Date: No translated content in the source language has been changed since the previous translation.
   */
  UpToDate, 
  /**
   *None: No translation is needed.
   */
  None;
  /**
   *This method will get the status of the node based on the string literals used for status in the argument
   * @param v A string instance that indicates the statuses in string
   * @return Result will be an enum instance of NodeTranslationStatus.
   */
  public static com.stibo.core.domain.NodeTranslationStatus fromValue(java.lang.String v) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ObjectType.java
====================
package com.stibo.core.domain;

/**
 *An ObjectType specifies the characteristics of a group of Nodes in the database structure. All Nodes
 * are of a specific ObjectType.
 */
public abstract interface ObjectType extends com.stibo.core.domain.DimensionDefiningType, com.stibo.core.domain.Node, com.stibo.core.domain.baseobjecttype.BaseObjectType {
  
  /**
   *Returns the root for this object type.
   *
   * @return The ObjectType root.
   */
  public abstract com.stibo.core.domain.ObjectType findObjectTypeRoot();
  
  /**
   *Returns all children of this ObjectType and all their descendants.
   * @return The Set of all descendants of this ObjectType, or the empty set, if no children exists.
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getAllChildren();
  
  /**
   *Returns the Set children of this ObjectType. The children are ObjectTypes themselves.
   * @return The ObjectType children of this ObjectType, or the empty set, if no children exists.
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getChildren();
  
  /**
   *Get all parent object types. An empty set is returned for
   * the root in the specific Node hierarchy.
   *
   * @return parent objecttypes
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getParents();
  
  /**
   *Returns all valid description attributes of this ObjectType.
   * @return The set of description Attributes that are valid for this objecttype, or the empty set if none applies.
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getValidDescriptionAttributes();
  
  /**
   *Checks whether or not this ObjectType is an Asset ObjectType?
   * @return True if it is a Asset ObjectType, false if not.
   */
  public abstract boolean isAssetType();
  
  /**
   *Checks whether or not this ObjectType is found in the hierachy below the parent supplied.
   * @param parent The parent ObjectType below which to search for this ObjectType.
   * @return True if this ObjectType is found in the hierarchy below the parent.
   */
  public abstract boolean isBelow(com.stibo.core.domain.ObjectType parent);
  
  /**
   *Checks whether or not the ClassificationProductLinks are owned by the Classification or the product (determining which end's history gets updated).
   *
   * @return true if classifications owns link, false if products.
   */
  public abstract boolean isClassificationProductLinkOwner();
  
  /**
   *Checks whether or not this object type is a Classification ObjectType.
   *
   * @return True if it is a Classification ObjectType, false if not.
   */
  public abstract boolean isClassificationType();
  
  /**
   *Checks whether or not this ObjectType is an entity object type.
   *
   * @return True if it is an entity object type, false if not
   */
  public abstract boolean isEntityType();
  
  /**
   *Checks whether or not this ObjectType is an EventQueue ObjectType?
   * @return True if it is a EventQueue ObjectType, false if not.
   */
  public abstract boolean isEventQueueType();
  
  /**
   *Checks whether or not this ObjectType is an IndexWord ObjectType
   * @return True, if it is an IndexWord ObjectType, false if not.
   */
  public abstract boolean isIndexWordObjectType();
  
  /**
   *Determine if this ObjectType is a product override ObjectType.
   * Is true if the parent path of this objecttype contains the top
   * product override objecttype.
   *
   * @return True if this ObjectType is a product override ObjectType
   */
  public abstract boolean isProductOverrideType();
  
  /**
   *Checks whether or not this ObjectType is a Product ObjectType.
   *
   * @return True if it is a Product ObjectType, false if not.
   */
  public abstract boolean isProductType();
  
  /**
   *Checks whether or not a description Attribute is valid for this ObjectType.
   * @param attribute A description Attribute
   * @return True if the attribute is valid for this objecttype, false if not.
   */
  public abstract boolean isValidDescriptionAttribute(com.stibo.core.domain.Attribute attribute);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ObjectTypeable.java
====================
package com.stibo.core.domain;

/**
 *Interface implemented by objects of a user defined object type.
 */
public abstract interface ObjectTypeable extends com.stibo.core.domain.Node {
  
  /**
   *Get the ObjectType of node. Was known as UserType in earlier
   * versions.
   *
   * @return ObjectType of node.
   */
  public abstract com.stibo.core.domain.ObjectType getObjectType();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ObjectTypeConstraintException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when an operation violates the constraints setup in the object type hierarchy.
 */
public class ObjectTypeConstraintException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ObjectTypeHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface to access object types and
 */
public abstract interface ObjectTypeHome {
  
  /**
   *Return a ObjectType object relating to the external identifer supplied
   * @param id - The external identifier of the ObjectType object
   * @return the appropriate ObjectType object or null if the identifer was not valid
   */
  public abstract com.stibo.core.domain.ObjectType getObjectTypeByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\PrivilegedExecutor.java
====================
package com.stibo.core.domain;

/**
 *The PrivilegedExecutor is the interface to implement when wanting to establish an code block to be executed with
 * privileges different from the privileges of the user of the current manager. "Execute methods" on the Manager class
 * take as input parameter a PrivilegedExecutor and invoke its execute method, which is then run with the wanted privileges.
 */
public abstract interface PrivilegedExecutor<T extends java.lang.Object> {
  
  /**
   *Execute method containing code block to be executed with special privileges.
   * @return an object encapsulating the result.
   * @throws Exception if block cannot execute
   */
  public abstract T execute() throws java.lang.Exception;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Product.java
====================
package com.stibo.core.domain;

/**
 *A Product represents a SKU, part number or any other orderable item that a company produces or sells.
 */
public abstract interface Product extends com.stibo.core.domain.datacontainertypelink.DataContainerTypeLinkable, com.stibo.core.domain.attributelink.AttributeLinkable, com.stibo.core.domain.Node, com.stibo.core.domain.hasdatacontainers.HasDataContainers, com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.terms.HasTerms, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.WorkflowableNode, com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode, com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.translation.TranslatableNode, com.stibo.core.domain.WorkspaceRevisableTreeNode<com.stibo.core.domain.Product> {
  
  /**
   *Adds a product (may be a product override) to list (last element)
   * of products linked into this product override. If called
   * on a normal product an UnsupportedOperationException thrown.
   * If called with null or product itself an IllegalArgumentException is thrown.
   * If called with a child already added to list no changes is made
   * @param child The product to add
   */
  public abstract void addProductOverrideChild(com.stibo.core.domain.Product child);
  
  /**
   *Classify this Product using the given ClassificationProductLinkType.
   * @param classification The Classification to classify this Product under.
   * @param type The type of the link to create.
   * @return The resulting ClassificationProductLink.
   * @throws UniqueConstraintException Thrown if a ClassificationProductLink already exists between this Product and the Classification.
   * @throws LinkTypeNotValidException Thrown if a ClassificationProductLink cannot be applied to provided classification or current product.
   */
  public abstract com.stibo.core.domain.ClassificationProductLink createClassificationProductLink(com.stibo.core.domain.Classification classification,com.stibo.core.domain.ClassificationProductLinkType type) throws com.stibo.core.domain.UniqueConstraintException,com.stibo.core.domain.LinkTypeNotValidException;
  
  /**
   *Creates a new product with the specified ID and object type as a child to the product for which the method
   * is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter. <br/>
   * If a product with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new product. Can be null or the empty string if auto IDs are configured
   * @param objectType The object type of the new product
   * @return The newly created product
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted product
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.Product createProduct(java.lang.String id,com.stibo.core.domain.ObjectType objectType) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Creates a new product with the specified ID and object type as a child to the product for which the method
   * is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter. <br/>
   * If a product with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new product. Can be null or the empty string if auto IDs are configured
   * @param objectTypeID The ID of the object type of the new product
   * @return The newly created product
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted product
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.Product createProduct(java.lang.String id,java.lang.String objectTypeID) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Get the set of children for this product.
   * Notice that the list is filtered for contexts and view privileges.
   * List is sorted only if manually sorted, otherwise "random" order is returned.
   * Warning - using this operation loads all child products into memory.
   * This can cause the application server to run out of memory, as there can be +100.000 child products under some products.
   * So this method should only be used, if the product is manually sorted, and you need to get the products in the
   * manually sorted order. Notice, that it does not make sense to have large number of child products that are manually sorted.
   * If you are do not need the child classifications in manually sorted order, you should instead use #queryChilden()
   * @return The set of children for this product.
   * @see ObjectType#isManuallySorted()
   */
  public abstract java.util.List<com.stibo.core.domain.Product> getChildren();
  
  /**
   *Returns the set of ClassificationProductLinks for this Product.
   * The result includes inherited and all valid links. However, it does not include suppressed links or links for all contexts.
   *
   * Ownership is not taken into account in this method.
   *
   * @return The Map of ClassificationProductLinks
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ClassificationProductLinkMap getClassificationProductLinks();
  
  /**
   *Returns a list of ClassificationProductLinks for this Product for a given ClassificationProductLinkType.
   * The result includes inherited and all valid links. However, it does not include suppressed links.
   *
   * Ownership is not taken into account in this method.
   *
   * @param type the type of the links to get.
   * @return The List of classification product links for this product of given type.
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ClassificationProductLinkList getClassificationProductLinks(com.stibo.core.domain.ClassificationProductLinkType type);
  
  /**
   *Returns an overridden Product for a product override.
   * For normal Products the method always returns <code>null</code>. For product override either <code>null</code> or the
   * Product it overrides.
   * @return The overridden product for a product override (can be null) or null for a normal Product.
   */
  public abstract com.stibo.core.domain.Product getOverriddenProduct();
  
  /**
   *Get the parent Product of this Product.
   * @return the parent Product or <code>null</code> if it is the root Product.
   */
  public abstract com.stibo.core.domain.Product getParent();
  
  /**
   *Returns all Products linked into this product override sorted ascending. The list
   * may contain other product overrides.  If called
   * on a normal product a empty list is returned.
   * @return all products linked into this product override or an empty list if none applies.
   */
  public abstract java.util.List<com.stibo.core.domain.Product> getProductOverrideChildren();
  
  /**
   *Returns all the Products of type override that override this Product.
   * @return all the Products of type override that override this Product, or the empty set if none applies.
   */
  public abstract java.util.Set<com.stibo.core.domain.Product> getProductOverrides();
  
  /**
   *Returns a query of ClassificationProductLinks for this Product for a given ClassificationProductLinkType.
   * The result includes inherited and all valid links. However, it does not include suppressed links.
   *
   * Ownership is not taken into account in this method.
   *
   * @param type the type of the links to get.
   * @return The Query of classification product links for this product of given type.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.ClassificationProductLink> queryClassificationProductLinks(com.stibo.core.domain.ClassificationProductLinkType type);
  
  /**
   *Removes a product from list
   * of products linked into this product override. If called
   * on a normal product an UnsupportedOperationException thrown.
   * If called with null or product itself an IllegalArgumentException is thrown.
   * @param child The product to remove
   */
  public abstract void removeProductOverrideChild(com.stibo.core.domain.Product child);
  
  /**
   *Make this product override the supplied product (can be a product override too).
   * Will throw a UnsupportedOperationException if called on a normal product.
   * @param product The product to override or null.
   * @return true if this product override was changed due to invoking the method.
   * That is, if this product override now overrides a different product
   * than it did before invoking the method.
   */
  public abstract boolean setOverriddenProduct(com.stibo.core.domain.Product product);
  
  /**
   *Set the parent of this Product to the parent given as argument.
   * @param parent The new parent.
   * @throws ObjectTypeConstraintException Thrown if the ObjectType of this Product is not allowed under the new parent.
   * @throws CycleConstraintException Thrown if attempting to move the Product below itself either directly or indirectly.
   * @throws UnsupportedOperationException Thrown if called on the root Product in the Product hierarchy.
   */
  public abstract void setParent(com.stibo.core.domain.Product parent) throws com.stibo.core.domain.ObjectTypeConstraintException,com.stibo.core.domain.CycleConstraintException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ProductHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for finding products.
 */
public abstract interface ProductHome {
  
  /**
   *Returns a Product relating to the identifer supplied.
   * @param id The identifier of the Product object.
   * @return the Product object with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.Product getProductByID(java.lang.String id);
  
  /**
   *Gets the root product of the product hierarchy.
   *
   * @return the root product in the product hierarchy.
   */
  public abstract com.stibo.core.domain.Product getTopProduct();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Reference.java
====================
package com.stibo.core.domain;

/**
 *A cross reference between two nodes going from "source" to "target" node. The source can be products,
 * classification, and entities among others. The target can be products, classifications, entities,
 * contexts among others.
 */
public abstract interface Reference extends com.stibo.core.domain.Link {
  
  /**
   *The dataContainer object that is referencing something else.
   *
   * @return The dataContainer object that is referencing something else.
   */
  public abstract com.stibo.core.domain.basereferencesource.BaseReferenceSource getDataContainerReferenceSource();
  
  /**
   *Get the type of this link.
   *
   * @return ReferenceType the type of reference
   */
  public abstract com.stibo.core.domain.ReferenceType getLinkType();
  
  /**
   *The node that owns this reference.
   *
   * @return RevisableNode the owner node
   * @deprecated use getSource() instead.
   */
  public abstract com.stibo.core.domain.WorkspaceRevisableNode getOwner();
  
  /**
   *Get the type of this reference.
   * Identical to getLinkType.
   * 
   * @return ReferenceType the type of reference
   */
  public default com.stibo.core.domain.ReferenceType getReferenceType() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the type ID of this reference . The ID also acts as unique id of the reference type.
   * This previously returned getName() which is not unique.
   *
   * @return ReferenceType the type ID of reference, cannot be null
   */
  public abstract java.lang.String getReferenceTypeString();
  
  /**
   *The node that owns this reference. If the source node is a workspace revisable node ownership means
   * that the revision history of the Reference is attached to the source node and that the reference
   * is approved as part of the source node.
   * 
   * @return Node the source node owning the reference, cannot be null
   */
  public abstract com.stibo.core.domain.ReferenceSource getSource();
  
  /**
   *The node pointed to by this reference
   * 
   * @return the target node, which cannot be null
   */
  public abstract com.stibo.core.domain.ReferenceTarget getTarget();
  
  /**
   *The node pointed to by this reference
   *
   * @return RevisableNode the target node
   * @deprecated use getTarget() instead.
   */
  public abstract com.stibo.core.domain.WorkspaceRevisableNode getTargetNode();
  
  /**
   *Change the reference type for this reference. A change is only valid if
   * 1) The source and target object type is valid on the new reference type.
   * 2) The new reference type has at least the same metadata and dimension dependency.  
   * 
   * @param referenceType the referenceType to set for this reference
   * @deprecated Should not be used anymore; here for compatibility only; the type is for the reference what the attribute is for the value.
   */
  public abstract void setReferenceType(com.stibo.core.domain.ReferenceType referenceType);
  
  /**
   *Set the target node of the reference.
   * @param node the new target node of the reference.
   */
  public abstract void setTarget(com.stibo.core.domain.ReferenceTarget node);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ReferenceList.java
====================
package com.stibo.core.domain;

/**
 *List of (cross) references that are characterized by having local origin, an origin inherited by parent
 * or an origin inherited via the product override hierarchy, a specific reference type,
 * and a source product being the node from where the reference appears.
 */
public abstract interface ReferenceList extends com.stibo.core.domain.LinkList<com.stibo.core.domain.Reference> {
  
  /**
   *Get the type of the references of this list of references
   * @return the type of the references of this list of references- should never be null
   */
  public abstract com.stibo.core.domain.ReferenceType getType();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ReferenceMap.java
====================
package com.stibo.core.domain;

/**
 *A map of references. Use get() and values() to get references grouped by reference type.
 * Using asList you get a flat list of all references.
 */
public abstract interface ReferenceMap extends com.stibo.core.domain.LinkMap<com.stibo.core.domain.ReferenceType,com.stibo.core.domain.ReferenceList,com.stibo.core.domain.Reference> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ReferenceSource.java
====================
package com.stibo.core.domain;

/**
 *The ReferenceSource is the node from where the references originates as opposed to the target node.
 * The source node is said to "own" the reference. If the source node is a revisable node ownership means
 * that the revision history of the Reference is attached to the source node and for workspace revisable
 * source nodes the reference is approved as part of the source node.
 */
public abstract interface ReferenceSource extends com.stibo.core.domain.basereferencesource.BaseReferenceSource, com.stibo.core.domain.Node {
  
  /**
   *Creates a reference from this node.
   *
   * @param targetNode the node that the reference should point to
   * @param referenceTypeID ID of the reference type for the reference to create
   * @return the newly created reference
   * @throws com.stibo.core.domain.UniqueConstraintException if a reference of the specified type to the specified target already exist or if the reference type only allows for a single reference and a reference already exists
   * @throws LinkTypeNotValidException if the reference source or reference target is not valid for the specified reference type
   */
  public abstract com.stibo.core.domain.Reference createReference(com.stibo.core.domain.ReferenceTarget targetNode,java.lang.String referenceTypeID) throws com.stibo.core.domain.UniqueConstraintException,com.stibo.core.domain.LinkTypeNotValidException;
  
  /**
   *Get the map of references to assets that this node owns or inherits,
   * excluding suppressed references.
   * <p/>
   * The result can hold a huge amount of objects, so please use query-variant instead.
   *
   * @return map of references to products that this node owns or inherits,
   * excluding suppressed references.
   * @see com.stibo.core.domain.ObjectType#isManuallySorted()
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ReferenceMap getAssetReferences();
  
  /**
   *Get the map of references to classifications that this node owns or inherits,
   * excluding suppressed references.
   * <p/>
   * The result can hold a huge amount of objects, so please use query-variant instead.
   *
   * @return map of references to assets that this node owns or inherits,
   * excluding suppressed references.
   * @see com.stibo.core.domain.ObjectType#isManuallySorted()
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ReferenceMap getClassificationReferences();
  
  /**
   *Get the map of local (i.e. not inherited) references.
   * The result can hold a huge amount of objects, so please use query-variant instead.
   * @return The map of references.
   */
  public abstract com.stibo.core.domain.ReferenceMap getLocalReferences();
  
  /**
   *Get local references (i.e. not inherited) of a specific reference type.
   * The result can hold a huge amount of objects, so please use query-variant instead.
   * @param type the type of reference to get local references for
   * @return The references.
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ReferenceList getLocalReferences(com.stibo.core.domain.ReferenceType type);
  
  /**
   *Get the set of references to products that this node owns or inherits,
   * excluding suppressed references.
   * <p/>
   * The result can hold a huge amount of objects, so please use query-variant instead.
   *
   * @return The set of references that this node owns or inherits,
   * excluding suppressed references.
   * @see com.stibo.core.domain.ObjectType#isManuallySorted()
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ReferenceMap getProductReferences();
  
  /**
   *Get the map of references that this revisable node owns or inherits, excluding suppressed references.
   * The result can hold a huge amount of objects, so please use query-variant instead.
   * @return The map of references for this node
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ReferenceMap getReferences();
  
  /**
   *Get the list of references that this node owns or inherits of the specified type,
   * excluding suppressed references.
   * <p/>
   * @param type the type of reference.
   * @return The set of references this node owns of the given reference type.
   * @see com.stibo.core.domain.ObjectType#isManuallySorted()
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract com.stibo.core.domain.ReferenceList getReferences(com.stibo.core.domain.ReferenceType type);
  
  /**
   *Query the references that this node owns or inherits of the specified type,
   * excluding suppressed references.
   * <p/>
   * @param type the type of reference.
   * @return The set of references this node owns of the given reference type.
   * @see com.stibo.core.domain.ObjectType#isManuallySorted()
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Reference> queryReferences(com.stibo.core.domain.ReferenceType type);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ReferenceTarget.java
====================
package com.stibo.core.domain;

/**
 *The ReferenceTarget is the node that a reference points to as opposed to the source node.
 */
public abstract interface ReferenceTarget extends com.stibo.core.domain.Node {
  
  /**
   *Get the set of references that target this node, excluding suppressed references.
   *
   * @return The set of references that target this node, the empty set if no such references
   * @see #queryReferencedBy(Class, ReferenceType)
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract java.util.Set<com.stibo.core.domain.Reference> getReferencedBy();
  
  /**
   *Get the set of references from assets to this node, , excluding suppressed references.
   *
   * @return The set of references from assets to this node, , the empty set if no such references.
   * @see #queryReferencedBy(Class, ReferenceType)
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract java.util.Set<com.stibo.core.domain.Reference> getReferencedByAssets();
  
  /**
   *Get the set of references from classifications to this node, excluding suppressed references.
   *
   * @return The set of references from classifications to this node, the empty set if no such references.
   * @see #queryReferencedBy(Class, ReferenceType)
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract java.util.Set<com.stibo.core.domain.Reference> getReferencedByClassifications();
  
  /**
   *Get the set of references from products to this node, excluding suppressed references
   * @return The set of references from products to this node, the empty set if no such references.
   * @see #queryReferencedBy(Class, ReferenceType)
   * @deprecated Please use query-variant instead as this method can cause the application server
   * to run out of memory.
   */
  public abstract java.util.Set<com.stibo.core.domain.Reference> getReferencedByProducts();
  
  /**
   *Query the references referencing this node.
   * @param type The type of reference referencing this node - or null for all types.
   * @return query result with references.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Reference> queryReferencedBy(com.stibo.core.domain.ReferenceType type);
  
  /**
   *Query the references referencing this node.
   * @param clazz The type of node referencing this node - or null for all types.
   * @param type The type of reference referencing this node - or null for all types.
   * @return query result with references.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Reference> queryReferencedBy(java.lang.Class<? extends com.stibo.core.domain.ReferenceSource> clazz,com.stibo.core.domain.ReferenceType type);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ReferenceType.java
====================
package com.stibo.core.domain;

/**
 *Instances of ReferenceType is a node used for holding the definition of a type of (cross) reference
 * relating revisable nodes (products, classifications, assets, and entities)
 */
public abstract interface ReferenceType extends com.stibo.core.domain.LinkType {
  
  /**
   *Returns the ObjectTypes that this ReferenceType is valid for.
   * @return Set<ObjectType> The set of Objecttypes that this ReferenceType is valid for.
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getValidForObjectTypes();
  
  /**
   *Returns the target ObjectTypes that this ReferenceType is valid for.
   * @return Set<ObjectType> The set of target Objecttypes that this ReferenceType is valid for.
   */
  public abstract java.util.Set<com.stibo.core.domain.ObjectType> getValidTargetObjectTypes();
  
  /**
   *<p>Checks whether or not References of the ReferenceType can point to instances of the supplied type.</p>
   * <p>For example, ReferenceType.isValidForTargetType(Product.class) will return true for a "product reference type".
   * This method will not work for non-concrete classes like DataTreeNode.class and should be used with
   * concrete classes only, i.e. Product.class, Classification.class, Entity.class and Asset.class.</p>
   * @param type class for the potential target type
   * @return boolean indicating whether or not instances of the supplied type are a valid targets.
   */
  public abstract boolean isValidForTargetType(java.lang.Class<? extends com.stibo.core.domain.ReferenceTarget> type);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ReferenceTypeHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for access to ReferenceTypes.
 */
public abstract interface ReferenceTypeHome {
  
  /**
   *Return the ReferenceType relating to the identifier supplied.
   * @param id The identifier of the ReferenceType object.
   * @return the ReferenceType with identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.ReferenceType getReferenceTypeByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\RevisableNode.java
====================
package com.stibo.core.domain;

/**
 *The RevisableNode is the superclass for all Nodes for which STEP saves historic data.
 */
public abstract interface RevisableNode extends com.stibo.core.domain.Node {
  
  /**
   *Get the current revision of the node. If node is a front node, the revision will be the frontmost, otherwise it will be the one
   * corresponding to the revision of the node.
   * @return Revision of node
   * @throws ObjectNotFoundException is node has been revised-deleted or purged (unless the node has already retrived the revisions)
   */
  public abstract com.stibo.core.domain.Revision getRevision();
  
  /**
   *Returns the revisions associated with this node. (ordered descending, newest first).
   * @return List of <code>Revision</code> objects associated with this node.
   */
  public abstract java.util.List<com.stibo.core.domain.Revision> getRevisions();
  
  /**
   *Gets the tail (oldest) revision of the node.
   * @return the tail revision
   * @throws ObjectNotFoundException is node has been revised-deleted or purged (unless the node has already retrived the revisions)
   */
  public abstract com.stibo.core.domain.Revision getTailRevision();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Revision.java
====================
package com.stibo.core.domain;

/**
 *A revision represents a revision of one of the revisable node types (ie. product, classification or asset).
 * <p>
 * Going back in the revision history, obtaining old information on the node is possible.
 * <p>
 * The revision furthermore knows which workspaces it participates in, which user edited it and when it was created and last edited.
 * <p>
 * A revision is always made by only one user, if a different user edits an object, a new revision is always made
 */
public abstract interface Revision {
  
  /**
   *Returns the date when this revision was created.
   * @return Date when this revision was created.
   */
  public abstract java.util.Date getCreatedDate();
  
  /**
   *Returns the last edited date of this revision.
   * @return Last edited date of revision.
   */
  public abstract java.util.Date getEditedDate();
  
  /**
   *Get name of revision, the name is the &lt;major-version&gt;.&lt;minor-version&gt; version string (ie. "0.1")
   * @return Formatted name of revision of form &lt;major-version&gt;.&lt;minor-version&gt;.
   */
  public abstract java.lang.String getName();
  
  /**
   *<p>Gets the version of the node associated with this revision.</p>
   * <p>Historical versions of a RevisableNode cannot be modified.</p>
   * @return the version of the node associated with this revision as a RevisableNode. Cannot be null.
   */
  public abstract com.stibo.core.domain.RevisableNode getNode();
  
  /**
   *Get predecessor of revision, ie. the revision preceeding this in the current workspace.
   * @return predecessor of revision or null, if this is the initial revision.
   */
  public abstract com.stibo.core.domain.Revision getPredecessor();
  
  /**
   *Get successor of revision, ie. the revision succeeding this in the current workspace.
   * @return successor of revision or null, if this is the front revision
   */
  public abstract com.stibo.core.domain.Revision getSuccessor();
  
  /**
   *Get the ID of the user that created this revision.
   * @return ID of the user doing the revision.
   */
  public abstract java.lang.String getUserID();
  
  /**
   *Change this revision to be a major revision.
   */
  public abstract void setMajor();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\SingleValue.java
====================
package com.stibo.core.domain;

/**
 *A single value, which is either the value for a single-valued attribute
 * or one the values for a multi-valued attributes.
 */
public abstract interface SingleValue extends com.stibo.core.domain.Value {
  
  /**
   *Converts this numeric value to another unit sharing the same base unit
   *
   * @param newUnit the unit to convert to
   * @return BigDecimal the value converted to the supplied unit
   * @throws UnitConversionException if current value is not a numeric value with a unit or if current unit can not be converted to the supplied target unit
   */
  public default java.math.BigDecimal convertValueToUnit(com.stibo.core.domain.Unit newUnit) throws com.stibo.core.domain.UnitConversionException {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Gets all dimensions points for value.
   *
   * @return all dimensions points for value
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
  /**
   *Get the unit of this SingleValue.
   * @return The unit of this SingleValue. Null if no value.
   */
  public abstract com.stibo.core.domain.Unit getUnit();
  
  /**
   *Gets string value of the attribute with inline references resolved.
   *
   * @return the string value of the attribute, null if no value is available.
   */
  public abstract java.lang.String getValue();
  
  /**
   *Sets string value of the attribute.
   *
   * @param attributeValue string value of set
   * @throws ValidatorException if validation of value fails
   */
  public abstract void setValue(java.lang.String attributeValue) throws com.stibo.core.domain.ValidatorException;
  
  /**
   *Set the value of this attribute value object to be the indicated value, unit.<p>
   *
   * Will establish a local variant of the value if isInherited()==true OR isDimensionPointInherited()==true. Will delete the current value if value.length()==0 && unit==null && the value is not inherited in neither product hierarchy nor dimension point graph(s).
   * @param value The value to set.
   * @param unit The unit to set.
   * @throws ValidatorException if validation of value fails
   */
  public abstract void setValue(java.lang.String value,com.stibo.core.domain.Unit unit) throws com.stibo.core.domain.ValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\TagValidatorException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when a value contains invalid tags
 */
public class TagValidatorException extends com.stibo.core.domain.ValidatorException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\TreeNode.java
====================
package com.stibo.core.domain;

/**
 *A node with one parent.
 */
public abstract interface TreeNode<T extends com.stibo.core.domain.TreeNode<?>> extends com.stibo.core.domain.Node {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\UniqueConstraintException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when a unique constraint is violated by the client.
 */
public class UniqueConstraintException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Unit.java
====================
package com.stibo.core.domain;

/**
 *The Unit is used for representing attribute values of numeric quantities. The Unit for example could be
 * meters for an attribute modeling a length.
 */
public abstract interface Unit extends com.stibo.core.domain.Node {
  
  /**
   *Gets the unit group where the unit is placed.
   * Units are structure in a 2-level hierarchi with
   * unit groups and units. There is a one to many
   * relation between unit groups and units.
   *
   * @return the unit group where the unit is placed
   */
  public abstract com.stibo.core.domain.UnitGroup getUnitGroup();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\UnitConversionException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown during unit conversion if it is not possible to perform the conversion
 */
public class UnitConversionException extends java.lang.RuntimeException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\UnitGroup.java
====================
package com.stibo.core.domain;

/**
 *Domain unit group. A container for unit where new
 * units can be created
 */
public abstract interface UnitGroup extends com.stibo.core.domain.Node {
  
  /**
   *Gets all units in group. Returned set is a
   * copy so all operations on set will not
   * effect the unit group
   *
   * @return set of all units in group as a copy
   */
  public abstract java.util.Set<com.stibo.core.domain.Unit> getUnits();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\UnitGroupHome.java
====================
package com.stibo.core.domain;

/**
 *Home of unit group. Unit are organized in 2-level
 * structure of unit groups with units.
 */
public abstract interface UnitGroupHome {
  
  /**
   *Gets the unit group object corresponding to the external unit group id supplied
   *
   * @param id - the external id of the unit group required. e.g. the name of the unit group
   * @return A unit group object that represents the unit group having the external id supplied of null
   * if id isn't a valid identifier
   */
  public abstract com.stibo.core.domain.UnitGroup getUnitGroupByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\UnitHome.java
====================
package com.stibo.core.domain;

/**
 *<p>Home interface for unit. Defines a set of methods
 * to obtain domain unit objects through.<p>
 *
 * <p>The UnitHome can be obtained though the manager</p>
 * @see Manager#getUnitHome()
 */
public abstract interface UnitHome {
  
  /**
   *Returns the Unit object with the supplied ID
   *
   * @param id ID of the Unit object
   * @return the appropriate Unit object or null if no Unit with the supplied ID is found
   */
  public abstract com.stibo.core.domain.Unit getUnitByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\User.java
====================
package com.stibo.core.domain;

/**
 *A user of the STEP system. (Operator)
 * A user can be part of several Groups and will inherit privileges from these Groups so that the privileges
 * of a User becomes the super set of privileges inherited from the Groups that have the User as a member.
 */
public abstract interface User extends com.stibo.core.domain.Node, com.stibo.core.domain.Assignee {
  
  /**
   *Retrieves all user groups that the user is a member of.
   * As opposed to User.getGroups(), this method will return a set that includes all groups from the user
   * up to the "Users & Groups" top node.
   *
   * @return The set of user groups that the user is a member of.
   */
  public abstract java.util.Set<com.stibo.core.domain.Group> getAllGroups();
  
  /**
   *Retrieve the e-mail of this User
   *
   * @return e-mail as a string, can be <code>null</code> if no email exists.
   */
  public abstract java.lang.String getEMail();
  
  /**
   *Retrieve the Groups having this user as a member.
   *
   * @return The Groups having this User a member. The set will always contain at least one Group as no User can
   * exist without being a member of a least one Group.
   */
  public abstract java.util.Set<com.stibo.core.domain.Group> getGroups();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\UserHome.java
====================
package com.stibo.core.domain;

/**
 *Interface for finding users.
 */
public abstract interface UserHome {
  
  /**
   *Returns a User relating to the identifier supplied.
   * @param id The identifier of the User object.
   * @return A User object with the identifier supplied, or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.User getUserByID(java.lang.String id);
  
  /**
   *Returns a User relating to the identifier supplied.
   * @param id The identifier of the User object.
   * @return A User object with the identifier supplied, or <code>null</code> if not found.
   * @deprecated Please use {@link #getUserByID(String)} instead.
   */
  public abstract com.stibo.core.domain.User getUserById(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ValidatorException.java
====================
package com.stibo.core.domain;

/**
 *Superclass for exceptions that can occurs when trying to
 * set a value of a baseobject to something that isn't valid.
 * Consider catching this exception on setValue() methods
 * if the specific exception isn't interesting
 */
public abstract class ValidatorException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Value.java
====================
package com.stibo.core.domain;

/**
 *A Value expresses the fundamental ability of a BaseObject to have a value associated via an associated attribute.
 * Values can be both single- and multi-valued and the BaseObject is an abstraction covering both nodes and the
 * relations (links/references) between nodes.
 */
public abstract interface Value {
  
  /**
   *Determines, whether current user has privileges to write to this attribute value.
   *
   * @return true if the user has the necessary privileges, false if not.
   */
  public abstract boolean canSetValue();
  
  /**
   *Determines, whether current user has privileges to read this value.
   *
   * @return true if the user has the necessary privileges, false if not.
   */
  public abstract boolean canViewValue();
  
  /**
   *Delete the current value of this attribute value from the database.<p>
   * Notice that the attribute value object may still be used, for instance to create a new value or to examine a newly visible inherited value.<p>
   * If isInherited() OR isDimensionPointInherited(), this method does nothing (only deletes non-inherited values).<p>
   * If deleting a MultiValue, the entire value is gone, whereas deleting a SingleValue in a MultiValue only deletes the value. See MultiValue.deleteCurrent()
   * <p/>
   * see MultiValue#deleteCurrent()
   */
  public abstract void deleteCurrent();
  
  /**
   *Gets defining attribute of value.
   *
   * @return the attribute of value
   */
  public abstract com.stibo.core.domain.Attribute getAttribute();
  
  /**
   *Gets the BaseObject for the Value object.
   * As opposed to getOwnerObject(), this method will always return the
   * BaseObject for which the Value object is obtained and will do this regardless
   * of whether or not a value exists.
   *
   * @return BaseObject for the Value object
   */
  public abstract com.stibo.core.domain.BaseObject getBaseObject();
  
  /**
   *Gets all dimensions points for value.
   *
   * @return all dimensions points for value
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
  /**
   *Gets the object that owns the value.
   * For a value on the local object, this will be the same as getBaseObject().
   * For an inherited value, it will be the base object where the value is defined.
   * Returns null if no value exists.
   *
   * @return owner BaseObject or null, if no value exists.
   */
  public abstract com.stibo.core.domain.BaseObject getOwnerObject();
  
  /**
   *Get a simple value representation of the object. Will put a space between value and unit.
   * Will put &lt;multisep/&gt; between multivalues.
   *
   * @return simple value string, suitable for presentation to user or log file. Will return null if there is no value.
   */
  public abstract java.lang.String getSimpleValue();
  
  /**
   *Does the current value contain an inline reference
   * @return true if the value contains an inline reference
   */
  public abstract boolean hasInlineRef();
  
  /**
   *Is the current value derived?<p>
   * Notice, this is not the same as getAttribute().getDerived(), since the value may be overridden with a specific value.
   *
   * @return true if value is derived, false if not.
   */
  public abstract boolean isDerived();
  
  /**
   *Is the current value inherited in the dimension point graph(s)?<p>
   * Notice that for soft MultiValue objects, this returns true only if all the values in it are dimensionpoint inherited.
   *
   * @return true if value is inherited, false if all dimension points of the value corresponds to dimension points in the current context.
   * Will return false if there is no value.
   */
  public abstract boolean isDimensionPointInherited();
  
  /**
   *Returns true if there is a value and the value is inherited from an ancestor product.
   * Notice that the methods is for testing hierarchical value inheritance.
   * Use isDimensionPointInherited() to test whether the value is inherited from another dimension point / qualifier.
   * Further notice that the method will return false for product override values set on the overridden product.
   *
   * @return true if there is a value and the value is inherited from an ancestor product
   */
  public abstract boolean isInherited();
  
  /**
   *Is the current value inherited in the language dimension?<p>
   * Notice that for soft MultiValue objects, this returns true only if all the values in it are language inherited.
   *
   * @return true if value is inherited, false if it is on the current language. Will return false if there is no value.
   */
  public abstract boolean isLanguageInherited();
  
  /**
   *Returns true if a value is set locally on the base object.
   * Notice that the method covers hierarchical value inheritance; not inheritance through the dimension point / qualifier hierarchy.
   *
   * @return true if a value is set locally on the base object
   */
  public abstract boolean isLocal();
  
  /**
   *Is the current value mandatory?
   * (If the attribute link between the baseObject and the attribute is mandatory
   * the value is mandatory)
   * @return true if the value is mandatory, false if not.
   */
  public abstract boolean isMandatory();
  
  /**
   *Returns true if there is a value and it is not locally defined or inherited from an overridden product.
   * Notice that the method covers hierarchical value inheritance; not inheritance through the dimension point / qualifier hierarchy.
   *
   * @return true if there is a value and it is not locally defined or inherited from an overridden product.
   */
  public abstract boolean isNotLocal();
  
  /**
   *Is the value orphan? ie. if there is a attribute link somewhere in product or
   * classification hierarchy (via ClassificationProductLink) pointing to an
   * attribute of value than the value isn't orphan.
   *
   * <p>NB. Only products can have orphan values and the attribute of these values
   * must be a specification attribute</p>
   *
   * @return true if and only if value is orphan
   */
  public abstract boolean isOrphan();
  
  /**
   *Is this value inherited from overridden product?
   *
   * @return true if value is inherited, false if it is attached to the object of the attribute value. Will return false if there is no value.
   */
  public abstract boolean isProductOverrideInherited();
  
  /**
   *Set the simple value. Will identify units at the end of the value amongst those legal for the attribute.
   * Will split at &lt;multisep/&gt; for multivalues.
   *
   * @param value The simple value to set. Empty string or null is identical and means that local value will be deleted.
   * @throws ValidatorException if validation of value fails
   */
  public abstract void setSimpleValue(java.lang.String value) throws com.stibo.core.domain.ValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\ValueValidatorException.java
====================
package com.stibo.core.domain;

/**
 *Exception thrown when a value cannot be validated by attributes validator
 */
public abstract class ValueValidatorException extends com.stibo.core.domain.ValidatorException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\WorkflowableNode.java
====================
package com.stibo.core.domain;

/**
 *If a Node is of a type that can participate in a workflow it will support these methods.
 */
public abstract interface WorkflowableNode extends com.stibo.core.domain.Node {
  
  /**
   *Fetches the task for a specific state.
   * @param state the state to get a task for. Must not be <code>null</code>.
   * @return the task for the specified state. Returns <code>null</code> if no task exist for the specified state.
   */
  public abstract com.stibo.core.domain.state.Task getTask(com.stibo.core.domain.state.State state);
  
  /**
   *Return a specific task for this node.
   * @param workflowID id of the workflow. Must not be <code>null</code>.
   * @param stateID id of the state in the workflow. Must not be <code>null</code>.
   * @return the task for the node in the specified state or <code>null</code> if no task exist.
   */
  public abstract com.stibo.core.domain.state.Task getTaskByID(java.lang.String workflowID,java.lang.String stateID);
  
  /**
   *Fetches the requested Workflow.
   * @param workflow the definition of the workflow to get a instance for. Must not be <code>null</code>.
   * @return the workflow instance for the given Workflow Definition, or <code>null</code>., if the node does not participate in the given workflow.
   */
  public abstract com.stibo.core.domain.state.WorkflowInstance getWorkflowInstance(com.stibo.core.domain.state.Workflow workflow);
  
  /**
   *Fetches the requested Workflow.
   * @param workflowID id of the requested workflow. Must not be <code>null</code>.
   * @return the workflow instance for the given Workflow Definition, or <code>null</code>, if the node does not participate in the given workflow.
   */
  public abstract com.stibo.core.domain.state.WorkflowInstance getWorkflowInstanceByID(java.lang.String workflowID);
  
  /**
   *Returns all the workflow instances that this node is in
   * @return all the WorkflowInstances this node is in.
   */
  public abstract java.util.Set<com.stibo.core.domain.state.WorkflowInstance> getWorkflowInstances();
  
  /**
   *Checks whether or not the workflow is in a specific state.
   * @param workflowID the external step-workflow id of the workflow to test. Must not be <code>null</code>.
   * @param stateID the id of the state to test. Must not be <code>null</code>.
   * @return True if this item is in the specified state of the specified workflow.
   * @throws RuntimeException if the workflow does not exist.
   */
  public abstract boolean isInState(java.lang.String workflowID,java.lang.String stateID);
  
  /**
   *Checks whether or not the current Node is in the specified workflow.
   * @param workflowID the external step-workflow id of the workflow to test. Must not be <code>null</code>.
   * @return True if this item is started in the specified workflow.
   * @throws RuntimeException if the workflow does not exist.
   */
  public abstract boolean isInWorkflow(java.lang.String workflowID);
  
  /**
   *Checks whether or not the current Node is valid for the specified workflow
   * @param workflowID the external step-workflow id of the workflow to test. Must not be <code>null</code>.
   * @return True if this node is valid for the specified workflow.
   */
  public abstract boolean isValidForWorkflow(java.lang.String workflowID);
  
  /**
   *Starts the workflow with the given id for this node.
   * Note that there can only be one instance of a workflow for a node.
   * The request will fail if the flow is already started or is of an object-type not valid for the workflow
   * @param workflowID id of the workflow to instantiate. Must not be <code>null</code>.
   * @param message an optional message for the log. Can be <code>null</code>.
   * @return a new workflow instance or <code>null</code> if start condition is preventing workflow from starting
   * @throws IllegalArgumentException if the requested workflow does not exist.
   */
  public abstract com.stibo.core.domain.state.WorkflowInstance startWorkflowByID(java.lang.String workflowID,java.lang.String message);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\Workspace.java
====================
package com.stibo.core.domain;

/**
 *Workspaces allow workspace revisable data objects to be edited in one workspace without affecting the versions in other workspaces.
 * <p>
 * Standard STEP installations come with two workspaces, Main and Approved, where Main is the editable "draft" workspace
 * and Approved is a non-editable workspace representing the version of data exposed to downstream systems (or other purposes).
 * <p>
 * Data is reflected in the Approved workspace via the approval functionality.
 */
public abstract interface Workspace extends com.stibo.core.domain.Node, com.stibo.core.domain.ReferenceTarget {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\WorkspaceHome.java
====================
package com.stibo.core.domain;

/**
 *Home interface for the workspace object. Defines a set of methods
 * to obtain domain workspace objects through.
 */
public abstract interface WorkspaceHome {
  
  /**
   *Returns the Approved workspace.
   * @return Approved workspace.
   */
  public abstract com.stibo.core.domain.Workspace getApprovedWorkspace();
  
  /**
   *The Main workspace.
   * @return Main workspace.
   */
  public abstract com.stibo.core.domain.Workspace getMainWorkspace();
  
  /**
   *Returns the Workspace matching the workspace id passed to this method.
   * Returns null if id is null or does not match a valid workspace.
   * @param id The id of the workspace to fetch.
   * @return A Workspace object that represents the Workspace having the id supplied.
   */
  public abstract com.stibo.core.domain.Workspace getWorkspaceByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\WorkspaceRevisableNode.java
====================
package com.stibo.core.domain;

/**
 *A node that is under revision control and can be dimension dependent. This is the common supertype for
 * Products, Classifications and Assets.
 * @deprecated Use WorkspaceAwareRevisableNode for workspace-aware purposes
 * or DataNode for objects that bears interesting information.
 */
@java.lang.Deprecated()
public abstract interface WorkspaceRevisableNode extends com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.ReferenceTarget, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.ReferenceSource, com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode, com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.translation.TranslatableNode {
  
  /**
   *Approve this node in current context (workspace must be Main, otherwise an exception is thrown).
   * 
   * @return the return value is a set of synchronize exceptions. In no exceptions has occurred during appproval
   * this collection will be empty. (E.g. at synchronze exception happen when trying to approve a child product
   * which has a parent that has not yet been approved.
   * @throws ApproveBulkValidationException covers a number of cases that might fail due to missing mandatory values,
   * failing triggers, business rules, or validating of approvals of LOV values. NOTICE that for now, the client is responsible for doing a rollback if this exception occurs.
   * @throws SynchronizeException covers various cases that might arise during approved see doc of SynchronizeException classe
   * @throws RuntimeException if current workspace is not Main.
   */
  public abstract java.util.Collection<com.stibo.core.domain.synchronize.exception.SynchronizeException> approve() throws com.stibo.core.domain.synchronize.exception.SynchronizeException,com.stibo.core.domain.approve.ApproveBulkValidationException;
  
  /**
   *Approve the specified objects (values/names/references) for this revisable node.
   * The objects to approve for this node carries the a set of dimension
   * points indentifying which contexts to approve in, ie. the method is
   * independent of the current viewing context.
   * Regarding workspaces: this method will always approve
   * the data from maintenance "Main" to "Approved". Current workspace MUST be Main, otherwise an exception is thrown.
   *
   * @param setOfPartObjects The objects to approve on this revisable node. This Set should only
   *                            contain objects owned by this node - (
   *                            this is always true if it only contains object received from query to get
   *                            non approved objects.
   * @return the return value is a set of synchronize exceptions. In no exceptions has occurred during appproval
   * this collection will be empty. (E.g. at synchronze exception happen when trying to approve a child product
   * which has a parent that has not yet been approved.
   * @throws ApproveBulkValidationException if a validation error occurs during approval (see subclasses of ApproveValidationException)
   * @throws SynchronizeException covers various cases that might arise during approved see doc of SynchronizeException classe
   * @throws RuntimeException if current workspace is not Main.
   */
  public abstract java.util.Collection<com.stibo.core.domain.synchronize.exception.SynchronizeException> approve(java.util.Set<com.stibo.core.domain.partobject.PartObject> setOfPartObjects) throws com.stibo.core.domain.synchronize.exception.SynchronizeException,com.stibo.core.domain.approve.ApproveBulkValidationException;
  
  /**
   *Deprecated legacy method for getting the approval status<p/>
   * @return approval status
   * @deprecated use WorksapceAwareRevisableNode.getApprovalStatus() instead.
   */
  public abstract com.stibo.core.domain.WorkspaceRevisableNode.ApproveStatus getApproveStatus();
  
  /**
   *Get set of PartObject instances representing the parts of this node having changes that is not approved.
   * Note: The part-object does not necessarily tell what changed in that part. 
   * E.g. a reference may both have been created or had changed a meta-attribute value.
   * Such differences can be discovered by comparing the retrieved part from the Main and the Approved workspace.   
   * @return Set of unapproved PartObjects (empty set if non objects)
   */
  public abstract java.util.Set<com.stibo.core.domain.partobject.PartObject> getNonApprovedObjects();
  
  /**
   *Approve status. Can be non approved, context approved or complete approved.
   */
  @java.lang.Deprecated()
  public enum ApproveStatus {
    /**
     *Status for node that is not approved, ie. has unapproved data in context.
     */
    NotApproved("Not Approved"), 
    /**
     *Status for node that is context/partially approved, ie. has unapproved data in other context, but seen from this context no unapproved data.
     */
    ContextApproved("Context Approved"), 
    /**
     *Status for node that is completely approved, ie. approved as seen from all contexts.
     */
    CompleteApproved("Complete Approved");
    /**
     *Name of approve status.
     */
    private java.lang.String name;
    /**
     *Return a string form of the ApproveStatus
     * @return String representation of ApproveStatus.
     */
    public java.lang.String toString() {
      throw new java.lang.UnsupportedOperationException();
    }
    
    private ApproveStatus(java.lang.String name) {}
    
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\WorkspaceRevisableTreeNode.java
====================
package com.stibo.core.domain;

/**
 *WorkspaceRevisableNodes that can have children and a parent.
 * Deprecated! Consider to use WorkspaceAwareDataTreeNode, or TableableNode, PublishableNode, ProductTemplatingNode, etc.
 */
@java.lang.Deprecated()
public abstract interface WorkspaceRevisableTreeNode<T extends com.stibo.core.domain.WorkspaceRevisableTreeNode<T>> extends com.stibo.core.domain.attributelink.AttributeLinkable, com.stibo.core.domain.Node, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode, com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.translation.TranslatableNode, com.stibo.core.domain.WorkspaceRevisableNode, com.stibo.core.domain.datatreenode.DataTreeNode<T> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\approve\ApproveBulkValidationException.java
====================
package com.stibo.core.domain.approve;

/**
 *During approval multiple blocking exceptions might occur that must cause the approval
 * to fail without committing anything. E.g. if multiple business rules doing validation are violated
 * each of these will throw an exception. Such exceptions are collected and thrown as one instance of
 * ApproveBulkValidationException basically being a set of the original validation exceptions.
 */
public class ApproveBulkValidationException extends com.stibo.core.domain.approve.ApproveValidationException {
  
  /**
   *Get validation exceptions
   * @return set of validation exceptions that caused this bulk exception to be thrown
   */
  public java.util.Set<? extends com.stibo.core.domain.approve.ApproveValidationException> getValidatorExceptions() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\approve\ApproveValidationException.java
====================
package com.stibo.core.domain.approve;

/**
 *Super exception for all exceptions thrown due to validation errors during approval. Subclass it to create a localizable message.
 */
public class ApproveValidationException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\approve\unstable\CustomApproveValidationException.java
====================
package com.stibo.core.domain.approve.unstable;

/**
 *Legacy class for custom approve validations, kept only to allow custom development to port code easily.
 *
 * All customizations seems to pass in the message to present as the key in the user message object. Noone expects it to format using GUIBundle keys anyway. This is reflected in the implementation...
 */
public class CustomApproveValidationException extends com.stibo.core.domain.approve.ApproveValidationException {
  
  /**
   *Constructor.
   * @param id identifying the validator from which this exception is thrown
   * @param message description of the exception
   */
  public CustomApproveValidationException(java.lang.String id,java.lang.String message) {}
  
  /**
   *Constructor.
   * @param id identifying the validator from which this exception is thrown
   * @param message description of the exception
   * @param dependentURLs URLs of nodes that in some way related to this exception
   */
  public CustomApproveValidationException(java.lang.String id,java.lang.String message,java.util.Set<java.lang.String> dependentURLs) {}
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\asset\AssetContent.java
====================
package com.stibo.core.domain.asset;

/**
 *Asset content for a certain viewing context.
 */
public abstract interface AssetContent {
  
  /**
   *Get the value for the indicated attribute on asset - using same dimension-points as in this asset content object.
   * If attribute has no dimension dependencies method will simple return dimension independent value from asset as well.
   * If attribute depend on dimensions and these dimension dependencies are different from asset content dimension
   * dependencies then an IllegalArgumentException is thrown.
   * @param attributeId The id of the attribute we want the value for.
   * @return The appropriate value.
   * Will return null if no value exists or if not privileged to read value.
   * @throws IllegalArgumentException if the attribute does not exists - or if attribute is dimension dependent and differs
   * from asset-content dimension dependencies.
   */
  public abstract java.lang.String getSimpleValue(java.lang.String attributeId);
  
  /**
   *Return the size of this asset's contents.
   *
   * @return The size of this asset's contents.
   */
  public abstract java.lang.String getSize();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\attributelink\AttributeLinkable.java
====================
package com.stibo.core.domain.attributelink;

/**
 *Features for objects that have attributelinks
 */
public abstract interface AttributeLinkable {
  
  /**
   *Validate an attribute for this revisable tree node.
   * .
   * @param attribute The attribute to validate
   * @return the link created
   * @throws com.stibo.core.domain.UniqueConstraintException if the attribute already is validates for node
   */
  public abstract com.stibo.core.domain.AttributeLink createAttributeLink(com.stibo.core.domain.Attribute attribute) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *Gets the local attribute link pointing to the specified attribute.
   *
   * @param attribute The attribute for which to retrieve the link.
   * @return The attribute link or null if no local link exists to the specified attribute.
   */
  public abstract com.stibo.core.domain.AttributeLink getAttributeLink(com.stibo.core.domain.Attribute attribute);
  
  /**
   *Returns the attributes that are legal for this tree node.
   *
   * @return The valid attributes or the empty set if none applies.
   */
  public abstract java.util.Set<com.stibo.core.domain.AttributeLink> getAttributeLinks();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\backgroundprocess\BackgroundProcess.java
====================
package com.stibo.core.domain.backgroundprocess;

/**
 *STEP domain model for background processes such as imports, exports, recursive approvals, etc.
 */
public abstract interface BackgroundProcess extends com.stibo.core.domain.Node {
  
  /**
   *<p>Writes BackgroundProcess attachment content to OutputStream supplied as parameter.
   * Remember to close the OutputStream.</p>
   * <p>Example:</p>
   * <pre>{@code
   *  try (OutputStream outputStream = new FileOutputStream(new File("fileName"))) {<br/>
   *      backgroundProcess.downloadAttachment("attachmentId", outputStream);
   *  }<br/>
   * }</pre>
   *
   * @param id id of the attachment
   * @param outputStream the stream to write BackgroundProcess attachment content to (remember to close it)
   * @throws IOException in case something goes wrong while content is written to stream
   */
  public abstract void downloadAttachment(java.lang.String id,java.io.OutputStream outputStream) throws java.io.IOException;
  
  /**
   *Returns a list of BackgroundProcessAttachmentMetadata objects representing the public file attachments
   * produced by the background process
   *
   * @return list of attachments metadata available in current BackgroundProcess
   */
  public abstract java.util.List<com.stibo.core.domain.backgroundprocess.attachment.BackgroundProcessAttachmentMetadata> getAttachmentsMetadata();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\backgroundprocess\BackgroundProcessHome.java
====================
package com.stibo.core.domain.backgroundprocess;

public abstract interface BackgroundProcessHome extends com.stibo.core.domain.NodeHome {
  
  /**
   *Get a BackgroundProcess object corresponding to the external BackgroundProcess id supplied
   * @param id - the external id of the BackgroundProcess required. e.g. the name of the BackgroundProcess
   * @return A BackgroundProcess object that represents the BackgroundProcess having the external id supplied
   */
  public abstract com.stibo.core.domain.backgroundprocess.BackgroundProcess getBackgroundProcessByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\backgroundprocess\attachment\BackgroundProcessAttachmentMetadata.java
====================
package com.stibo.core.domain.backgroundprocess.attachment;

/**
 *Model representing BackgroundProcess attachment metadata like:
 *  - unique id
 *  - short description
 */
public abstract interface BackgroundProcessAttachmentMetadata {
  
  /**
   *Gets the description of the BackgroundProcess attachment
   * @return BackgroundProcess attachment description
   */
  public abstract java.lang.String getDescription();
  
  /**
   *Gets the unique ID of the BackgroundProcess attachment metadata
   * @return BackgroundProcess attachment metadata unique ID
   */
  public abstract java.lang.String getID();
  
  /**
   *Gets the mime type of the BackgroundProcess attachment
   * @return BackgroundProcess attachment mime type
   */
  public abstract java.lang.String getMimeType();
  
  /**
   *Gets the name of the BackgroundProcess attachment
   * @return BackgroundProcess attachment name
   */
  public abstract java.lang.String getName();
  
  /**
   *Gets the ID of the BackgroundProcess attachment. Please remember
   * that this ID does not have to be unique - same ID can be used by
   * multiple attachments if the attachment holds multiple files.
   * @return BackgroundProcess attachment ID
   */
  public abstract java.lang.String getOriginalAttachmentID();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\backgroundprocess\service\ServiceDescriptor.java
====================
package com.stibo.core.domain.backgroundprocess.service;

/**
 *A service descriptor is a handle (identification) for a service (background process for now).
 *
 * It knows its parameter, ensuring that clients call us with the correct parameter.
 *
 * Notice that the implementation MUST be a class. And really should be final.
 * @param <Parameter>  the type of the parameter to use when invoking the service.
 */
public abstract interface ServiceDescriptor<Parameter extends java.lang.Object> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\baseobjecttype\BaseObjectType.java
====================
package com.stibo.core.domain.baseobjecttype;

/**
 *Interface for types of BaseObject.
 * This primarily has to do with capabilities to have valid description attributes.
 */
public abstract interface BaseObjectType extends com.stibo.core.domain.Node {
  
  /**
   *Returns all valid description attributes.
   * @return The set of description Attributes that are valid, or the empty set if none applies.
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getValidDescriptionAttributes();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\basereferencesource\BaseReferenceSource.java
====================
package com.stibo.core.domain.basereferencesource;

public abstract interface BaseReferenceSource extends com.stibo.core.domain.BaseObject {
  
  /**
   *Creates a reference from this node.
   * @param targetNode the node that the reference should point to
   *
   * @param type the reference type for the reference to create
   * @return the newly created reference
   * @throws com.stibo.core.domain.UniqueConstraintException if a reference of the specified type to the specified target already exist or if the reference type only allows for a single reference and a reference already exists
   * @throws LinkTypeNotValidException if the reference source or reference target is not valid for the specified reference type
   */
  public abstract com.stibo.core.domain.Reference createReference(com.stibo.core.domain.ReferenceTarget targetNode,com.stibo.core.domain.ReferenceType type) throws com.stibo.core.domain.UniqueConstraintException,com.stibo.core.domain.LinkTypeNotValidException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\BusinessAction.java
====================
package com.stibo.core.domain.businessrule;

/**
 *Represents a configurable unit of logic that can be executed against STEP data (commonly a Node).
 * Business actions are intended to have side effects, i.e. change the state of STEP data.
 */
public abstract interface BusinessAction extends com.stibo.core.domain.Node, com.stibo.core.domain.RevisableNode {
  
  /**
   *Executes this business action using the passed node as Current Object bind.
   * Note that this will not support context specific binds.
   * @param node current node, is a required parameter, must not be null.
   * @return A BusinessActionResult for which isNonApplicable() will return true if the action was not valid
   * for the object it was sought executed against (invalid object type or pre-condition evaluating to false).
   * @throws BusinessRuleException  In case an exception is raised while executing this business action.
   * Changes to STEP data made by the action will in this case be rolled back.
   */
  public abstract com.stibo.core.domain.businessrule.evaluate.BusinessActionResult execute(com.stibo.core.domain.Node node) throws com.stibo.core.domain.businessrule.evaluate.BusinessRuleException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\BusinessCondition.java
====================
package com.stibo.core.domain.businessrule;

/**
 *Represents a configurable unit of logic that can be evaluated against STEP data (commonly a Node).
 * Business conditions should not have any side effects.
 */
public abstract interface BusinessCondition extends com.stibo.core.domain.Node, com.stibo.core.domain.RevisableNode {
  
  /**
   *Evaluates this business condition using the passed node as Current Object.
   * Note that this will not support context specific binds.
   * A Message returned from a BusinessConditon.evaluate() call can be localized in javascript like this:
   * <pre>
   * var brHome = node.getManager().getHome(com.stibo.core.domain.businessrule.BusinessRuleHome)
   * var myCondition = brHome.getBusinessConditionByID("ConditionWithMessage")
   * var bcResult =myCondition.evaluate(node)
   * if (bcResult.isRejected()) {
   *   var myLocale = manager.getCurrentContext().getLocale()
   *   var myLocalizer = new com.stibo.framework.localization.simple.SimpleLocalizerFactory().getLocalizer(myLocale)
   *   logger.info("Localized Message " + myLocalizer.localize(bcResult.getLocalizableMessages()));
   * }
   * </pre>
   * @param node Current node, is a required parameter, must not be null.
   * @return Result from evaluating this business condition using the node as Current Object binding.
   * @throws BusinessRuleException In case an exception is raised while evaluating this business condition.
   */
  public abstract com.stibo.core.domain.businessrule.evaluate.BusinessConditionResult evaluate(com.stibo.core.domain.Node node) throws com.stibo.core.domain.businessrule.evaluate.BusinessRuleException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\BusinessRuleHome.java
====================
package com.stibo.core.domain.businessrule;

/**
 *Home interface for interacting with business rules. This is the main entry point for retriving and executing
 * business actions and evaluating business conditions
 */
public abstract interface BusinessRuleHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Gets a business action specified by a defined id.
   * Will return null if no business action matches supplied id.
   * @param id the id of the business action.
   * @return the business action found or null if no business action was found matching the supplied id.
   */
  public abstract com.stibo.core.domain.businessrule.BusinessAction getBusinessActionByID(java.lang.String id);
  
  /**
   *Gets a business condition specified by a defined id.
   * Will return null if no business condition matches supplied id.
   * @param id the id of the business condition.
   * @return the business condition found or null if no business condition was found matching the supplied id.
   */
  public abstract com.stibo.core.domain.businessrule.BusinessCondition getBusinessConditionByID(java.lang.String id);
  
  /**
   *Gets a business function specified by a defined id.
   * Will return null if no business function matches supplied id.
   * @param id the id of the business function.
   * @return the business function found or null if no business function was found matching the supplied id.
   */
  public abstract com.stibo.core.domain.businessrule.function.BusinessFunction getBusinessFunctionByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\conditionalvalidity\hidden\HiddenContext.java
====================
package com.stibo.core.domain.businessrule.conditionalvalidity.hidden;

/**
 *A context to mark data as hidden elements for clients.
 */
public abstract interface HiddenContext {
  
  /**
   *Allows to mark the baseObject's attribute as hidden for the client.
   * The client gets information that the attribute is hidden and decides how to handle it.
   *
   * @param baseObject the baseObject for which attribute should be marked as hidden
   * @param attribute  the attribute which should be marked as hidden
   */
  public abstract void setHidden(com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Attribute attribute);
  
  /**
   *Allows to mark the baseObject's linkType as hidden for clients.
   * The client gets information that the link type is hidden and decides how to handle it.
   *
   * @param baseObject the baseObject for which linkType should be marked as hidden
   * @param linkType   the linkType which should be marked as hidden
   */
  public abstract void setHidden(com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.LinkType linkType);
  
  /**
   *Allows to mark the referenceSource's referenceType as hidden for clients.
   * The client gets information that the referenceSource is hidden and decides how to handle it.
   *
   * @param referenceSource the hasDataContainers for which attributes on referenceType  should be marked as hidden
   * @param referenceType   the referenceType which contains the attributes
   * @param attributes      the Attributes... which should be marked as hidden
   */
  public abstract void setHidden(com.stibo.core.domain.ReferenceSource referenceSource,com.stibo.core.domain.ReferenceType referenceType,com.stibo.core.domain.Attribute... attributes);
  
  /**
   *Allows to mark the hasDataContainers's dataContainerType as hidden for clients.
   * The client gets information that the dataContainerType is hidden and decides how to handle it.
   *
   * @param hasDataContainers the hasDataContainers for which dataContainerType should be marked as hidden
   * @param dataContainerType the dataContainerType which should be marked as hidden
   */
  public abstract void setHidden(com.stibo.core.domain.hasdatacontainers.HasDataContainers hasDataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
  /**
   *Allows to mark the hasDataContainers's dataContainerType as hidden for clients.
   * The client gets information that the dataContainerType is hidden and decides how to handle it.
   *
   * @param dataContainers    the hasDataContainers for which dataType on dataContainerType  should be marked as hidden
   * @param dataContainerType the dataContainerType which contains the dataType
   * @param dataType          the dataType which is allowed to be only Attribute or ReferenceType which should be marked as hidden
   */
  public abstract void setHidden(com.stibo.core.domain.hasdatacontainers.HasDataContainers dataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType,com.stibo.core.domain.DataType dataType);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\conditionalvalidity\mandatory\MandatoryContext.java
====================
package com.stibo.core.domain.businessrule.conditionalvalidity.mandatory;

/**
 *Context allows to mark data as mandatory elements.
 */
public abstract interface MandatoryContext {
  
  /**
   *Allows to mark the baseObject's attribute as mandatory for the client.
   * The client gets information that the attribute is mandatory and decides how to handle it.
   *
   * @param baseObject the baseObject for which attribute should be marked as mandatory
   * @param attribute  the attribute which should be marked as mandatory
   */
  public abstract void setMandatory(com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Attribute attribute);
  
  /**
   *Allows to mark the baseObject's linkType as mandatory for clients.
   * The client gets information that the link type is mandatory and decides how to handle it.
   *
   * @param baseObject the baseObject for which attribute should be marked as mandatory
   * @param linkType   the linkType which should be marked as mandatory
   */
  public abstract void setMandatory(com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.LinkType linkType);
  
  /**
   *Allows to mark the baseObject's attribute as mandatory for the client.
   * The client gets information that the attribute is mandatory and decides how to handle it.
   *
   * @param localizableMessage the localizable message
   * @param baseObject         the baseObject for which attribute should be marked as mandatory
   * @param attribute          the attribute which should be marked as mandatory
   */
  public abstract void setMandatory(java.lang.Object localizableMessage,com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Attribute attribute);
  
  /**
   *Allows to mark the baseObject's linkType as mandatory for clients.
   * The client gets information that the link type is mandatory and decides how to handle it.
   *
   * @param localizableMessage the localizable message
   * @param baseObject         the baseObject for which attribute should be marked as mandatory
   * @param linkType           the linkType which should be marked as mandatory
   */
  public abstract void setMandatory(java.lang.Object localizableMessage,com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.LinkType linkType);
  
  /**
   *Allows to mark the datatype of reference/attribute on referenceType  as mandatory
   *
   * @param localizableMessage the localizable message
   * @param referenceSource    the referenceSource for which referenceType is legal for
   * @param referenceType      the ReferenceType that contains the attributes
   * @param attributes         the attributes that should be marked as mandatory
   */
  public abstract void setMandatory(java.lang.Object localizableMessage,com.stibo.core.domain.ReferenceSource referenceSource,com.stibo.core.domain.ReferenceType referenceType,com.stibo.core.domain.Attribute... attributes);
  
  /**
   *Allows to mark the reference inside a datacontainer object as mandatory
   *
   * @param localizableMessage  the localizable message
   * @param dataContainerObject the dataContainerObject for which reference should be marked as mandatory
   * @param referenceType       the referenceType which should be marked as mandatory
   */
  public abstract void setMandatory(java.lang.Object localizableMessage,com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject,com.stibo.core.domain.ReferenceType referenceType);
  
  /**
   *Allows to mark the datacontainer  as mandatory
   *
   * @param localizableMessage the localizable message
   * @param hasDataContainers  the hasDataContainers for which datacontainer should be marked as mandatory
   * @param dataContainerType  the dataContainerType which should be marked as mandatory
   */
  public abstract void setMandatory(java.lang.Object localizableMessage,com.stibo.core.domain.hasdatacontainers.HasDataContainers hasDataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
  /**
   *Allows to mark the datatype of reference/attribute on datacontainer  as mandatory
   *
   * @param localizableMessage the localizable message
   * @param dataContainers     the hasDataContainers for which datacontainer is legal for
   * @param dataContainerType  the dataContainerType that contains the dataType
   * @param dataType           the dataType which is allowed to be only Attribute or ReferenceType which should be marked as mandatory
   */
  public abstract void setMandatory(java.lang.Object localizableMessage,com.stibo.core.domain.hasdatacontainers.HasDataContainers dataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType,com.stibo.core.domain.DataType dataType);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\conditionalvalidity\readonly\ReadOnlyContext.java
====================
package com.stibo.core.domain.businessrule.conditionalvalidity.readonly;

/**
 *A context to mark data as read only elements for clients.
 */
public abstract interface ReadOnlyContext {
  
  /**
   *Allows to mark the baseObject's attribute as read only for the client.
   * The client gets information that the attribute is read only and decides how to handle it.
   *
   * @param baseObject the baseObject for which attribute should be marked as read only
   * @param attribute  the attribute which should be marked as read only
   */
  public abstract void setReadOnly(com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Attribute attribute);
  
  /**
   *Allows to mark the baseObject's linkType as read only for clients.
   * The client gets information that the link type is read only and decides how to handle it.
   *
   * @param baseObject the baseObject for which linkType should be marked as read only
   * @param linkType   the linkType which should be marked as read only
   */
  public abstract void setReadOnly(com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.LinkType linkType);
  
  /**
   *Allows to mark the baseObject's attribute as read only for the client with the message why it was set as ready only.
   * The client gets information that the attribute is read only and the message and decides how to handle it.
   *
   * @param localizableMessage the message for a user
   * @param baseObject         the baseObject for which attribute should be marked as read only
   * @param attribute          the attribute which should be marked as read only
   */
  public abstract void setReadOnly(java.lang.Object localizableMessage,com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Attribute attribute);
  
  /**
   *Allows to mark the baseObject's linkType as read only for clients with the message why it is read only.
   * The client gets information that the link type is read only and the message and decides how to handle it.
   *
   * @param localizableMessage the message for a user
   * @param baseObject         the baseObject for which linkType should be marked as read only
   * @param linkType           the linkType which should be marked as read only
   */
  public abstract void setReadOnly(java.lang.Object localizableMessage,com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.LinkType linkType);
  
  /**
   *Allows to mark the datatype of reference/attribute on referenceType   as readonly
   *
   * @param localizableMessage the localizable message
   * @param referenceSource    the referenceSource for which referenceType is legal for
   * @param referenceType      the ReferenceType that contains the attributes
   * @param attributes         the attributes that should be marked as mandatory
   */
  public abstract void setReadOnly(java.lang.Object localizableMessage,com.stibo.core.domain.ReferenceSource referenceSource,com.stibo.core.domain.ReferenceType referenceType,com.stibo.core.domain.Attribute... attributes);
  
  /**
   *Allows to mark the reference inside a datacontainer object as readonly
   *
   * @param localizableMessage  the localizable message
   * @param dataContainerObject the dataContainerObject for which reference should be marked as mandatory
   * @param referenceType       the referenceType which should be marked as mandatory
   */
  public abstract void setReadOnly(java.lang.Object localizableMessage,com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject,com.stibo.core.domain.ReferenceType referenceType);
  
  /**
   *Allows to mark the  datacontainer  as readonly
   *
   * @param localizableMessage the localizable message
   * @param hasDataContainers  the hasDataContainers for which datacontainer should be marked as mandatory
   * @param dataContainerType  the dataContainerType which should be marked as mandatory
   */
  public abstract void setReadOnly(java.lang.Object localizableMessage,com.stibo.core.domain.hasdatacontainers.HasDataContainers hasDataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
  /**
   *Allows to mark the datatype of reference/attribute on datacontainer  as readonly
   *
   * @param localizableMessage the localizable message
   * @param dataContainers     the hasDataContainers for which datacontainer is legal for
   * @param dataContainerType  the dataContainerType that contains the dataType
   * @param dataType           the dataType which is allowed to be only Attribute or ReferenceType which should be marked as mandatory
   */
  public abstract void setReadOnly(java.lang.Object localizableMessage,com.stibo.core.domain.hasdatacontainers.HasDataContainers dataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType,com.stibo.core.domain.DataType dataType);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\errorhandling\context\DataIssuesContext.java
====================
package com.stibo.core.domain.businessrule.errorhandling.context;

/**
 *A context to add issues about data as either errors or warnings!
 */
public abstract interface DataIssuesContext {
  
  /**
   *Add an error issue as a localizable object.
   * @param localizableErrorMessage object annotated as Localizable
   */
  public abstract void addError(java.lang.Object localizableErrorMessage);
  
  /**
   *Add an error issue
   * @param localizableErrorMessage object annotated as Localizable
   * @param errorObject             of type BaseObject to accomodate both Node and Link types, other subtypes should be dismissed
   * @param attributes              attributes on the errorObject
   */
  public abstract void addError(java.lang.Object localizableErrorMessage,com.stibo.core.domain.BaseObject errorObject,com.stibo.core.domain.Attribute... attributes);
  
  /**
   *Add an error issue
   * @param localizableErrorMessage       object annotated as Localizable
   * @param baseObject                    of the baseObject as issue object
   * @param link                          with a Link
   */
  public abstract void addError(java.lang.Object localizableErrorMessage,com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Link link);
  
  /**
   *Add an error issue
   * @param localizableErrorMessage object annotated as Localizable
   * @param node                    a node to anchor the message
   * @param link                    a linktype that has issues in the context of the node
   */
  public abstract void addError(java.lang.Object localizableErrorMessage,com.stibo.core.domain.Node node,com.stibo.core.domain.LinkType link);
  
  /**
   *Add an error issue
   * @param localizableErrorMessage       object annotated as Localizable
   * @param dataContainerObject           of the dataContainerObject as issueObject
   * @param referenceType                 with a reference type
   */
  public abstract void addError(java.lang.Object localizableErrorMessage,com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject,com.stibo.core.domain.ReferenceType referenceType);
  
  /**
   *Add an error issue
   * @param localizableErrorMessage       object annotated as Localizable
   * @param hasDataContainers             of the type HasDataContainers
   * @param dataContainerType             with a datacontainerType
   */
  public abstract void addError(java.lang.Object localizableErrorMessage,com.stibo.core.domain.hasdatacontainers.HasDataContainers hasDataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
  /**
   *Add an issue report header
   * @param localizableHeader object annotated as Localizable
   */
  public abstract void addIssuesReportHeader(java.lang.Object localizableHeader);
  
  /**
   *Add a warning
   * @param localizableErrorMessage object annotated as Localizable
   */
  public abstract void addWarning(java.lang.Object localizableErrorMessage);
  
  /**
   *Add a warning issue
   * @param localizableErrorMessage object annotated as Localizable
   * @param errorObject             of type BaseObject to accomodate both Node and Link types, other subtypes should be dismissed
   * @param attributes              attributes on the errorObject
   */
  public abstract void addWarning(java.lang.Object localizableErrorMessage,com.stibo.core.domain.BaseObject errorObject,com.stibo.core.domain.Attribute... attributes);
  
  /**
   *Add an error issue
   * @param localizableErrorMessage       object annotated as Localizable
   * @param baseObject                    of the baseObject as issue object
   * @param link                           with a Link
   */
  public abstract void addWarning(java.lang.Object localizableErrorMessage,com.stibo.core.domain.BaseObject baseObject,com.stibo.core.domain.Link link);
  
  /**
   *Add a warning
   * @param localizableErrorMessage object annotated as Localizable
   * @param node                    a node to anchor the message
   * @param link                    a linktype that has issues in the context of the node
   */
  public abstract void addWarning(java.lang.Object localizableErrorMessage,com.stibo.core.domain.Node node,com.stibo.core.domain.LinkType link);
  
  /**
   *Add a warning issue
   * @param localizableErrorMessage       object annotated as Localizable
   * @param dataContainerObject           of the dataContainerObject as issueObject
   * @param referenceType                 with a referencetype
   */
  public abstract void addWarning(java.lang.Object localizableErrorMessage,com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject,com.stibo.core.domain.ReferenceType referenceType);
  
  /**
   *Add a warning issue
   * @param localizableErrorMessage       object annotated as Localizable
   * @param hasDataContainers             of the type HasDataContainers
   * @param dataContainerType             with a datacontainerType
   */
  public abstract void addWarning(java.lang.Object localizableErrorMessage,com.stibo.core.domain.hasdatacontainers.HasDataContainers hasDataContainers,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\evaluate\BusinessActionResult.java
====================
package com.stibo.core.domain.businessrule.evaluate;

/**
 *<p>Result from executing a business action.</p>
 * <p>isNonApplicable() will return true if the action was not valid for the object it was executed against
 * (invalid object type or pre-condition evaluating to false).</p>
 */
public class BusinessActionResult {
  
  /**
   *Returns true if the action was not valid for the object it was executed against
   * (invalid object type or pre-condition evaluating to false).
   * @return true if not applicable, otherwise false.
   */
  public boolean isNonApplicable() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\evaluate\BusinessConditionResult.java
====================
package com.stibo.core.domain.businessrule.evaluate;

/**
 *<p>Result from evaluating a business condition.</p>
 * <p>If the condition was evaluated to Boolean true, isAccepted() will return true.
 * If the condition was evaluated to Boolean false, isRejected() will return true.
 * isNonApplicable() will return true if the condition was not valid for the object it was evaluated against
 * (invalid object type or pre-condition evaluating to false).
 * When a condition is evaluated to be false, a localizable "rejection message" may be provided.
 * This message can be obtained by passing the BusinessConditionResult to a localizer method
 * like e.g. com.stibo.portal.api.component.context.ComponentContext.localize(java.lang.Object objectToLocalize).
 * </p>
 */
public class BusinessConditionResult {
  
  /**
   *Get Localizable Messages from business condition result.
   * @return List of Localizable Messages
   */
  public java.util.List<java.lang.Object> getLocalizableMessages() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns true if the condition was evaluated to be true.
   * isRejected() and isNonApplicable() will in this case be false.
   * @return true if condition was was evaluated to be true, false otherwise.
   */
  public boolean isAccepted() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns true if the condition was not valid for the object it was evaluated against
   * (invalid object type or pre-condition evaluating to false).
   * isAccepted() and isRejected() will in this case be false.
   * @return true if not applicable, otherwise false.
   */
  public boolean isNonApplicable() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns true if the condition was evaluated to be false.
   * isAccepted() and isNonApplicable() will in this case be false.
   * @return true if condition was evaluated to be false, false otherwise.
   */
  public boolean isRejected() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\evaluate\BusinessRuleException.java
====================
package com.stibo.core.domain.businessrule.evaluate;

/**
 *Thrown if the evaluation/execution of a business rule fails in a checked way
 * (one of the plugins fail with a BusinessRulePlugin exception for instance).
 * Exception message may be localizable and the exception can be passed to a localizer method like
 * e.g. com.stibo.portal.api.component.context.ComponentContext.localize(java.lang.Object objectToLocalize)
 * to obtain a localized message.
 */
public class BusinessRuleException extends java.lang.Exception {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\function\BusinessFunction.java
====================
package com.stibo.core.domain.businessrule.function;

/**
 *Business Function.
 */
public abstract interface BusinessFunction extends com.stibo.core.domain.Node, com.stibo.core.domain.RevisableNode {
  
  /**
   *Executes the business function and returns a result object.
   * @param functionParameterBinds input parameters to the business function
   * @return Object as specified in the script by the user.
   * @throws BusinessRuleException when execution cannot properly end.
   */
  public abstract java.lang.Object evaluate(java.util.Map<java.lang.String,java.lang.Object> functionParameterBinds) throws com.stibo.core.domain.businessrule.evaluate.BusinessRuleException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\businessrule\function\javascript\proxy\BusinessFunctionScriptingProxy.java
====================
package com.stibo.core.domain.businessrule.function.javascript.proxy;

/**
 *Interface providing functionality for evaluating business functions from JavaScript.
 */
public abstract interface BusinessFunctionScriptingProxy {
  
  /**
   *Method for evaluating business functions with no input parameters from JavaScript.
   *
   * @return the result of evaluating the business function
   * @throws BusinessRuleException if an error occurs during the business function evaluation
   */
  public abstract java.lang.Object evaluate() throws com.stibo.core.domain.businessrule.evaluate.BusinessRuleException;
  
  /**
   *Method for evaluating a business function from JavaScript with a specific Manager.
   * <p>
   * Causes the business function to be evaluated within the context of the passed Manager.
   * Input parameters can be passed as a Map or as a JavaScript object that will automatically
   * be converted to a Map.
   * The snippets below show three different valid ways of evaluating a function with a Boolean
   * and a String input parameter (input parameter identifiers "truncate" and "prefix", business
   * function bound to variable "bf", Manager bound to "manager"):
   * <pre>
   * {@code
   * // HashMap
   * var params = new java.util.HashMap();
   * params.put("truncate", true);
   * params.put("prefix", "A prefix");
   * var res = bf.evaluate(manager, params);
   *
   * // JavaScript object
   * var params = {};
   * params.truncate = true;
   * params.prefix = "A prefix";
   * var res = bf.evaluate(manager, params);
   *
   * // JavaScript object inline
   * var res = bf.evaluate(manager, {truncate: true, prefix: "A prefix"});
   * }
   * </pre>
   * Pass an empty Map or JavaScript object for functions that do not take any input parameters.
   * <p>
   * To avoid issues with type conversions, for Integer and Double input parameters it is
   * recommended to instantiate the correct Java types. I.e.:
   * <pre>
   * {@code
   * bf.evaluate(manager, {aDouble: new java.lang.Double(2.5), anInteger: new java.lang.Integer(6)});
   * }
   * </pre>
   * JavaScript arrays will automatically be converted to Lists and can be used for List input
   * parameters. E.g.
   * <pre>
   * {@code
   * bf.evaluate(manager, {products: [p1, p2, p3]});
   * }
   * </pre>
   * @param manager  the Manager to use for the function evaluation.
   * @param inputParameters  the input parameters required by the business function
   * @return the result of evaluating the business function
   * @throws BusinessRuleException if an error occurs during the business function evaluation
   */
  public abstract java.lang.Object evaluate(com.stibo.core.domain.Manager manager,java.util.Map<java.lang.String,java.lang.Object> inputParameters) throws com.stibo.core.domain.businessrule.evaluate.BusinessRuleException;
  
  /**
   *Method for evaluating a business function with input parameters from JavaScript.
   * <p>
   * Input parameters can be passed as a Map or as a JavaScript object that will automatically
   * be converted to a Map.
   * The snippets below show three different valid ways of evaluating a function with a Boolean
   * and a String input parameter (input parameter identifiers "truncate" and "prefix", business
   * function bound to variable "bf"):
   * <pre>
   * {@code
   * // HashMap
   * var params = new java.util.HashMap();
   * params.put("truncate", true);
   * params.put("prefix", "A prefix");
   * var res = bf.evaluate(params);
   *
   * // JavaScript object
   * var params = {};
   * params.truncate = true;
   * params.prefix = "A prefix";
   * var res = bf.evaluate(params);
   *
   * // JavaScript object inline
   * var res = bf.evaluate({truncate: true, prefix: "A prefix"});
   * }
   * </pre>
   * To avoid issues with type conversions, for Integer and Double input parameters it is
   * recommended to instantiate the correct Java types. I.e.:
   * <pre>
   * {@code
   * bf.evaluate({aDouble: new java.lang.Double(2.5), anInteger: new java.lang.Integer(6)});
   * }
   * </pre>
   * JavaScript arrays will automatically be converted to Lists and can be used for List input
   * parameters. E.g.
   * <pre>
   * {@code
   * bf.evaluate({products: [p1, p2, p3]});
   * }
   * </pre>
   * @param inputParameters  the input parameters required by the business function
   * @return the result of evaluating the business function
   * @throws BusinessRuleException if an error occurs during the business function evaluation
   */
  public abstract java.lang.Object evaluate(java.util.Map<java.lang.String,java.lang.Object> inputParameters) throws com.stibo.core.domain.businessrule.evaluate.BusinessRuleException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\changepackage\ChangePackage.java
====================
package com.stibo.core.domain.changepackage;

/**
 *A change package is a container for transporting and comparing system setup objects and friends.
 * <p>
 * BEWARE that Node objects in this class are only a subset of nodes, where their impl-equivalents must
 * subclass PackageChangeableImpl; but we are not allowed to create and use an interface for the latter,
 * so ClassCastExceptions may occur as a consequence
 */
public abstract interface ChangePackage extends com.stibo.core.domain.Node, com.stibo.core.domain.WorkflowableNode {
  
  /**
   *Used to add a specified item as primary item and all nodes below as secondary items to the change package.
   * @param item is the node we want to add to the Change Package as the primary item
   * @throws AddItemConflictException when an item was already added previously through the opposite method: item vs hierarchy
   */
  public abstract void addHierarchy(com.stibo.core.domain.Node item) throws com.stibo.core.domain.changepackage.exception.AddItemConflictException;
  
  /**
   *Used to add a single specified item to the change package
   * @param item is a type of Node that we want to add to the Change Package
   * @throws AddItemConflictException when an item was already added previously through the opposite method: item vs hierarchy
   */
  public abstract void addItem(com.stibo.core.domain.Node item) throws com.stibo.core.domain.changepackage.exception.AddItemConflictException;
  
  /**
   *Will return the set of the URLs of the primary items in the change package.
   *
   * @return packageitems
   */
  public abstract java.util.Collection<java.lang.String> getPrimaryItems();
  
  /**
   *Used to reopen a package
   * @throws InvalidStateException when it's already open
   */
  public abstract void reOpen() throws com.stibo.core.domain.changepackage.exception.InvalidStateException;
  
  /**
   *Used to remove a node from a change package (will also remove secondary items if any are connected to the primary item).
   * @param stepURL the URL of the item we want to remove from the change package
   */
  public abstract void removeItem(java.lang.String stepURL);
  
  /**
   *Seal a change package by starting a background process that will do the sealing.
   * @param signComments a comment at seal time.
   * @return the BGP ID of the Background process that was started
   * @throws InvalidStateException when its already sealed
   */
  public abstract java.lang.String startSealInBackground(java.lang.String signComments) throws com.stibo.core.domain.changepackage.exception.InvalidStateException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\changepackage\ChangePackageHome.java
====================
package com.stibo.core.domain.changepackage;

/**
 *The home used to retrieve, create or manipulate change packages.
 */
public abstract interface ChangePackageHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Creates a new change package under a given system setup node
   * @param parentID is going to be the SystemSetupGroup parent of the change package about to be created
   * @param cpID the id of the change package to be created
   * @return null or the change package found
   * @throws ObjectTypeConstraintException happens if a change package object type is not allowed under given setup node
   * @throws NodeIdUniqueConstraintException happens if a change package of the same ID already exist
   */
  public abstract com.stibo.core.domain.changepackage.ChangePackage createChangePackage(java.lang.String parentID,java.lang.String cpID) throws com.stibo.core.domain.ObjectTypeConstraintException,com.stibo.core.domain.NodeIdUniqueConstraintException;
  
  /**
   *Method to retrieve change package by id
   * @param id the external ID of the change package
   * @return the change package found or null
   */
  public abstract com.stibo.core.domain.changepackage.ChangePackage getChangePackageByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\changepackage\exception\AddItemConflictException.java
====================
package com.stibo.core.domain.changepackage.exception;

/**
 *Used when an item or hierarchy was already previously added and a user tries to add it again through the opposite method
 */
public class AddItemConflictException extends java.lang.Exception {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\changepackage\exception\ApprovalCheckedException.java
====================
package com.stibo.core.domain.changepackage.exception;

/**
 *Exception to use when there are unapproved items in a change package when we don't want to allow it
 */
public class ApprovalCheckedException extends java.lang.Exception {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\changepackage\exception\InvalidStateException.java
====================
package com.stibo.core.domain.changepackage.exception;

/**
 *Throw when someone tries to seal or open a change package while its in the wrong state
 */
public class InvalidStateException extends java.lang.Exception {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\classificationproductlinktype\ClassificationProductLinkTypeHome.java
====================
package com.stibo.core.domain.classificationproductlinktype;

/**
 *Home interface for access to ClassificationProductLinkTypes. To access it simple use:
 * <pre>{@code
 * manager.getHome(ClassificationProductLinkTypeHome.class)
 * }</pre> or for javascript
 * <pre>{@code
 * manager.getHome(com.stibo.core.domain.classificationproductlinktype.ClassificationProductLinkTypeHome)
 * }</pre>
 */
public abstract interface ClassificationProductLinkTypeHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Get the ClassificationProductLinkType with the supplied identifier.
   * @param id The identifier of the ClassificationProductLinkType object
   * @return ClassificationProductLinkType with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.ClassificationProductLinkType getLinkTypeByID(java.lang.String id);
  
  /**
   *Get ClassificationProductLinkType valid for provided classification object type
   * @param classificationObjectType object type for which classification product link
   *                                 should be valid
   * @return found ClassificationProductLinkType or <code>null</code> if not found
   */
  public abstract com.stibo.core.domain.ClassificationProductLinkType getLinkTypeValidForClassificationType(com.stibo.core.domain.ObjectType classificationObjectType);
  
  /**
   *Get all ClassificationProductLinkType objects
   * @return set of all ClassificationProductLinkType objects
   */
  public abstract java.util.Set<com.stibo.core.domain.ClassificationProductLinkType> getLinkTypes();
  
  /**
   *Get ClassificationProductLinkTypes valid for provided product object type
   * @param productObjectType object type for which classification product links
   *                          should be valid
   * @return found ClassificationProductLinkTypes set or empty set if not found
   */
  public abstract java.util.Set<com.stibo.core.domain.ClassificationProductLinkType> getLinkTypesValidForProductType(com.stibo.core.domain.ObjectType productObjectType);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\collection\NodeCollection.java
====================
package com.stibo.core.domain.collection;

/**
 *Interface for collections
 */
public abstract interface NodeCollection extends com.stibo.core.domain.Node {
  
  /**
   *Return a collection of node objects.
   * @return The collection of nodes.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.Node> queryNodes();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\collection\NodeCollectionHome.java
====================
package com.stibo.core.domain.collection;

/**
 *Home of collections.
 */
public abstract interface NodeCollectionHome {
  
  /**
   *Returns the collection object corresponding to the external id passed in
   * @param id - external id of the collection
   * @return the appropriate collection object or null if the external id is invalid
   */
  public abstract com.stibo.core.domain.collection.NodeCollection getNodeCollectionByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainer\DataContainer.java
====================
package com.stibo.core.domain.datacontainer;

/**
 *Represent data container domain objects that then can give you access to underlying Data Container Objects
 */
public abstract interface DataContainer {
  
  /**
   *Delete the local data container object behind this data container.
   * Notice that the data container object may still be used, for instance to create a new data container object or to examine a newly visible inherited value.
   * If isInherited() OR isDimensionPointInherited(), this method does nothing (only deletes non-inherited values).
   * If deleting a MultiDataContainer, all data container objects are deleted, whereas deleting a SingleDataContainer in a MultiDataContainer only deletes that one single data container object.
   * @return returns whether or not a data container object was deleted
   */
  public abstract boolean deleteLocal();
  
  /**
   *The object from where this DataContainer was requested.
   *
   * @return the object from where this DataContainer was requested
   */
  public abstract com.stibo.core.domain.hasdatacontainers.HasDataContainers getBaseObject();
  
  /**
   *Gets defining DataContainerType of value.
   *
   * @return the DataContainerType of value
   */
  public abstract com.stibo.core.domain.datacontainertype.DataContainerType getDataContainerType();
  
  /**
   *Is this container inherited from overridden product?
   *
   * @return true if container is inherited, false if it is attached to the object of the container. Will return false if there is no container.
   */
  public abstract boolean isProductOverrideInherited();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainer\MultiDataContainer.java
====================
package com.stibo.core.domain.datacontainer;

/**
 *Represents a multi valued data container domain object
 */
public abstract interface MultiDataContainer extends com.stibo.core.domain.datacontainer.DataContainer {
  
  /**
   *Creates and return new single data container.
   *
   * NOTE: this call will have NO effect unless createDataContainerObject()
   * method is called on returned SingleDataContainer instance.
   *
   * On the other hand when createDataContainerObject() is called on returned
   * SingleDataContainer instance then it will implicitly un-inherit any
   * other data container objects that might exists on base object
   * if they were inherited.
   *
   * @return the new local data container.
   */
  public abstract com.stibo.core.domain.datacontainer.SingleDataContainer addDataContainer();
  
  /**
   *Get the single data container objects in this multi valued data container.
   * Return null if no such object exists yet.
   * Manipulating any of the returned single data containers will only affect local data container objects
   * (will implicitly un-inherit these values if they were inherited).
   *
   * @return the single data container objects in this multi valued data container. Returns empty collection if no values exists.
   */
  public abstract java.util.Collection<com.stibo.core.domain.datacontainer.SingleDataContainer> getDataContainers();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainer\SingleDataContainer.java
====================
package com.stibo.core.domain.datacontainer;

/**
 *Represents a single data container domain object
 */
public abstract interface SingleDataContainer extends com.stibo.core.domain.datacontainer.DataContainer {
  
  /**
   *Create a local data container object behind this data container.
   * If a local object already exists an exception will be thrown.
   *
   * Throws SingleDataContainerConstraintException if a local
   * data container object already exists.
   *
   * Throws DataContainerTypeNotValidException if trying to create
   * a data container object for a data container type that is not valid
   * for current owner object.
   *
   * @return the new local data container object.
   * @param id the ID to use when creating data container object, if null or empty will try to auto-generate id using ID template of data container type
   * @throws UniqueConstraintException thrown if a constraint exception is raised during creation.
   */
  public abstract com.stibo.core.domain.datacontainerobject.DataContainerObject createDataContainerObject(java.lang.String id) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *Create a local data container object behind this data container and set the key values/references for the data container as specified
   * in the DataContainerKey.
   *
   * Notice that that this requires data container to auto-generate id using ID template of data container type
   *
   * Throws SingleDataContainerConstraintException if a local
   * data container object already exists.
   *
   * Throws DataContainerTypeNotValidException if trying to create
   * a data container object for a data container type that is not valid
   * for current owner object.
   *
   * Throws MissingValuesForDataContainerKey if not all key values are given
   * Throws IllegalDataContainerKeyParameterException if called with an illegal DtaContainerKey
   *
   * @return the new local data container object.
   * @param dataContainerKey Holds the values for the attributes and reference types used by the data container type key.
   *
   * @throws UniqueConstraintException thrown if a constraint exception is raised during creation.
   * @throws LinkTypeNotValidException if the reference source or reference target is not valid for the specified reference type used as key reference
   * @throws ValidatorException if validation of value in the data container key attributes fails
   */
  public abstract com.stibo.core.domain.datacontainerobject.DataContainerObject createDataContainerObjectWithKey(com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKey dataContainerKey) throws com.stibo.core.domain.UniqueConstraintException,com.stibo.core.domain.LinkTypeNotValidException,com.stibo.core.domain.ValidatorException;
  
  /**
   *Get the data container object behind this domain data container.
   * Return null if no such object exists yet.
   *
   * @return the data container object, or null if no such exists yet.
   */
  public abstract com.stibo.core.domain.datacontainerobject.DataContainerObject getDataContainerObject();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainerkey\keyhome\DataContainerKey.java
====================
package com.stibo.core.domain.datacontainerkey.keyhome;

/**
 *This represents a DataContainerKey that can be passed for creating or finding DataContainerObjects
 * Objects of this type is constructed using {@link DataContainerKeyBuilder}
 */
public abstract interface DataContainerKey {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainerkey\keyhome\DataContainerKeyBuilder.java
====================
package com.stibo.core.domain.datacontainerkey.keyhome;

/**
 *Builder for constructing DataContainerKey.
 * Instances of this type is acquired on {@link DataContainerKeyHome}
 */
public abstract interface DataContainerKeyBuilder {
  
  /**
   *Builds the DataContainerKey. After this method has been called it is no longer possible to call withAttributeValue or withReferenceTarget
   * @return DataContainerKey
   */
  public abstract com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKey build();
  
  /**
   *Include the specified attribute vale in the resulting builder
   * Will fail if attribute with attributeID is not found or if the attribute is not valid for the key on DataContainerType.
   * Will fail if attributeValue is null or empty string.
   * Will replace if a value has already been added for attributeID
   * @param attributeID id of attribute
   * @param attributeValue value for attribute in key
   * @return DataContainerKeyBuilder
   */
  public abstract com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKeyBuilder withAttributeValue(java.lang.String attributeID,java.lang.String attributeValue);
  
  /**
   *Include the specified attribute ID in the resulting builder
   * Will fail if attribute with attributeID is not found or if the attribute is not valid for the key on DataContainerType
   * Will fail if attributeValueID is null or empty string or if the id is not found
   * Will replace if an attributeValueID has already been added for attributeID
   * @param attributeID id of attribute
   * @param attributeValueID id of the value
   * @return DataContainerKeyBuilder
   */
  public abstract com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKeyBuilder withAttributeValueID(java.lang.String attributeID,java.lang.String attributeValueID);
  
  /**
   *Include the specified attribute and unit vale in the resulting builder
   * Will fail if attribute with attributeID is not found or if the attribute is not valid for the key on DataContainerType.
   * Will fail if attributeValue is null or empty string.
   * Will replace if a value has already been added for attributeID
   * @param attributeID id of attribute
   * @param attributeValue value for attribute in key
   * @param unitID id of unit to use for value
   * @return DataContainerKeyBuilder
   */
  public abstract com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKeyBuilder withAttributeValueUnit(java.lang.String attributeID,java.lang.String attributeValue,java.lang.String unitID);
  
  /**
   *Include the specified reference target ID in the resulting builder
   * Will fail if reference type with referenceTypeID is not found or if the reference type is not valid for the key on DataContainerType
   * Will fail if targetID is null or empty string, if the target is not found or a targetID has already been added for referenceTypeID
   * @param referenceTypeID id of reference type
   * @param targetID id of reference target
   * @return DataContainerKeyBuilder
   */
  public abstract com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKeyBuilder withReferenceTarget(java.lang.String referenceTypeID,java.lang.String targetID);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainerkey\keyhome\DataContainerKeyHome.java
====================
package com.stibo.core.domain.datacontainerkey.keyhome;

/**
 *Home for acquiring {@link DataContainerKeyBuilder}
 */
public abstract interface DataContainerKeyHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Find the data container objects by using the values for attributes, reference target IDs or specified in the supplied DataContainerKey.
   * If the data container type has a key definition, the attribute values and reference target IDs is used to calculate a key value to use to find
   * a matching data container object. If a ID is given in the keyGetter it takes precedence over the key definition in the data container type: If
   * a data container object is found by ID it is returned. If not, the the key definition is used to find a matching data container object.
   *
   * Notice that using the key may mean that more data container objects are found. This might happen in the case where a key definition has
   * been added to an existing data container type, but the users have not had the time to clean up the data in the data containers yet. Calling code should
   * handle the case appropriately.
   *
   * @param dataContainerNode   Check data containers of the given data container type for this node
   * @param dataContainerTypeID The data container type to check
   * @param dataContainerKey    Holds the values that should be used when matching using the key definition in the data container type
   *
   * @return The data container objects that matches the values in the key or empty set if no match
   */
  public abstract java.util.Set<com.stibo.core.domain.datacontainer.SingleDataContainer> getDataContainerByKey(com.stibo.core.domain.hasdatacontainers.HasDataContainers dataContainerNode,java.lang.String dataContainerTypeID,com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKey dataContainerKey);
  
  /**
   *Returns a DataContainerKeyBuilder for the DataContainer with specified ID
   * Will fail if DataContainerType is not found or has no key definition
   * @param dataContainerTypeID id of DataContainerType
   * @return DataContainerKeyBuilder
   */
  public abstract com.stibo.core.domain.datacontainerkey.keyhome.DataContainerKeyBuilder getDataContainerKeyBuilder(java.lang.String dataContainerTypeID);
  
  /**
   *Check if the key on the object is valid/complete
   * This method will fail if the DataContainerType behind the object doesn't define a key
   *
   * Call this method before using matchingKeys which will fail on incomplete keys
   *
   * @param dataContainerObject dataContainerObject to validate key
   *
   * @return true if all values and and references in the key is present on the object, otherwise false
   */
  public abstract boolean hasValidKey(com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject);
  
  /**
   *Compare two datacontainer objects by keys and return true if they have the same key.
   * This method will fail either object has in invalid/incomplete key or if the DataContainerType behind them doesn't define a key
   *
   * @param dataContainerObject1 dataContainerObject to compare
   * @param dataContainerObject2 dataContainerObject to compare
   *
   * @return true if the two objects has matching keys otherwise false
   */
  public abstract boolean matchingKeys(com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject1,com.stibo.core.domain.datacontainerobject.DataContainerObject dataContainerObject2);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainerobject\DataContainerObject.java
====================
package com.stibo.core.domain.datacontainerobject;

/**
 *The object holding the data of the data container.
 */
public abstract interface DataContainerObject extends com.stibo.core.domain.BaseObject, com.stibo.core.domain.basereferencesource.BaseReferenceSource {
  
  /**
   *Get the map of references that this DataContainer owns
   * @return The map of references for this DataContainer
   */
  public abstract com.stibo.core.domain.ReferenceMap getAllDataContainerReferences();
  
  /**
   *Returns a list of dataContainerReferences in the form of a ReferenceList.
   * @param dataContainerReferenceType the reference type retrieved
   * @return The DataContainerReferences
   */
  public abstract com.stibo.core.domain.ReferenceList getDataContainerReferences(com.stibo.core.domain.ReferenceType dataContainerReferenceType);
  
  /**
   *Get ID of this data container object.
   * @return the ID of this data container object
   */
  public abstract java.lang.String getID();
  
  /**
   *The object holding this data container object.
   *
   * @return Owner object of this data container object
   */
  public abstract com.stibo.core.domain.hasdatacontainers.HasDataContainers getOwnerObject();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainertype\CannotRemoveDataContainerTypeFromLastParentException.java
====================
package com.stibo.core.domain.datacontainertype;

/**
 *Exception is thrown in case of an attempt to remove last type from a group
 */
public class CannotRemoveDataContainerTypeFromLastParentException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainertype\DataContainerType.java
====================
package com.stibo.core.domain.datacontainertype;

/**
 *Interface for data container types.
 */
public abstract interface DataContainerType extends com.stibo.core.domain.baseobjecttype.BaseObjectType, com.stibo.core.domain.DataType {
  
  /**
   *Adds the current data container to the specified group.
   *
   * @param attributeGroup the group to add the current data container to
   * @return true if the current data container was added to the specified group
   */
  public default boolean addAttributeGroup(com.stibo.core.domain.AttributeGroup attributeGroup) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the groups this data container type is linked into.
   * @return The AttributeGroups this type is linked into
   */
  public default java.util.Set<com.stibo.core.domain.AttributeGroup> getAttributeGroups() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Removes the current data container from the specified group.
   * It is not possible to remove last type from a group - will throw exception if this is tried.
   *
   * @param attributeGroup the group to remove the current data container from
   * @return true if the current data container was removed from the specified group
   * @throws CannotRemoveDataContainerTypeFromLastParentException in case of an attempt to remove last type from a group
   */
  public default boolean removeAttributeGroup(com.stibo.core.domain.AttributeGroup attributeGroup) throws com.stibo.core.domain.datacontainertype.CannotRemoveDataContainerTypeFromLastParentException {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainertype\DataContainerTypeHome.java
====================
package com.stibo.core.domain.datacontainertype;

/**
 *Home for Data Container Types
 */
public abstract interface DataContainerTypeHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Get a DataContainerType by id lookup.
   *
   * @param id The ID if the Data Container Type
   *
   * @return The Data Container Type with the ID or null if not found
   */
  public abstract com.stibo.core.domain.datacontainertype.DataContainerType getDataContainerTypeByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainertypelink\DataContainerTypeLink.java
====================
package com.stibo.core.domain.datacontainertypelink;

/**
 *A hierarchy-restricted datacontainertype can be made valid for a Product either by making an DataContainerTypeLink between the Product itself
 * (or one of its parents) to the datacontainertype or by making an an DataContainerTypeLink to a Classification (or one of its parents)
 * where the product and classification is further associated via a ClassificationProductLink
 */
public abstract interface DataContainerTypeLink extends com.stibo.core.domain.BaseObject {
  
  /**
   *Delete this DataContainerTypeLink. Note: Deleting an datacontainertype link might give rise to the side-effect that values
   * exist on products that are not valid any longer. Such containers are denoted as being orphan.
   * @see Value#isOrphan()
   */
  public abstract void delete();
  
  /**
   *Retrieve the DataContainerType of this DataContainerTypeLink
   * @return The DataContainerType of this DataContainerTypeLink, should never be null.
   */
  public abstract com.stibo.core.domain.datacontainertype.DataContainerType getDataContainerType();
  
  /**
   *Retrieve the Node (Product or Classification) of this DataContainerTypeLink
   * @return The Node (a Product or Classification) of this DataContainerTypeLink, should never be <code>null</code>
   */
  public abstract com.stibo.core.domain.datacontainertypelink.DataContainerTypeLinkable getNode();
  
  /**
   *Investigate whether this DataContainerTypeLink is mandatory. If the datacontainertype link is mandatory all "child products" of
   * the Node of this DataContainerTypeLink must have a value for the DataContainerType of this link. If the Node is a classification,
   * "child products" includes all products that are linked into the classification
   * or one children of the classification.
   * @return <code>true</code> is this DataContainerTypeLink is mandatory, <code>false</code> otherwise.
   */
  public abstract boolean isMandatory();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datacontainertypelink\DataContainerTypeLinkable.java
====================
package com.stibo.core.domain.datacontainertypelink;

/**
 *Features for objects that have datacontainertypelinks
 */
public abstract interface DataContainerTypeLinkable {
  
  /**
   *Validate a data container type for this revisable tree node.
   * .
   * @param dataContainerType The datacontainertype to validate
   * @return the link created
   * @throws UniqueConstraintException if the datacontainertype already is validated for this node
   */
  public abstract com.stibo.core.domain.datacontainertypelink.DataContainerTypeLink createDataContainerTypeLink(com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType) throws com.stibo.core.domain.UniqueConstraintException;
  
  /**
   *Gets the local data container type link pointing to the specified dct.
   *
   * @param dataContainerType The attribute for which to retrieve the link.
   * @return The attribute link or null if no local link exists to the specified dct.
   */
  public abstract com.stibo.core.domain.datacontainertypelink.DataContainerTypeLink getDataContainerTypeLink(com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
  /**
   *Returns the datacontainertype links that are legal for this tree node.
   *
   * @return The valid datacontainertype or the empty set if none applies.
   */
  public abstract java.util.Set<com.stibo.core.domain.datacontainertypelink.DataContainerTypeLink> getDataContainerTypeLinks();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datanode\DataNode.java
====================
package com.stibo.core.domain.datanode;

/**
 *A data-node, the common supertype for data-bearing nodes,
 * such as Products, Classifications, Entities and Assets.
 */
public abstract interface DataNode extends com.stibo.core.domain.Node, com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.ReferenceTarget, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.ReferenceSource {
  
  /**
   *The general delete method for data nodes.<p>
   *
   * A deletion of a node includes all data owned by the node in question including local values
   * and local outgoing references and links. <p>
   * A deletion of a revised node is not a physical deletion of the object from the database, but merely an indication
   * that the object is deleted but still accessible in earlier revisions (in the recycle bin). A deletion of an unrevised
   * node is a physical deletion of the object from the database. <p>
   * Notice that you should not subsequently call methods on nodes for which delete() has been called. If you
   * e.g. want to approve the deletion of a revisable node, this should be done one the object returned by delete();
   *
   * @return the node from recycle bin (only for revisable nodes) or null if node is completely deleted.
   * @throws DependencyException Indicates whether the node has dependencies so that is could not be deleted
   */
  public abstract com.stibo.core.domain.datanode.DataNode delete() throws com.stibo.core.domain.DependencyException;
  
  /**
   *This method was implemented because delete is a reserved keyword in JavaScript.
   * This method will just delegate call to delete().
   * @see  #delete()
   * @return the node from recycle bin (only for revisable nodes) or null if node is completely deleted.
   * @throws DependencyException Indicates whether the node has dependencies so that is could not be deleted
   *
   * @deprecated Use delete method instead. From ECMAScript 5 specification it is allowed to use
   * reserved keyword in identifier names.
   */
  public abstract com.stibo.core.domain.datanode.DataNode deleteJS() throws com.stibo.core.domain.DependencyException;
  
  /**
   *Force deletes the specified node.
   * The node will be prevented from being deleted if the node has dependencies, such as child nodes or references from other nodes.
   * However, instances in workflows or events in EventQueues will not prevent the deletion.
   * Upon deletion, any such instances or events will also be removed. Also note that deleting a node this way does not generate an event.
   * @throws DependencyException Indicates whether the node has dependencies in which case it will not be deleted. The user may get a message about in which context or workspace a blocking dependency may exist.
   */
  public abstract void forceDelete() throws com.stibo.core.domain.DependencyException;
  
  /**
   *Set the ObjectType of a node. Was known as UserType in earlier
   * versions.
   *
   * @param objectType - the ObjectType we want the node to have
   * @throws com.stibo.core.domain.ObjectTypeConstraintException if the change to the new object type is not possible
   */
  public abstract void setObjectType(com.stibo.core.domain.ObjectType objectType) throws com.stibo.core.domain.ObjectTypeConstraintException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\dataprofile\DataProfileHome.java
====================
package com.stibo.core.domain.dataprofile;

/**
 *Home interface for data profiling.
 */
public abstract interface DataProfileHome {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\dataquality\CompletenessInfo.java
====================
package com.stibo.core.domain.dataquality;

/**
 *Deprecated: use new completeness metrics instead.
 * A CompletenessInfo instance is supposed to hold info on the completeness score of a node.
 */
@java.lang.Deprecated()
public class CompletenessInfo {
  
  /**
   *Deprecated: use new completeness metrics instead.
   * Returns the completeness score of the node - a percentage that indicates how complete the node is
   * @return completeness score of a node as a percentage of the actual score related to the max score,
   * 0 if the max score is 0.
   */
  public int getCompletenessScore() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\dataquality\DataQualityHome.java
====================
package com.stibo.core.domain.dataquality;

/**
 *Deprecated: use new completeness metrics instead.
 * An interface for get access to completeness info of nodes.
 * @deprecated Use new completeness metrics instead.
 * @see com.stibo.completenessscore.domain.CompletenessMetric
 */
@java.lang.Deprecated()
public abstract interface DataQualityHome {
  
  /**
   *Deprecated: use new completeness metrics instead.
   * Compute the completeness data for the node passed as argument.
   * @param node target Node to compute completeness for.
   * @return completeness info or <code>null</code> if no completeness could be computed for node
   */
  public abstract com.stibo.core.domain.dataquality.CompletenessInfo getCompletenessInfo(com.stibo.core.domain.Node node);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\datatreenode\DataTreeNode.java
====================
package com.stibo.core.domain.datatreenode;

/**
 *A node with one parent and multiple children.
 */
public abstract interface DataTreeNode<T extends com.stibo.core.domain.datatreenode.DataTreeNode<T>> extends com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.TreeNode<T> {
  
  /**
   *Returns the direct children of this node in arbitrary order.
   * <p>
   * Note that when calling {@link com.stibo.core.domain.query.Query#asList(int)} on the returned query, the result
   * will be limited to 100 regardless of the provided parameter.
   * @return a {@link com.stibo.core.domain.query.Query} containing direct children of this node.
   */
  public abstract com.stibo.core.domain.query.Query<? extends T> queryChildren();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\entity\Entity.java
====================
package com.stibo.core.domain.entity;

/**
 *A Node representing an Entity in STEP.
 * An Entity represents data which are not Products, like contacts, addresses, markets or customers.
 */
public abstract interface Entity extends com.stibo.core.domain.Node, com.stibo.core.domain.hasdatacontainers.HasDataContainers, com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.terms.HasTerms, com.stibo.core.domain.RevisableNode, com.stibo.core.domain.ReferenceTarget, com.stibo.core.domain.WorkflowableNode, com.stibo.core.domain.ReferenceSource, com.stibo.core.domain.datanode.DataNode, com.stibo.core.domain.datatreenode.DataTreeNode<com.stibo.core.domain.entity.Entity> {
  
  /**
   *Creates a new entity with the specified ID and object type as a child to the entity
   * for which the method is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter.<br/>
   * If an entity with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new entity. Can be null or the empty string if auto IDs are configured
   * @param objectType The object type of the new entity
   * @return The newly created entity
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted entity
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.entity.Entity createEntity(java.lang.String id,com.stibo.core.domain.ObjectType objectType) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Creates a new entity with the specified ID and object type as a child to the entity
   * for which the method is invoked. <p>
   *
   * If auto IDs are configured for the object type, null or the empty string can be supplied for the "id" parameter.<br/>
   * If an entity with the provided (or auto generated) ID already exists in the recycle bin, it will be revived
   * and a new revision without any data created.
   *
   * @param id The ID of the new entity. Can be null or the empty string if auto IDs are configured
   * @param objectTypeID The ID of the object type of the new entity
   * @return The newly created entity
   * @throws NodeIdUniqueConstraintException if the ID is already in use by a non-deleted entity
   * @throws ObjectTypeConstraintException if the object type is not valid under this node
   */
  public abstract com.stibo.core.domain.entity.Entity createEntity(java.lang.String id,java.lang.String objectTypeID) throws com.stibo.core.domain.NodeIdUniqueConstraintException,com.stibo.core.domain.ObjectTypeConstraintException;
  
  /**
   *Get the List of children for this Entity.
   * Notice that the List is filtered for contexts and view privileges.
   * @return A list of children or the empty list if none exists.
   */
  public abstract java.util.List<com.stibo.core.domain.entity.Entity> getChildren();
  
  /**
   *Get the parent object of this Entity.
   * @return The Parent of this Entity or null, if none exists.
   */
  public abstract com.stibo.core.domain.entity.Entity getParent();
  
  /**
   *Returns the children of this node.
   * This does not recursively return all the children only one generation down is considered.
   * Note that calling asList on this query will be limited to 100 results regardless of limit set as parameter.
   * @return Children related to this node.
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.entity.Entity> queryChildren();
  
  /**
   *Sets the parent of this Entity to the Entity given as argument.
   * @param parent The new parent of this Entity.
   * @throws ObjectTypeConstraintException if the objecttype of this entity is not allowed under the new parent.
   * @throws CycleConstraintException if attempting to move the entity itself either directly or indirectly.
   * @throws UnsupportedOperationException Thrown if called on root entity in entity hierarchy.
   * @throws IllegalArgumentException Thrown if parent argument is <code>null</code>.
   */
  public abstract void setParent(com.stibo.core.domain.entity.Entity parent) throws com.stibo.core.domain.ObjectTypeConstraintException,com.stibo.core.domain.CycleConstraintException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\entity\EntityHome.java
====================
package com.stibo.core.domain.entity;

public abstract interface EntityHome extends com.stibo.core.domain.NodeHome {
  
  /**
   *Return an Entity object relating to the identifier supplied.
   * @param id The identifier of the domain object.
   * @return The Entity object with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.entity.Entity getEntityByID(java.lang.String id);
  
  /**
   *Get the root entity in the Entity hierarchy.
   *
   * @return the root entity in the Entity hierarchy.
   */
  public abstract com.stibo.core.domain.entity.Entity getTopEntity();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventprocessor\batch\EventBatch.java
====================
package com.stibo.core.domain.eventprocessor.batch;

/**
 *The unit of work for an eventprocessor plugin.
 * This batched set of events will match the configured event size.
 * If not set it will default to 1000.
 *
 * Depending on the amount of events on a event queue when excuting an
 * event processor it will receive a number of event batches.
 *
 * For example if batchsize is 1000 and the queue has 12540 events when
 * executing the event processor it will receive 13 event batches each
 * containing up to 1000 events.
 */
public abstract interface EventBatch {
  
  /**
   *Return a read-only list of the events in the event-batch.
   * 
   * @return Returns a read-only list of events in the event batch
   */
  public abstract java.lang.Iterable<com.stibo.core.domain.eventqueue.event.Event> getEvents();
  
  /**
   *Returns the number of events in the eventbatch.
   * @return The size of the batch
   */
  public abstract int size();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventprocessor\exception\EventProcessorInterruptedException.java
====================
package com.stibo.core.domain.eventprocessor.exception;

/**
 *Exception thrown when we want to interrupt event processor execution. It results in BGP status set to failed.
 */
public class EventProcessorInterruptedException extends java.lang.RuntimeException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventqueue\BasicEventType.java
====================
package com.stibo.core.domain.eventqueue;

/**
 *Basic non-derived event types.
 */
public enum BasicEventType implements com.stibo.core.domain.eventqueue.SimpleEventType {
  
  /**
   *Create event.
   */
  Create, 
  /**
   *Modify event.
   */
  Modify, 
  /**
   *Delete event.
   */
  Delete;
  public java.lang.String getID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Do the values on this enum contain an eventtype of the name passed.
   * @param s The name of the event type to check for.
   * @return True if the eventtype name s is contained in this enum.
   */
  public static boolean contains(java.lang.String s) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventqueue\DerivedEventType.java
====================
package com.stibo.core.domain.eventqueue;

public abstract interface DerivedEventType extends com.stibo.core.domain.eventqueue.SimpleEventType {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventqueue\EventQueue.java
====================
package com.stibo.core.domain.eventqueue;

/**
 *Event Queue object
 */
public abstract interface EventQueue extends com.stibo.core.domain.Node, com.stibo.core.domain.RevisableNode {
  
  /**
   *Will queue a event into this event-queue.
   * @param event type of event to add to queue.
   * @param node node of event to add to queue.
   */
  public abstract void queueDerivedEvent(com.stibo.core.domain.eventqueue.DerivedEventType event,com.stibo.core.domain.Node node);
  
  /**
   *Republishes a specific node to this event queue. I.e. generates events, as if the node had been
   * changed and approved.
   * @param nodeToRepublish The node to republish.
   */
  public abstract void republish(com.stibo.core.domain.RevisableNode nodeToRepublish);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventqueue\SimpleEventType.java
====================
package com.stibo.core.domain.eventqueue;

/**
 *Common interface for basic, non-derived event types and derived event types.
 */
public abstract interface SimpleEventType {
  
  /**
   *Returns the id of this event type.
   * @return id of this event type.
   */
  public abstract java.lang.String getID();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventqueue\event\Event.java
====================
package com.stibo.core.domain.eventqueue.event;

/**
 *Event object from an event queue.
 */
public abstract interface Event {
  
  /**
   *Returns the event type of this event.
   * @return The event type of this event, this can be either a base event type or a derived event type.
   */
  public abstract com.stibo.core.domain.eventqueue.SimpleEventType getEventType();
  
  /**
   *Returns the node associated with this event.
   * The node is returned in the context that the eventprocessor is executing for.
   * @return Node on event.
   */
  public abstract com.stibo.core.domain.Node getNode();
  
  /**
   *Return which workspace(s) the event was triggered from.
   * @return The workspace triggering
   */
  public abstract com.stibo.core.domain.eventqueue.triggeringworkspace.TriggeringWorkspace getTriggeringWorkspace();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\eventqueue\triggeringworkspace\TriggeringWorkspace.java
====================
package com.stibo.core.domain.eventqueue.triggeringworkspace;

/**
 *Used for specifying on an event queue which workspace to trigger on and used on an event to identify which workspace the event in question originates from.
 */
public enum TriggeringWorkspace {
  
  /**
   *Triggering on changes from Main workspace
   */
  Main, 
  /**
   *Triggering on changes from Approved workspace
   */
  Approved, 
  /**
   *Triggering on changes from both Main and Approved workspace
   */
  MainAndApproved;
  /**
   *Is triggered from main workspace
   * @return true if triggering from main workspace
   */
  public boolean isMainTriggering() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Is triggered from approved workspace
   * @return true if triggering from approved workspace
   */
  public boolean isApprovedTriggering() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\hasdatacontainers\HasDataContainers.java
====================
package com.stibo.core.domain.hasdatacontainers;

/**
 *Provide the capability of having data containers
 */
public abstract interface HasDataContainers extends com.stibo.core.domain.Node {
  
  /**
   *Get data container of given type.
   * @param dataContainerType the type to get data container of
   * @return the data container
   */
  public abstract com.stibo.core.domain.datacontainer.DataContainer getDataContainer(com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType);
  
  /**
   *Get data container of given type.
   * @param dataContainerTypeID the type to get data container of, use the type id
   * @return the data container corresponding to this ID
   */
  public abstract com.stibo.core.domain.datacontainer.DataContainer getDataContainerByTypeID(java.lang.String dataContainerTypeID);
  
  /**
   *Get all valid data containers - even if no data container objects exists for given data container type.
   * @return all data containers.
   */
  public abstract java.util.Collection<com.stibo.core.domain.datacontainer.DataContainer> getDataContainers();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\home\Home.java
====================
package com.stibo.core.domain.home;

/**
 *All component Home interfaces should extend from this interface, allowing clients to use Manager.getHome(MyHome.class);
 */
public abstract interface Home {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\importer\ImportValidationException.java
====================
package com.stibo.core.domain.importer;

/**
 *Super exception for all exceptions thrown due to validation errors during import.
 */
public class ImportValidationException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\importer\changeinfo\AttributeValueChange.java
====================
package com.stibo.core.domain.importer.changeinfo;

/**
 *Object representing a change of an attribut in a single qualifier.
 * Returned by com.stibo.core.domain.importer.changeinfo.ImportChangeInfo.Changes#getAttributeValueChanges().
 */
public abstract interface AttributeValueChange {
  
  /**
   *Returns the attribute whose value has been changed.
   * @return changed attribute
   */
  public abstract com.stibo.core.domain.Attribute getAttribute();
  
  /**
   *Returns a set of dimension points contained in a qualifier in which the attribute value has been changed.
   * @return a set of dimension points contained in a qualifier in which the attribute value has been changed
   */
  public abstract java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\importer\changeinfo\ImportChangeInfo.java
====================
package com.stibo.core.domain.importer.changeinfo;

/**
 *Class containing information about what has changed for a {@link com.stibo.core.domain.Node} after an import has been performed in STEP.
 */
public abstract interface ImportChangeInfo {
  
  /**
   *Returns an object containing specific information about what has changed for a {@link com.stibo.core.domain.Node}.
   *
   * @return a {@link Changes} object.
   */
  public abstract com.stibo.core.domain.importer.changeinfo.ImportChangeInfo.Changes getChanges();
  
  /**
   *Tells whether or not all data for the object has been handled when the ImportChangeInfo object is instantiated.
   * The handling of links will in some cases be deferred until all objects have been processed.
   *
   * @return true if all data has been handled, false if not
   */
  public abstract boolean isAllDataHandled();
  
  /**
   *@return <code>true</code> if the {@link com.stibo.core.domain.Node} was created by the current import process.<br/>
   * <code>false</code> if the {@link com.stibo.core.domain.Node} did already exist before the current process was started.
   */
  public abstract boolean isCreatedByCurrentProcess();
  
  /**
   *This method returns:<br/>
   * <code>true</code> if no existing {@link com.stibo.core.domain.Node} was changed and no new {@link com.stibo.core.domain.Node} was added.<br/>
   * <code>false</code> if existing {@link com.stibo.core.domain.Node} <u>may</u> have changed or new {@link com.stibo.core.domain.Node} was added.
   * <p/>
   * Notice that if the handling of any links is deferred, this method will return false regardless of whether the object in the end will be modified or not.
   *
   * @return <code>true</code> if no existing {@link com.stibo.core.domain.Node} was changed and no new {@link com.stibo.core.domain.Node} was added.<br/><br/>
   * <code>false</code> if existing {@link com.stibo.core.domain.Node} <u>may</u> have changed or new {@link com.stibo.core.domain.Node} was added.
   */
  public abstract boolean isUnmodified();
  
  /**
   *This class contains specific information about the changed attributes of a {@link com.stibo.core.domain.Node}.
   */
  public abstract static interface Changes {
    
    /**
     *Returns a Map where the String keys are IDs of attributes modified during the import and values are a Set of AttributeValueChange
     * objects representing changes in different qualifiers. For non-cross context imports, the value Set will always only hold a single entry.
     *
     * @return a Map holding detailed information about attribute value changes
     */
    public abstract java.util.Map<java.lang.String,java.util.Set<com.stibo.core.domain.importer.changeinfo.AttributeValueChange>> getAttributeValueChanges();
    
    /**
     *Returns a {@link List} of attribute Ids of changed, added or deleted attribute values.
     *
     * @return a {@link List} list of attribute Ids.
     */
    public abstract java.util.List<java.lang.String> getAttributes();
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\integration\faulttolerance\FailAndRetryException.java
====================
package com.stibo.core.domain.integration.faulttolerance;

/**
 *Exception thrown when we don't want to interrupt event processor execution.
 * It results in BGP status set to 'Failed (retrying)' state and the event processing will start retrying.
 */
public class FailAndRetryException extends java.lang.RuntimeException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\integrationendpoint\OutboundIntegrationEndpoint.java
====================
package com.stibo.core.domain.integrationendpoint;

/**
 *An outbound integration endpoint exports data from STEP to external systems/users
 */
public abstract interface OutboundIntegrationEndpoint extends com.stibo.core.domain.Node, com.stibo.core.domain.RevisableNode {
  
  /**
   *Return the context IDs the integration endpoint is using during import or export.
   *
   * @return The context IDs used during import or export.
   */
  public abstract java.util.List<java.lang.String> getContextIDs();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\integrationendpoint\streaming\domain\StreamingMessage.java
====================
package com.stibo.core.domain.integrationendpoint.streaming.domain;

/**
 *Represents a message received from a streaming source.
 */
public abstract interface StreamingMessage {
  
  /**
   *Received message.
   *
   * @return Received message.
   */
  public abstract byte[] content();
  
  /**
   *Message metadata.
   *
   * @return Message metadata.
   */
  public abstract com.stibo.core.domain.integrationendpoint.streaming.domain.StreamingMessageMetadata metadata();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\integrationendpoint\streaming\domain\StreamingMessageMetadata.java
====================
package com.stibo.core.domain.integrationendpoint.streaming.domain;

/**
 *Represents metadata of a message received from a streaming source.
 */
public abstract interface StreamingMessageMetadata {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\integrationendpoint\streaming\logger\StreamingExecutionReportLogger.java
====================
package com.stibo.core.domain.integrationendpoint.streaming.logger;

/**
 *Provides access to the background process logging framework
 */
public abstract interface StreamingExecutionReportLogger {
  
  /**
   *Log an error level message
   *
   * @param message the message as a String. Object parameter to allow for localization in the future.
   */
  public abstract void logError(java.lang.Object message);
  
  /**
   *Log an info level message
   *
   * @param message the message as a String. Object parameter to allow for localization in the future.
   */
  public abstract void logInfo(java.lang.Object message);
  
  /**
   *Log a warning level message
   *
   * @param message the message as a String. Object parameter to allow for localization in the future.
   */
  public abstract void logWarning(java.lang.Object message);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\key\KeyHome.java
====================
package com.stibo.core.domain.key;

/**
 *Home of unique keys.
 */
public abstract interface KeyHome {
  
  /**
   *Update attribute values participating in unique-keys on an object. 
   * The affected unique-keys will be updated as well.
   * @param attributeValueMap a map from attribute IDs to values
   * @param node the object
   */
  public abstract void updateUniqueKeyValues2(java.util.Map<java.lang.String,java.lang.String> attributeValueMap,com.stibo.core.domain.datanode.DataNode node);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\key\UniqueKeyViolationException.java
====================
package com.stibo.core.domain.key;

/**
 *Exception thrown when a unique key constraint is violated by the client.
 */
public class UniqueKeyViolationException extends java.lang.RuntimeException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\license\TooManyUsersException.java
====================
package com.stibo.core.domain.license;

/**
 *Exception thrown when trying to create a new user and the limit on named users in the license has been exceeded.
 */
public class TooManyUsersException extends java.lang.RuntimeException {
  
  /**
   *Accessor for the current number of users
   * @return current number of users.
   */
  public int getCurrentUsers() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\listofvalues\lovfilter\IllegalLOVFilterException.java
====================
package com.stibo.core.domain.listofvalues.lovfilter;

/**
 *Exception is thrown when list of values filter cannot be added of modified,
 *   e.g. when trying to add value filter on attribute-link and it is not subset of filter on the attribute,
 *   or when hierarchical filters are not allowed for attribute.
 */
public abstract class IllegalLOVFilterException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\multivalue\LOVMultiValueBuilder.java
====================
package com.stibo.core.domain.multivalue;

/**
 *<p>Builder using which multiple values for LOV validated attributes can be set in a single action.</p>
 * <p>The apply() method, which saves all the changes, will completely replace the content of the LOVMultiValue
 * with new values also removing old values not added to the builder.</p>
 * <p>If the builder was obtained by calling LOVMultiValue.append() the apply() method, will instead
 * append the values to the existing values in the LOVMultiValue</p>
 * <p>Example:</p>
 * <pre>{@code
 * product.getValue("TestLOVMultiValueAttribute").replace().addLOVValueByID("LOVID1").addLOVValueByID("LOVID2").apply();
 * }</pre>
 */
public abstract interface LOVMultiValueBuilder extends com.stibo.core.domain.multivalue.MultiValueBuilder {
  
  /**
   *<p>Adds a value to the temporary list of values.</p>
   * <p>The temporary list can be persisted by calling the builder apply() method.</p>
   * @param value The value to add.
   * @return LOVMultiValueBuilder instance holding added values
   */
  public abstract com.stibo.core.domain.multivalue.LOVMultiValueBuilder addLOVValue(com.stibo.core.domain.ListOfValuesValue value);
  
  /**
   *<p>Adds a value identified by value ID to the temporary list of values.</p>
   * <p>The temporary list can be persisted by calling the builder apply() method.</p>
   * @param id The id of value to add.
   * @return LOVMultiValueBuilder instance holding added values
   */
  public abstract com.stibo.core.domain.multivalue.LOVMultiValueBuilder addLOVValueByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\multivalue\MultiValueBuilder.java
====================
package com.stibo.core.domain.multivalue;

/**
 *<p>Builder using which multiple values can be set in a single action.</p>
 * <p>If the builder was obtained by calling MultiValue.replace() the apply() method,
 * which saves all the changes, will completely replace the content of the MultiValue
 * with new values also removing old values not added to the builder.</p>
 * <p>If the builder was obtained by calling MultiValue.append() the apply() method, will instead
 * append the values to the existing values in the MultiValue</p>
 * <p>The builder can be used to set values for non-LOV based multivalued attributes.</p>
 * <p>Example:</p>
 * <pre>{@code
 * product.getValue("TestMultiValueAttribute").replace().addValue("Value1").addValue("Value2").apply();
 * }</pre>
 */
public abstract interface MultiValueBuilder {
  
  /**
   *<p>Adds a simple value to the temporary list of values</p>
   * <p>The temporary list can be persisted by calling the builder apply() method.</p>
   * <p>Noticeable about the simple value format is that you can add values with units entering value
   * and unit name as a string and further that the simple value string can contain multiple
   * "&lt;multisep/&gt;" values to add.</p>
   * <p>Example usage:</p>
   * <p>builder.addSimpleValue("14 cm").addSimpleValue("15 cm&lt;multisep/&gt;18 cm").apply();</p>
   * @param value value to be added
   * @return MultiValueBuilder instance holding added values
   */
  public abstract com.stibo.core.domain.multivalue.MultiValueBuilder addSimpleValue(java.lang.String value);
  
  /**
   *<p>Adds a value without unit to the temporary list of values.</p>
   * <p>The temporary list can be persisted by calling the builder apply() method.</p>
   * @param value The value to add.
   * @return MultiValueBuilder instance holding added values
   */
  public abstract com.stibo.core.domain.multivalue.MultiValueBuilder addValue(java.lang.String value);
  
  /**
   *<p>Adds a value with unit to the temporary list of values.</p>
   * <p>The temporary list can be persisted by calling the builder apply() method.</p>
   * @param value The value to add.
   * @param unit The unit of value.
   * @return MultiValueBuilder instance holding added values
   */
  public abstract com.stibo.core.domain.multivalue.MultiValueBuilder addValue(java.lang.String value,com.stibo.core.domain.Unit unit);
  
  /**
   *<p>Applies all values held in builder in a single action overwriting any existing value.</p>
   * <p>The value is left unchanged if just one of the values cannot be set.
   * If no values have been added to the builder, any existing value will be deleted.</p>
   * @throws ValidatorException if validation of values set fails
   */
  public abstract void apply() throws com.stibo.core.domain.ValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\AssetClassificationLinkPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Part object for indicating approval of a "parent" link from an asset to a classifications.
 */
public class AssetClassificationLinkPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the identifier of the classification
   * @return id of classification.
   */
  public java.lang.String getClassificationID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\AssetContentPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Part object for indicating approval of asset content include the blob itself and associated auto generated metadata
 * but excluding any metadata manually attached via the object type definition of the asset.
 */
public class AssetContentPartObject extends com.stibo.core.domain.partobject.PartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\AssetReferencePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Part object for indicating approval of a reference to an asset including metadata (if any) associated with that reference.
 */
public class AssetReferencePartObject extends com.stibo.core.domain.partobject.ReferencePartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\AttributeLinkPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object used of indicating the approval of an attribute link
 */
public class AttributeLinkPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the attribute identifier defining the attribute of the attribute link
   * @return the identifier of the attribute
   */
  public java.lang.String getAttributeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ClassificationLinkPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object used for indicating approval of the link between a product and a classification including metadata (if any) associated with that link.
 * Only makes sense for links owned by the product.
 */
public class ClassificationLinkPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the identifier of the classification being the target of the link
   * @return identifier of classification.
   */
  public java.lang.String getClassificationID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns the ID of the link type used for the product to classification link.
   * @return ID of the ClassificationProductLinkType.
   */
  public java.lang.String getLinkTypeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ClassificationReferencePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Part object for indicating approval of a reference to a classification including metadata (if any) associated with that reference.
 */
public class ClassificationReferencePartObject extends com.stibo.core.domain.partobject.ReferencePartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ContextReferencePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Part object for indicating approval 0f a reference from an entity to a context including metadata (if any) associated with that reference..
 */
public class ContextReferencePartObject extends com.stibo.core.domain.partobject.ReferencePartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\DefaultInDesignTemplatePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of the default InDesign template of a node.
 */
public class DefaultInDesignTemplatePartObject extends com.stibo.core.domain.partobject.PartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\DefaultQuarkTemplatePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Part object for approving the default Quark template of a node.
 * @deprecated Quark no longer supported in STEP
 */
@java.lang.Deprecated()
public class DefaultQuarkTemplatePartObject extends com.stibo.core.domain.partobject.PartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\EntityReferencePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of a reference to an entity including metadata (if any) associated with that reference.
 */
public class EntityReferencePartObject extends com.stibo.core.domain.partobject.ReferencePartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\NamePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of the context specific name of a revisable node
 */
public class NamePartObject extends com.stibo.core.domain.partobject.PartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\OverrideProductLinkPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of the relation between a product override and the overridden product.
 */
public class OverrideProductLinkPartObject extends com.stibo.core.domain.partobject.PartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ParentPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of the relation between a product, classification, or
 * workspace revisable entity and its parent.
 */
public class ParentPartObject extends com.stibo.core.domain.partobject.PartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\PartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Objects derived from this class can be used to indicate what should be
 * approved (synchronized/merged) for a given revisable node
 * and can be used both server and client side.
 */
public abstract class PartObject implements java.lang.Cloneable {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Return the set of dimension points being targeted by approved/synchronized/merged functionality
   * @return set of dimension points
   */
  public java.util.Set<com.stibo.core.domain.DimensionPoint> getDimensionPoints() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ProductLinkPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object used for indicating approval of a link between a classification and a product including metadata (if any) associated with that link.
 * Only makes sense for links owned by the classification.
 */
public class ProductLinkPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Gets the ID of the ClassificationProductLinkType of the represented link.
   * @return The ID of the link type.
   */
  public java.lang.String getLinkTypeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *The ID of the product.
   * @return the id of the product.
   */
  public java.lang.String getProductID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ProductOverrideChildPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of the link between a product and one of its product override children.
 * (Note that a product "owns" its  product override children links)
 */
public class ProductOverrideChildPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns the ID of the product override child product.
   * @return ID of product override child product.
   */
  public java.lang.String getProductOverrideChildID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ProductReferencePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of a reference to a product including metadata (if any) associated with that reference.
 */
public class ProductReferencePartObject extends com.stibo.core.domain.partobject.ReferencePartObject {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ReferencePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Abstract Part object for indicating approval of a reference including metadata (if any) associated with that reference
 */
public abstract class ReferencePartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the type of the reference being the subject of this part object
   * @return the reference type
   */
  public java.lang.String getReferenceType() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the identifier of the node being referenced
   * @return the identifier of the node being referenced
   */
  public java.lang.String getTargetID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\TablePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of a PIM table.
 */
public class TablePartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *The table type to approve/sync.
   * @return table type ID.
   */
  public java.lang.String getTableTypeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\TableTextsPartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of a the content of a free text cell of a PIM table.
 */
public class TableTextsPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns the TableTextsAttributeID.
   * @return The TableTextsAttributeID.
   */
  public java.lang.String getTableTextsAttributeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns the ID of this tabletype.
   * @return ID of this table type.
   */
  public java.lang.String getTableTypeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\ValuePartObject.java
====================
package com.stibo.core.domain.partobject;

/**
 *Object for indicating approval of a value (single or multi) on a workspace revisable node. The value is identified
 * by the identifier of an attribute.
 */
public class ValuePartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the attribute ID of this value.
   * @return The attribute ID of this value.
   */
  public java.lang.String getAttributeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\datacontainer\DataContainerPartObject.java
====================
package com.stibo.core.domain.partobject.datacontainer;

/**
 *Object used of indicating the approval of a data container
 */
public class DataContainerPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *Get current data container type id
   * @return the identifier of data container type
   */
  public java.lang.String getDataContainerTypeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\partobject\datacontainertypelink\DataContainerTypeLinkPartObject.java
====================
package com.stibo.core.domain.partobject.datacontainertypelink;

/**
 *Object used of indicating the approval of an datacontainertype link
 */
public class DataContainerTypeLinkPartObject extends com.stibo.core.domain.partobject.PartObject {
  
  /**
   *{@inheritDoc}
   */
  public boolean equals(java.lang.Object obj) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the datacontainertype identifier defining the datacontainertype of the datacontainertype link
   * @return the identifier of the datacontainertype
   */
  public java.lang.String getDataContainerTypeID() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *{@inheritDoc}
   */
  public int hashCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\query\Query.java
====================
package com.stibo.core.domain.query;

/**
 *A representation of a query, invoke methods on it to get the result of the query.
 * @param <T> the type of objects returned from the query.
 */
public abstract interface Query<T extends java.lang.Object> {
  
  /**
   *Get the result of the query as a list, limited by the limit argument.
   *
   * While convenient, it can take up huge amounts of memory, and spend time processing
   * before the results can be inspected, so for that reason it is recommended to iterate using forEach, or stream the
   * information.
   * <p/>
   * Invoking this several times is allowed, however, it is unspecified if the result is the same or different every time. The query is thus free to remember that it was invoked before and return the same result even if changes has been made in the meantime. Also, it can choose to redo the query. It is generally advisable to only call this once.
   * If a new query is to be run, a new Query object should be obtained from the "query" method.
   * <p/>
   * Using forEach should generally be preferred over calling asList, as forEach streams the result rather than collecting it into a list consuming memory on-heap.
   *
   * @param limit number of elements to include. Notice that methods returning a Query can impose restrictions on the maximum value. Refer to the Javadoc for these methods for more information.
   *              If not specialized, this method is limited by STEPs default query-restriction, currently 500.
   * @return the list of results from the query. This may be an immutable list.
   */
  public default java.util.List<T> asList(int limit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Invoke the {@code QueryConsumer} for each element of the {@code Query} until all elements have been consumed,
   * the consumer throws an exception or the consumer stops the consumption by returning <code>false</code>.
   * <p>
   * Be aware that a Query potentially can hold millions of elements.
   * Never have the QueryConsumer add elements to a collection without keeping track of how many elements have been
   * added.
   * Failure to follow this rule can lead to out of memory exceptions or more generally, severe performance
   * degradation.
   * <p>
   * Java example:
   * <pre>
   * Query<? extends Node> query = getNodeQuery();
   * query.forEach(new QueryConsumer<Node>() {
   *
   *     public boolean consume(Node node) {
   *         //handle node here
   *         return true;
   *     }
   * });
   * </pre>
   * <p>
   * JavaScript example:
   * <pre>
   * var query = getNodeQuery();
   * query.forEach(function(node) {
   *     //handle node here
   *     return true;
   * });
   * </pre>
   *
   * @param consumer  the {@code QueryConsumer} to invoke for each element of the query
   * @throws NullPointerException if the specified consumer is null
   */
  public abstract void forEach(com.stibo.core.domain.query.QueryConsumer<? super T> consumer);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\query\QueryConsumer.java
====================
package com.stibo.core.domain.query;

/**
 *Consumes results from executing a Query.
 * @param <T> the type of objects returned from the query.
 */
public abstract interface QueryConsumer<T extends java.lang.Object> {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\setupentity\SetupEntity.java
====================
package com.stibo.core.domain.setupentity;

/**
 *A Node representing an Setup Entity in STEP.
 * An Setup Entity represents a generic system setup node.
 */
public abstract interface SetupEntity extends com.stibo.core.domain.Node, com.stibo.core.domain.ObjectTypeable, com.stibo.core.domain.terms.HasTerms, com.stibo.core.domain.RevisableNode {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\setupentity\SetupEntityHome.java
====================
package com.stibo.core.domain.setupentity;

public abstract interface SetupEntityHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Return a SetupEntity object relating to the identifier supplied.
   * @param id The identifier of the domain object.
   * @return The SetupEntity object with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.setupentity.SetupEntity getSetupEntityByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\singleattributequery\SingleAttributeQueryHome.java
====================
package com.stibo.core.domain.singleattributequery;

/**
 *A home to search for data nodes having a specific value for a specific attribute.
 * <p/>
 * Can be used like this:
 * <pre> {@code
 * List<Product> products = manager.getHome(SingleAttributeQueryHome.class).querySingleAttribute(new SingleAttributeQueryHome.SingleAttributeQuerySpecification(Product.class, attribute, "A value")).asList(10);
 * } </pre>
 */
public abstract interface SingleAttributeQueryHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Get a query object for querying for nodes having a specific value for a specific attribute.
   * When calling asList on this Query a maxmimum of 100 query results will be returned.
   * @param specification the specification of the search to make
   * @return a Query instance that can be used to retrieve the requested nodes.
   */
  public abstract <T extends com.stibo.core.domain.Node>com.stibo.core.domain.query.Query<T> querySingleAttribute(com.stibo.core.domain.singleattributequery.SingleAttributeQueryHome.SingleAttributeQuerySpecification<T> specification);
  
  /**
   *The specification of a single attribute query condition.
   * @param <T> the result type.
   */
  public static class SingleAttributeQuerySpecification<T extends com.stibo.core.domain.Node> {
    
    /**
     *The attribute to search for
     */
    public com.stibo.core.domain.Attribute attribute;
    
    /**
     *A root node that the result will be filtered against. Can be a classification node for products and assets, otherwise it should be the same type as the type requested.
     */
    public com.stibo.core.domain.datanode.DataNode root;
    
    /**
     *The type of data node to search for.
     */
    public java.lang.Class<T> type;
    
    /**
     *The unit to search for if any.
     */
    public com.stibo.core.domain.Unit unit;
    
    /**
     *The value to search for, must be exact, ie. wildcards are not dealt with.
     */
    public java.lang.String value;
    
    /**
     *Instantiates a new SingleAttributeQuerySpecification for specifying a single attribute query condition.
     * @param type The type of data node to search for.
     * @param attribute The attribute to search for.
     * @param value The value to search for, must be exact, ie. wildcards are not handled.
     */
    public SingleAttributeQuerySpecification(java.lang.Class<T> type,com.stibo.core.domain.Attribute attribute,java.lang.String value) {}
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApproveAssetTrigger.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Executes additional task on approval of Assets, implement to get your code executed on approval.
 */
public abstract interface ApproveAssetTrigger extends com.stibo.core.domain.spi.approve.ApproveTrigger {
  
  /**
   *Special approve trigger context for approving Assets
   */
  public abstract static interface ApproveAssetTriggerContext extends com.stibo.core.domain.spi.approve.ApproveTrigger.ApproveTriggerContext {
    
    /**
     *Add the content of this asset to the part objects that will be approved
     * @param dimPoints The dimension points where the content should be approved. Null mean current context.
     */
    public abstract void approveAssetContent(java.util.Set<com.stibo.core.domain.DimensionPoint> dimPoints);
    
    /**
     *Approves the classification asset link.
     * @param classification The classification the asset link should be approved for. Must not be <code>null</code>.
     */
    public abstract void approveClassificationAssetLink(com.stibo.core.domain.Classification classification);
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApproveClassificationTrigger.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Executes additional task on approval of Classifications, implement to get your code executed on approval.
 */
public abstract interface ApproveClassificationTrigger extends com.stibo.core.domain.spi.approve.ApproveTrigger {
  
  /**
   *Context for approving Classifications
   */
  public abstract static interface ApproveClassificationTriggerContext extends com.stibo.core.domain.spi.approve.ApproveTrigger.ApproveTriggerContext {
    
    /**
     *Adds a attribute link to the part objects that should be approved
     * @param attributeLink The attribute link that should be approved. Must not be <code>null</code>.
     */
    public abstract void approveAttributeLink(com.stibo.core.domain.AttributeLink attributeLink);
    
    /**
     *Adds a ClassificationProductLink to the part objects that should be approved
     * @param classificationProductLink The classification link that should be approved. Must not be <code>null</code>.
     */
    public abstract void approveClassificationProducLink(com.stibo.core.domain.ClassificationProductLink classificationProductLink);
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApproveEntityTrigger.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Executes additional task on approval of Entities, implement to get your code executed on approval.
 */
public abstract interface ApproveEntityTrigger extends com.stibo.core.domain.spi.approve.ApproveTrigger {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApprovePlugin.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Common interface of all Approve Triggers and Validators. Should not be implemented directly.
 */
public abstract interface ApprovePlugin {
  
  /**
   *Context available for WorkspaceAwareRevisableNodes being approved.
   * Allows you to compare data across workspaces prior to the approval and access information about the data to be synchronized.
   */
  public abstract static interface ApproveContext {
    
    /**
     *Get the Manager providing a gateway into the domain model for the Approved Workspace.
     * @return The STEP manager in approved workspace
     */
    public abstract com.stibo.core.domain.Manager getApprovedManager();
    
    /**
     *Get the node in the approved workspace.
     * @return the node in the approved workspace, null if node is not approved - or invisible in this context
     */
    public abstract com.stibo.core.domain.WorkspaceRevisableNode getApprovedNode();
    
    /**
     *Gets the predecessor revision of the node in the Approved workspace.
     * The predecessor revision is the revision before the latest revision of the node.
     * Notice that business conditions configured to be evaluated before approval and business actions configured
     * to be executed during approval are run before the approval is reflected in the Approved workspace.
     * For these, the name of this method will be misleading as it at this point in time will be the
     * latest revision in Approved that will reflect the state of the node before approval.
     * The latest revision can be obtained via the getApprovedNode() method.
     * @return the node in the approved workspace, null if node is not approved - or invisible in this context
     */
    public abstract com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode getApprovedNodeBeforeApproval();
    
    /**
     *Get the Manager providing a gateway into the domain model for the Main Workspace.
     * @return The STEP manager in Main context
     */
    public abstract com.stibo.core.domain.Manager getMainManager();
    
    /**
     *Get the node in the main workspace.
     * @return the node in the main workspace
     */
    public abstract com.stibo.core.domain.WorkspaceRevisableNode getMainNode();
    
    /**
     *Get the part objects involved in the approval.
     * @return part objects involved in the approval.
     */
    public abstract java.util.Set<com.stibo.core.domain.partobject.PartObject> getPartObjects();
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApproveProductTrigger.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Executes additional task on approval of Products, implement to get your code executed on approval.
 */
public abstract interface ApproveProductTrigger extends com.stibo.core.domain.spi.approve.ApproveTrigger {
  
  public abstract static interface ApproveProductTriggerContext extends com.stibo.core.domain.spi.approve.ApproveTrigger.ApproveTriggerContext {
    
    /**
     *Adds a attribute link to the part objects that should be approved
     * @param attributeLink The attribute link that should be approved. Must not be <code>null</code>.
     */
    public abstract void approveAttributeLink(com.stibo.core.domain.AttributeLink attributeLink);
    
    /**
     *Adds a ClassificationProductLink to the part objects that should be approved
     * @param classificationProductLink The classification Link that should be approved. Must not be <code>null</code>.
     */
    public abstract void approveClassificationProducLink(com.stibo.core.domain.ClassificationProductLink classificationProductLink);
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApproveTrigger.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *This interface is a common interface for all the approve trigger interfaces. It should not be directly implemented.
 * Please see <class>ApproveAssetTrigger</class>, <class>ApproveProductTrigger</class>,
 * <class>ApproveClassificationTrigger</class> and <class>ApproveEntityTrigger</class>
 */
public abstract interface ApproveTrigger extends com.stibo.core.domain.spi.approve.ApprovePlugin {
  
  /**
   *Executes the job of this trigger
   */
  public abstract void run();
  
  /**
   *A context for the approve trigger. If the trigger changes the object, the changes will not be automatically
   * approved. This can be done via this context object
   */
  public abstract static interface ApproveTriggerContext extends com.stibo.core.domain.spi.approve.ApprovePlugin.ApproveContext {
    
    /**
     *Executes the executor without checking privileges
     *
     * @param executor The executor that should be executed
     * @param <T> The return type of the executor
     * @return The return value of the executor
     * @throws Exception Will throw the same Exceptions as the executor
     */
    public abstract <T extends java.lang.Object>T executeWritePrivileged(com.stibo.core.domain.PrivilegedExecutor<T> executor) throws java.lang.Exception;
    
    /**
     *Adds the name to the part object the should be approved
     * @param dimPoints The dimension points the name should be approved in, null mean current context of the approval
     */
    public abstract void approveName(java.util.Set<com.stibo.core.domain.DimensionPoint> dimPoints);
    
    /**
     *Adds a reference to the part objects that should be approved
     * @param reference The reference that should be approved. Must not be <code>null</code>.
     */
    public abstract void approveReference(com.stibo.core.domain.Reference reference);
    
    /**
     *Adds a value to the part object that should be approved
     * @param value The value that should be approved. Must not be <code>null</code>.
     */
    public abstract void approveValue(com.stibo.core.domain.SingleValue value);
    
    /**
     *Sends an event to an event queue telling that the part object for a node has changed
     * @param eventQueueID ID of event queue. Must not be <code>null</code>.
     * @param node the Node that has been modified. Must not be <code>null</code>.
     */
    public abstract void sendApproveModifiedEvent(java.lang.String eventQueueID,com.stibo.core.domain.WorkspaceRevisableNode node);
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\ApproveValidator.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Implement this interface to provide a validation for approval. Notice that approve validations run with privileges disabled (but stibo. checks enabled), this ensures that validations
 * do not succeed simply due to user having limited view privileges.
 *
 * @see DeleteApproveValidator
 */
public abstract interface ApproveValidator extends com.stibo.core.domain.spi.approve.ApprovePlugin {
  
  /**
   *Validate the node after approval
   * @throws ApproveValidationException if validation fails.
   */
  public abstract void after() throws com.stibo.core.domain.approve.ApproveValidationException;
  
  /**
   *Validate the node before approval.
   * @throws ApproveValidationException if validation fails
   */
  public abstract void before() throws com.stibo.core.domain.approve.ApproveValidationException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\DeleteApprovePlugin.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Interface for plugins that should be run when approving a deletion, should not be implemented directly.
 * @see DeleteApproveValidator
 */
public abstract interface DeleteApprovePlugin {
  
  /**
   *The approve context for the approval of a deletion.
   */
  public abstract static interface DeleteApproveContext {
    
    /**
     *Get the Manager providing a gateway into the domain model for the Approved Workspace.
     * @return STEP Manager for Approved workspace
     */
    public abstract com.stibo.core.domain.Manager getApprovedManager();
    
    /**
     *Get the node in the approved workspace.
     * @return the node in the approved workspace
     */
    public abstract com.stibo.core.domain.WorkspaceRevisableNode getApprovedNode();
    
    /**
     *Get the Manager providing a gateway into the domain model for the Main Workspace.
     * @return STEP Manager for Main workspace
     */
    public abstract com.stibo.core.domain.Manager getMainManager();
    
    /**
     *Get the node in the main workspace.
     * @return the node in the main workspace
     */
    public abstract com.stibo.core.domain.WorkspaceRevisableNode getMainNode();
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\spi\approve\DeleteApproveValidator.java
====================
package com.stibo.core.domain.spi.approve;

/**
 *Implement this interface to provide a validation for delete approval. Notice that approve delete validations run with privileges disabled (but stibo. checks enabled), this ensures that validations
 * do not succeed simply due to user having limited view privileges.
 *
 * @see ApproveValidator
 */
public abstract interface DeleteApproveValidator extends com.stibo.core.domain.spi.approve.DeleteApprovePlugin {
  
  /**
   *Validate the node after approval of deletion
   * @throws com.stibo.core.domain.approve.ApproveValidationException if validation fails.
   */
  public abstract void after() throws com.stibo.core.domain.approve.ApproveValidationException;
  
  /**
   *Validate the node before approval of deletion.
   * @throws com.stibo.core.domain.approve.ApproveValidationException if validation fails
   */
  public abstract void before() throws com.stibo.core.domain.approve.ApproveValidationException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\Event.java
====================
package com.stibo.core.domain.state;

/**
 *An event that can be send to a workflow.
 */
public abstract interface Event {
  
  /**
   *Returns the identifier for the event
   * @return the event identifier
   */
  public abstract java.lang.String getID();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\Mailer.java
====================
package com.stibo.core.domain.state;

/**
 *Utility for sending email.
 * Deprecated: Please use the MailHome bind instead.
 */
@java.lang.Deprecated()
public abstract interface Mailer {
  
  /**
   *Send an email as specified by the parameters.
   * @param sender The sender of the email
   * @param receiver The receiver of the email
   * @param subject The subject to use for the email
   * @param body The content body of the email
   */
  public abstract void send(java.lang.String sender,java.lang.String receiver,java.lang.String subject,java.lang.String body);
  
  /**
   *Send an email as specified by the parameters.
   * @param sender The sender of the email
   * @param receiver The receiver of the email
   * @param subject The subject to use for the email
   * @param body The content body of the email
   * @param attachments Optional argument can be either a File, String og FileInfo (or a Collection of these)
   */
  public abstract void send(java.lang.String sender,java.lang.String receiver,java.lang.String subject,java.lang.String body,java.lang.Object attachments);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\State.java
====================
package com.stibo.core.domain.state;

/**
 *A state belonging to a STEP Workflow. It contains the id and title of the state and the workflow definition.
 */
public abstract interface State extends com.stibo.core.domain.DomainObject {
  
  /**
   *Returns the ID of the state. Will always return a value.
   * @return ID as entered for the State in the Workflow editor
   */
  public abstract java.lang.String getID();
  
  /**
   *Return the events that can be handled in this state. The events are returned in the order they
   * are defined in the workflow definition.
   * @return the legal events. Returns empty set if none.
   */
  public abstract java.util.List<com.stibo.core.domain.state.Event> getLegalEvents();
  
  /**
   *Returns a display title for the state
   * @return a the title. If title is null the ID of the state. Will not return <code>null</code>.
   */
  public abstract java.lang.String getTitle();
  
  /**
   *Returns all outgoing transitions.
   * <p>
   * Order configured in the workflow designer tool will be respected
   * @return a list of outgoing transitions
   */
  public abstract java.util.List<com.stibo.core.domain.state.Transition> getTransitions();
  
  /**
   *Returns all unconditionally mandatory attributes.
   * These are attributes that have been configured to be mandatory for the state without any condition having been specified.
   * @return a set of unconditionally mandatory attributes
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getUnconditionallyMandatoryAttributes();
  
  /**
   *Returns all unconditionally mandatory reference/link types.
   * These are reference/link types that have been configured to be mandatory for the state without any condition having been specified.
   * @return a set of unconditionally mandatory reference/link types
   */
  public abstract java.util.Set<com.stibo.core.domain.LinkType> getUnconditionallyMandatoryLinkTypes();
  
  /**
   *Return the Workflow instance that this State belongs to
   * @return owning Workflow. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.state.Workflow getWorkflow();
  
  /**
   *Returns a boolean that indicates if the state is a leaf node - meaning it has no sub-states.
   * @return true if this state has now child states or is a Final state
   */
  public abstract boolean isLeaf();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\StatusFlag.java
====================
package com.stibo.core.domain.state;

/**
 *Status flag for at task.
 */
public abstract interface StatusFlag extends com.stibo.core.domain.Node {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\Task.java
====================
package com.stibo.core.domain.state;

/**
 *Task is the preferred way to work with a node in a specific state in a STEP Workflow.
 *  It contains information about workflow, state, node, assignee, priority and deadline.
 *  It also has methods necessary to work with the task
 */
public abstract interface Task extends com.stibo.core.domain.DomainObject {
  
  /**
   *Start a background process that notifies the task when the background process completes.
   *
   * Notice that the background process is not committed before the containing transaction commits.
   *
   * @param serviceDescriptor the descriptor identifying the service to run. Must not be <code>null</code>.
   * @param parameter the parameter (list with values from object filled in) for the service. Must not be <code>null</code>.
   * @param description the description of the background process as viewed in the UI. Must not be <code>null</code>.
   * @param <P> Type of the parameter
   * @param <T> Type of the descriptor.
   * @return the newly created background process. Will not return <code>null</code>.
   */
  public abstract <P extends java.lang.Object,T extends com.stibo.core.domain.backgroundprocess.service.ServiceDescriptor<P>>com.stibo.core.domain.backgroundprocess.BackgroundProcess startBackgroundProcess(java.lang.Class<T> serviceDescriptor,P parameter,java.lang.String description);
  
  /**
   *Assign the task to the current user.
   * A user is only allowed claim a task, if he is a member of the group the task is currently assigned to.
   */
  public abstract void claim();
  
  /**
   *Returns the current assignee for this task.
   * @return the current assignee for the task. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.Assignee getAssignee();
  
  /**
   *Gets the current deadline for the task
   * advance STEP Workflow only
   * @return the deadline of the task or <code>null</code> if none
   */
  public abstract java.util.Date getDeadline();
  
  /**
   *Sort of "Task creation time" - timestamp for the node entering the state which defines the task
   * advance STEP Workflow only
   * @return the time that the state was entered. Will not return <code>null</code>.
   */
  public abstract java.util.Date getEntryTime();
  
  /**
   *The node for this Task
   * @return the step node. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.WorkflowableNode getNode();
  
  /**
   *Returns the state that this task it related to.
   * @return the State this Task is related to. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.state.State getState();
  
  /**
   *Returns the status for this task.
   * @return returns the status of this task. Notice that status can be null.
   */
  public abstract com.stibo.core.domain.state.StatusFlag getStatusFlag();
  
  /**
   *Gets the workflow instance to which the this task belongs.
   * @return The WorkflowInstance for this Task.
   */
  public abstract com.stibo.core.domain.state.WorkflowInstance getWorkflowInstance();
  
  /**
   *reassigns the task to the supplied assignee (user or group)-
   * this requires Workflow administrator privileges as normal users should only be allowed to claim and unClaim
   * advance STEP Workflow only
   * @param assignee the user or group assign to. Must not be <code>null</code>.
   * @throws IllegalArgumentException is assignee is <code>null</code>.
   */
  public abstract void reassign(com.stibo.core.domain.Assignee assignee);
  
  /**
   *Set the deadline of the task
   * advance STEP Workflow only
   * @param date -date and time of new deadline; <code>null</code> to clear deadline.
   */
  public abstract void setDeadline(java.util.Date date);
  
  /**
   *Set the status of this task
   * @param statusID the ID of status to be set for this task
   */
  public abstract void setStatusFlagByID(java.lang.String statusID);
  
  /**
   *Triggers the taskEvent with the given id on this task
   * This trigger will execute immediately and return a TaskEventResult
   * -this will fail if triggered from within a script in the same WorkflowInstance as this Task is in
   * @param taskEventID id of the taskEvent to trigger or <code>null</code> for anonymous event
   * @param message a optional message for the transition log. Can be <code>null</code>.
   * @return an event-result that indicates if the transition was performed or conditions rejected the event. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.state.TriggerResult triggerByID(java.lang.String taskEventID,java.lang.String message);
  
  /**
   *queues taskEvent with the given id on this task
   * this is the way to trigger taskEvents from a Business rule in the same WorkflowInstance as the task
   * will fail if in the wrong context - ie. not from a business rule in the same WorkflowInstance as the Task
   * @param taskEventID id of the taskEvent to queue or <code>null</code> for anonymous event
   * @param message a optional message for the transition log. Can be <code>null</code>.
   */
  public abstract void triggerLaterByID(java.lang.String taskEventID,java.lang.String message);
  
  /**
   *Unclaim the task by giving it back to the previous assigned group or assign it to the default assignee for the state.
   * Can only be called, if the user invoking the method is currently assigned to the task.
   * @return the assignee that task is released to. Will return <code>null</code> if the current user is not assigned to the task.
   */
  public abstract com.stibo.core.domain.Assignee unclaim();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\Transition.java
====================
package com.stibo.core.domain.state;

/**
 *Represents a modelled transition between two states in a workflow.
 */
public abstract interface Transition {
  
  /**
   *Returns all events supported by this transition.
   * @return a set of valid events
   */
  public abstract java.util.Set<com.stibo.core.domain.state.Event> getEvents();
  
  /**
   *Returns all unconditionally mandatory attributes.
   * These are attributes that have been configured to be mandatory for the transition without any condition having been specified.
   * @return a set of unconditionally mandatory attributes
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getUnconditionallyMandatoryAttributes();
  
  /**
   *Returns all unconditionally mandatory reference/link types.
   * These are reference/link types that have been configured to be mandatory for the transition without any condition having been specified.
   * @return a set of unconditionally mandatory reference/link types
   */
  public abstract java.util.Set<com.stibo.core.domain.LinkType> getUnconditionallyMandatoryLinkTypes();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\TriggerResult.java
====================
package com.stibo.core.domain.state;

/**
 *The output from triggering an taskEvent on a Task
 */
public abstract interface TriggerResult {
  
  /**
   *a message returned by the script. Will be logged (on bulk operations) or displayed to the user.
   * Required if the script refuses the node
   * @return a string message. Will return <code>null</code> if triggering was not rejected.
   */
  public abstract java.lang.String getScriptMessage();
  
  /**
   *Workflow condition scripts can return  a boolean to indicate 'soft' success or failure instead of throwing exceptions
   * @return a boolean flag returned from the script to indicate rejection - ie. no transitions where performed by the trigger
   */
  public abstract boolean isRejectedByScript();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\Workflow.java
====================
package com.stibo.core.domain.state;

/**
 *Holds the definition of a workflow.
 * A lightweight workflow/state machine that describes the states an node can pass through,
 * along with rules describing how events trigger different actions, which move an item node
 * one state to another.
 */
public abstract interface Workflow extends com.stibo.core.domain.RevisableNode {
  
  /**
   *Return the external ID of this workflow. Will not return <code>null</code>.
   * @return the external ID of this workflow. Will not return <code>null</code>.
   */
  public abstract java.lang.String getID();
  
  /**
   *Returns the latest process notes for the given item.
   *
   * @param node     the item to inspect. Must no be <code>null</code>.
   * @param maxcount the maximum number of hits to return
   * @return the process notes in reverse chronological order. Will return empty list rather than <code>null</code> if there are no notes.
   * @deprecated Do not use. Use one of the following methods instead.
   * @see WorkflowLogHome#queryWorkflowLogTransitionEntries(Workflow workflow, WorkflowableNode node)
   * @see WorkflowLogHome#queryWorkflowLogAssignmentEntries(Workflow workflow, WorkflowableNode node)
   * @see WorkflowLogHome#queryWorkflowLogNoteEntries(Workflow workflow, WorkflowableNode node)
   * @see WorkflowLogHome#queryWorkflowLogStatusFlagEntries(Workflow workflow, WorkflowableNode node)
   */
  public abstract java.util.List<com.stibo.core.domain.state.unstable.log.StateLogEntry> getProcessNotes(com.stibo.core.domain.WorkflowableNode node,int maxcount);
  
  /**
   *Get the state with the given ID.
   *
   * @param stateID the external ID to look for. Must not be <code>null</code>.
   * @return the state or <code>null</code> if no such state exists.
   */
  public abstract com.stibo.core.domain.state.State getStateByID(java.lang.String stateID);
  
  /**
   *Get all legal states.
   *
   * @return the legal states for this workflow. Will not return <code>null</code>.
   */
  public abstract java.util.Set<com.stibo.core.domain.state.State> getStates();
  
  /**
   *Return the display name for this workflow
   *
   * @return a string containing the resulting title. Can return <code>null</code> depending on which <code>TitlePlugin</code> is used.
   */
  public abstract java.lang.String getTitle();
  
  /**
   *Starts this workflow for the given node
   * will fail if the workflow is already started for the node or the node is of an object type
   * that is not valid for the workflow
   *
   * @param node    the workflow-able node to start flow for. Must not be <code>null</code>.
   * @param message an optional message for the log. can not be <code>null</code>.
   * @return instance representing the node in this Workflow. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.state.WorkflowInstance start(com.stibo.core.domain.WorkflowableNode node,java.lang.String message);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\WorkflowAttachment.java
====================
package com.stibo.core.domain.state;

/**
 *Represents attachments that can be made to a Workflow Instance.
 */
public abstract interface WorkflowAttachment {
  
  /**
   *Adds more content to attachment.
   * @param content new content to add. Must not be <code>null</code>.
   */
  public abstract void add(com.stibo.core.domain.state.WorkflowAttachmentContent content);
  
  /**
   *Creates more content to attachment.
   *
   * @param contentID ID of content. Must not be <code>null</code>.
   * @param data new content to add. Must not be <code>null</code>.
   */
  public abstract void createContent(java.lang.String contentID,java.io.InputStream data);
  
  /**
   *Returns the content of this attachment.
   * @return the content of the attachment. Will not return <code>null</code>.
   */
  public abstract java.util.Set<com.stibo.core.domain.state.WorkflowAttachmentContent> getContent();
  
  /**
   *Returns the ID of this attachment.
   * @return the identifier of the attachment.
   */
  public abstract java.lang.String getID();
  
  /**
   *Returns true is this workflowattachment has content, false otherwise.
   * @return true if the attachment has content.
   */
  public abstract boolean hasContent();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\WorkflowAttachmentContent.java
====================
package com.stibo.core.domain.state;

/**
 *Represents the content of a STEP Workflow Attachment.
 */
public abstract interface WorkflowAttachmentContent {
  
  /**
   *Deletes this attachment content.
   */
  public abstract void delete();
  
  /**
   *Returns the identifier of the attachment content.
   * @return the identifier of the attachment content. Will not return <code>null</code>.
   */
  public abstract java.lang.String getID();
  
  /**
   *Returns the content as a stream.
   * @return content as stream. Will not return <code>null</code>.
   * @throws IOException In case of errors and IOException is raised.
   */
  public abstract java.io.InputStream getStream() throws java.io.IOException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\WorkflowHome.java
====================
package com.stibo.core.domain.state;

/**
 *Home interface for finding Workflows.
 */
public abstract interface WorkflowHome {
  
  /**
   *Returns an in-production (or test) Workflow object relating to the identifier supplied.
   * (If you need to EDIT a workflow, retrieve it via StateFlowHome.getWorkflowForEditing until further notice.)
   * @param id The identifier of the Workflow object.
   * @return The Workflow with the identifier supplied or <code>null</code> if not found.
   */
  public abstract com.stibo.core.domain.state.Workflow getWorkflowByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\WorkflowInstance.java
====================
package com.stibo.core.domain.state;

/**
 *Represents a node's connection to a STEP Workflow.
 */
public abstract interface WorkflowInstance {
  
  /**
   *Deletes this STEP Workflow instance ie. remove the node from all states and deletes all tasks.
   * -should only be called under strict privileges control
   * @param message - message added to audit/transition log. Can be <code>null</code>.
   */
  public abstract void delete(java.lang.String message);
  
  /**
   *Return the Workflow attachment with the given id
   * @param attachmentID the identifier of the attachment to retrieve. Must not be <code>null</code>.
   * @return the attachment with the given id or <code>null</code> if no such attachment exists.
   */
  public abstract com.stibo.core.domain.state.WorkflowAttachment getAttachmentByID(java.lang.String attachmentID);
  
  /**
   *Returns a simple value for the STEP Workflow variable.
   * Will return <code>null</code> if variable does not exist or user is missing privileges.
   * @param variableID id of variable. Most not be <code>null</code>.
   * @return a simple value for STEP Workflow variable. - returns <code>null</code> if variable does not exist or user is missing privileges.
   */
  public abstract java.lang.String getSimpleVariable(java.lang.String variableID);
  
  /**
   *Return a task
   * @param state the state to get the task for. Must not be <code>null</code>.
   * @return the task for the specified state. Returns <code>null</code> if no task is found.
   */
  public abstract com.stibo.core.domain.state.Task getTask(com.stibo.core.domain.state.State state);
  
  /**
   *Return a task by the id of the state
   * @param stateID the identifier of the state to get the task for. Must not be <code>null</code>.
   * @return the task for the specified state id. Returns <code>null</code> if no task is found.
   */
  public abstract com.stibo.core.domain.state.Task getTaskByID(java.lang.String stateID);
  
  /**
   *Returns the tasks that the node is currently in
   * @return current tasks from the workflow
   */
  public abstract java.util.Set<com.stibo.core.domain.state.Task> getTasks();
  
  /**
   *Gets a STEP Value-object for the WorkflowInstance
   * note that for this to work the underlying attribute MUST be bound to workflow variable
   * @param attributeID id of attribute bound to a variable in the Workflow. Must not be <code>null</code>.
   * @return the value object for a bound workflow variable
   * @throws exception if no Workflow variable is bound to an attribute of the given id.
   */
  public abstract com.stibo.core.domain.Value getValue(java.lang.String attributeID);
  
  /**
   *Gets the workflow that holds the definition for this instance
   * @return the workflow. Will not return <code>null</code>.
   */
  public abstract com.stibo.core.domain.state.Workflow getWorkflow();
  
  /**
   *Sets a simple value for STEP Workflow variable.
   * @param variableID id of variable. Most not be <code>null</code>.
   * @param simpleValue the value to set for the variable. Can be <code>null</code>. If simpleValue is <code>null</code>, the existing value will be erased.
   * @throws ValidatorException if the value fails validation - this can happen if the variable is bound to an Attribute
   */
  public abstract void setSimpleVariable(java.lang.String variableID,java.lang.String simpleValue) throws com.stibo.core.domain.ValidatorException;
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\currenttransition\CurrentTransition.java
====================
package com.stibo.core.domain.state.currenttransition;

/**
 *Describes the properties of the current transition being performed in a STEP Workflow.
 * This will be accessible to javascript business conditions and actions through the "Current transition" binding in the business rule editor
 * Current Transition is available to all onEntry, onTransition and onExit business actions and to business conditions placed
 * on transitions.
 * It is not available to Workflow start condition, actions on Task deadlines or any conditions on conditionally mandatory
 * attributes.
 */
public abstract interface CurrentTransition {
  
  /**
   *Returns the event triggered or null if an anonymous event was triggered
   *
   * @return current event or null
   */
  public abstract com.stibo.core.domain.state.Event getEvent();
  
  /**
   *Returns the current submit message or null.
   * This message can be entered by the user when a workflow is started or a event is triggered (submitted). In some
   * cases this message is generated automatically.
   * If this message should be carried over on Task.triggerByID or Task.triggerLaterByID the business rule that does
   * the Task.trigger... must obtain it from current transition and include it in trigger
   *
   * @return current message or null if none available
   */
  public abstract java.lang.String getMessage();
  
  /**
   *The state from which this transition originates - nodes will move out of this state when performing the
   * transition.  The source state can be null if the Javascript is running as part of an onEntry business action
   * for the Initial state of the Workflow.
   *
   * @return the source state or null if not available.
   */
  public abstract com.stibo.core.domain.state.State getSource();
  
  /**
   *Target state that nodes will move to when performing the transition.
   *
   * @return the target state
   */
  public abstract com.stibo.core.domain.state.State getTarget();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\function\WorkflowFunctionHome.java
====================
package com.stibo.core.domain.state.function;

/**
 *A Home to add workflow functions.
 */
public abstract interface WorkflowFunctionHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Return all attributes that are conditionally or unconditionally mandatory for a given state which are
   * missing from the supplied workflow node.
   * @param state workflow state.
   * @param node node that is in a workflow.
   * @return mandatory attributes required for this workflow state which are missing from this node.
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getStateMissingMandatoryAttributes(com.stibo.core.domain.state.State state,com.stibo.core.domain.WorkflowableNode node);
  
  /**
   *Returns all references/links that are conditionally or unconditionally mandatory for a given state which are
   * missing from the supplied workflow node.
   * @param state workflow state.
   * @param node node that is in a workflow.
   * @return mandatory link types required for the workflow state which are missing from this node.
   */
  public abstract java.util.Set<com.stibo.core.domain.LinkType> getStateMissingMandatoryLinkTypes(com.stibo.core.domain.state.State state,com.stibo.core.domain.WorkflowableNode node);
  
  /**
   *Return all attributes that are conditionally or unconditionally mandatory for a given transition which are
   * missing from the supplied workflow node.
   * @param transition workflow state transition.
   * @param node node that is in a workflow.
   * @return mandatory attributes required when doing the requested workflow state transition which are missing from this node.
   */
  public abstract java.util.Set<com.stibo.core.domain.Attribute> getTransitionMissingMandatoryAttributes(com.stibo.core.domain.state.Transition transition,com.stibo.core.domain.WorkflowableNode node);
  
  /**
   *Returns all references/links that are conditionally or unconditionally mandatory for a given transition which are
   * missing from the supplied workflow node.
   * @param transition workflow state transition.
   * @param node node that is in a workflow.
   * @return mandatory link types required when doing the requested workflow state transition which are missing from this node.
   */
  public abstract java.util.Set<com.stibo.core.domain.LinkType> getTransitionMissingMandatoryLinkTypes(com.stibo.core.domain.state.Transition transition,com.stibo.core.domain.WorkflowableNode node);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\log\WorkflowLogEntry.java
====================
package com.stibo.core.domain.state.log;

/**
 *Audit log and process notes for the state system.
 * Notice that there are 3 types of log entries:
 * 1) Transition - captures info about the state before and after the transition.
 * 2) Assignment - captures info about who gets assigned to a task
 * 3) Note - user specified message.
 * Notice that the various fields on the StateLogEntry does not make sense for all types of the above log entries.
 * E.g. the <code>from</code> and <code>to</code> fields does not make sense for a note log entry.
 */
public abstract interface WorkflowLogEntry {
  
  /**
   *Will return null, if LogType of this is not WorkflowLogType.ASSIGNMENT. ie a state transition or status change.
   * @return the ID of the assignee User or Group. Notice that the assignee might not exist (could have been deleted).
   */
  public abstract java.lang.String getAssigneeID();
  
  /**
   *Get the ID of the event that caused the update
   * @return the ID of an event as defined in the STEP Workflow. Can return <code>null</code>.
   */
  public abstract java.lang.String getEvent();
  
  /**
   *The state that the item was in before the event
   * @return the ID of the state before the update. Can return <code>null</code>.
   */
  public abstract java.lang.String getFromState();
  
  /**
   *Content of the process note
   * @return the note.  Can return <code>null</code>.
   */
  public abstract java.lang.String getMessage();
  
  /**
   *Returns the status-flag affected in this entry.
   *
   * @return status-flag or null
   */
  public abstract com.stibo.core.domain.state.StatusFlag getStatusFlag();
  
  /**
   *When did the event occur
   * @return timestamp. Will not return <code>null</code>.
   */
  public abstract java.util.Date getTime();
  
  /**
   *The state that the item was in after the event
   * @return ID of the state. Can return <code>null</code>.
   */
  public abstract java.lang.String getToState();
  
  /**
   *Notice that a user might have been deleted since the log entry was made.
   * Thus the system might not contain a user matching the returned ID.
   * @return userID for the user that caused the change. Will not return <code>null</code>.
   */
  public abstract java.lang.String getUserID();
  
  /**
   *Will return true if the LogType for this entry is WorkflowLogType.ASSIGNMENT and the Assigment is to a group. Otherwise returns false.
   * @return true if assigment was for a group. Otherwise false.
   */
  public abstract boolean isAssigneeGroup();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\log\home\WorkflowLogHome.java
====================
package com.stibo.core.domain.state.log.home;

/**
 *Home for retrieval of {@link WorkflowLogEntry}.
 */
public abstract interface WorkflowLogHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Returns a query with all "assignment" workflow log entries for a node in a workflow
   * Notice that the returned information can span multiple workflow instances.
   *
   * @param workflow the workflow to retrieve log entries for
   * @param node the node to retrieve log entries for
   * @return a query with all workflow log entries of type "assignment" for the passed node in the passed workflow
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.state.log.WorkflowLogEntry> queryWorkflowLogAssignmentEntries(com.stibo.core.domain.state.Workflow workflow,com.stibo.core.domain.WorkflowableNode node);
  
  /**
   *Returns a query with all "note" workflow log entries for a node in a workflow
   * Notice that the returned information can span multiple workflow instances and that
   * notes can be present for "transition" log entries as well as "note" log entries.
   *
   * @param workflow the workflow to retrieve log entries for
   * @param node the node to retrieve log entries for
   * @return a query with all workflow log entries of type "note" for the passed node in the passed workflow
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.state.log.WorkflowLogEntry> queryWorkflowLogNoteEntries(com.stibo.core.domain.state.Workflow workflow,com.stibo.core.domain.WorkflowableNode node);
  
  /**
   *Returns a query with all "statusflag" workflow log entries for a node in the workflow
   * Notice that the returned information can span multiple workflow instances.
   *
   * @param workflow the workflow to retrieve log entries for
   * @param node the node to retrieve log entries for
   * @return a query with all workflow log entries of type "statusflag" for the passed node
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.state.log.WorkflowLogEntry> queryWorkflowLogStatusFlagEntries(com.stibo.core.domain.state.Workflow workflow,com.stibo.core.domain.WorkflowableNode node);
  
  /**
   *Returns a query with all "transition" workflow log entries for a node in a workflow
   * Notice that the returned information can span multiple workflow instances.
   *
   * @param workflow the workflow to retrieve log entries for
   * @param node the node to retrieve log entries for
   * @return a query with all workflow log entries of type "transition" for the passed node in the passed workflow
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.state.log.WorkflowLogEntry> queryWorkflowLogTransitionEntries(com.stibo.core.domain.state.Workflow workflow,com.stibo.core.domain.WorkflowableNode node);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\transitionevaluation\TransitionEvaluation.java
====================
package com.stibo.core.domain.state.transitionevaluation;

/**
 *Describes the properties of the evaluated transition in a STEP Workflow including information of
 * why the transition may have been rejected.  This will be accessible to javascript business actions
 * through the "Transition evaluation" binding in the business rule editor
 *
 * Transition evaluation is available to all onEntry, onTransition and onExit business actions.
 * It is not available to actions on Task deadlines or any conditions.
 */
public abstract interface TransitionEvaluation {
  
  /**
   *Returns the event triggered or null if an anonymous event was triggered
   *
   * @return current event or null
   */
  public abstract com.stibo.core.domain.state.Event getEvent();
  
  /**
   *Returns the current submit message or null.
   * This message can be entered by the user when a workflow is started or an event is triggered (submitted).
   * In some cases this message is generated automatically.
   *
   * @return current message or null if no message is available
   */
  public abstract java.lang.String getMessage();
  
  /**
   *Returns the evaluation result messages of all the rejected transitions that have been evaluated.
   *
   * @return A list of the evaluation result messages or an empty list if none available.
   */
  public abstract java.util.List<java.lang.String> getResultMessages();
  
  /**
   *The state from which this transition originates - nodes will move out of this state when performing the
   * transition.  The source state can be null if the Javascript is running as part of an onEntry business action
   * for the Initial state of the Workflow.
   *
   * @return the source state.
   */
  public abstract com.stibo.core.domain.state.State getSource();
  
  /**
   *Target state that nodes will move to when performing the transition.
   *
   * @return the target state or null if the evaluated transition was rejected.
   */
  public abstract com.stibo.core.domain.state.State getTarget();
  
  /**
   *Returns true if the evaluated transition was rejected based on the applicable transition condition(s),
   * otherwise returns false.
   *
   * @return if the evaluated transition was rejected or not.
   */
  public abstract boolean isRejected();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\unstable\log\StateLogEntry.java
====================
package com.stibo.core.domain.state.unstable.log;

/**
 *Audit log and process notes for the state system.
 * Notice that there are 3 types of log entries:
 * 1) Transition - captures info about the state before and after the transition.
 * 2) Assignment - captures info about who gets assigned to a task
 * 3) Note - user specified message.
 * Notice that the various fields on the StateLogEntry does not make sense for all types of the above log entries.
 * E.g. the <code>from</code> and <code>to</code> fields does not make sense for a note log entry.
 */
public abstract interface StateLogEntry extends com.stibo.core.domain.state.log.WorkflowLogEntry {
  
  /**
   *Get the ID of the event that caused the update
   * @return the ID of an event as defined in the STEP Workflow. Can return <code>null</code>.
   */
  public abstract java.lang.String getEvent();
  
  /**
   *The state that the item was in before the event
   * @return the ID of the state before the update. Can return <code>null</code>.
   */
  public abstract java.lang.String getFromState();
  
  /**
   *Content of the process note
   * @return the note. Can return <code>null</code>.
   */
  public abstract java.lang.String getMessage();
  
  /**
   *When did the event occur
   * @return timestamp. Will not return <code>null</code>.
   */
  public abstract java.util.Date getTime();
  
  /**
   *The state that the item was in after the event
   * @return ID of the state. Can return <code>null</code>.
   */
  public abstract java.lang.String getToState();
  
  /**
   *Who caused the change
   * @return userID for the user that caused the change. Will not return <code>null</code>.
   */
  public abstract java.lang.String getUserID();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\state\unstable\stateflow\StateFlow.java
====================
package com.stibo.core.domain.state.unstable.stateflow;

/**
 *A lightweight workflow/state machine that describes the states an item can pass through,
 * along with rules describing how events trigger different actions, which move an item from
 * one state to another.
 */
public abstract interface StateFlow extends com.stibo.core.domain.state.Workflow {
  
  /**
   *Returns the latest process notes for the given item.
   *
   * @param node     the item to inspect. Must no be <code>null</code>.
   * @param maxcount the maximum number of hits to return
   * @return the process notes in reverse chronological order. Will never empty list rather than <code>null</code> if there are no notes.
   * @deprecated Please use version returning WorkflowLogEntry instead.
   * @see @com.stibo.core.domain.state.unstable.stateflow.StateFlow.getLogFiltered(WorkflowableNode node, Set<String> includeStateIDS, WorkflowLogType... logTypes)
   * @see @com.stibo.core.domain.state.WorkflowInstance#getLogFiltered(Set<String> includeStateIDS, WorkflowLogType... logTypes)
   * @see @com.stibo.core.domain.state.WorkflowInstance#getLogFiltered(Set<String> includeStateIDS, WorkflowLogType... logTypes)
   */
  public abstract java.util.List<com.stibo.core.domain.state.unstable.log.StateLogEntry> getProcessNotes(com.stibo.core.domain.WorkflowableNode node,int maxcount);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\synchronize\exception\SynchronizeException.java
====================
package com.stibo.core.domain.synchronize.exception;

/**
 *Used when synchronizing workspaces if PartObjects cannot be synchronized
 */
public class SynchronizeException extends com.stibo.core.domain.DomainException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\terms\HasTerms.java
====================
package com.stibo.core.domain.terms;

/**
 *Interface for Nodes that can have Terms
 */
public abstract interface HasTerms extends com.stibo.core.domain.Node {
  
  /**
   *Counts the STEPTrade terms that are associated with this node, limited to max.
   * 
   * @param termsList The list to query
   * @param max explained above and below - but we cannot compile if this line is missing.
   * @return the amount of terms, if not exceeding max.
   */
  public abstract int countTerms(com.stibo.core.domain.termslist.TermsList termsList,int max);
  
  /**
   *Finds the STEPTrade terms that are associated with this node. This includes price list terms and
   * selection list terms.
   * 
   * @param termsList The list to query
   * @return a collection of Terms
   */
  public abstract com.stibo.core.domain.query.Query<com.stibo.core.domain.termslist.TermsList.Term> queryTerms(com.stibo.core.domain.termslist.TermsList termsList);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\termslist\TermsList.java
====================
package com.stibo.core.domain.termslist;

/**
 *List of terms offered by a party.
 */
public abstract interface TermsList extends com.stibo.core.domain.Node {
  
  /**
   *Data for an individual term.
   */
  public static class Term {
    
    /**
     *Get Term end date or null If not exists.
     * @return end date of individual term or null if not exists.
     */
    public java.util.Date getEndDate() {
      throw new java.lang.UnsupportedOperationException();
    }
    
    /**
     *Get maximum quantity of term or -1 if undefined.
     * @return maximum quantity or -1 if undefined.
     */
    public int getMaxQuantity() {
      throw new java.lang.UnsupportedOperationException();
    }
    
    /**
     *Get minimum quantity of term.
     * @return minimum quantity.
     */
    public int getMinQuantity() {
      throw new java.lang.UnsupportedOperationException();
    }
    
    /**
     *Get Term start date or null If not exists.
     * @return start date of individual term or null if not exists.
     */
    public java.util.Date getStartDate() {
      throw new java.lang.UnsupportedOperationException();
    }
    
    /**
     *Get Term unit or null If not exists.
     * @return unit of term or null If not exists.
     */
    public com.stibo.core.domain.Unit getUnit() {
      throw new java.lang.UnsupportedOperationException();
    }
    
    /**
     *Get Term value
     * @return value of individual term
     */
    public java.lang.String getValue() {
      throw new java.lang.UnsupportedOperationException();
    }
    
  }
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\termslist\TermsListHome.java
====================
package com.stibo.core.domain.termslist;

/**
 *Home interface for access to Terms Lists
 *
 * Can be accessed from a Manager using:
 * <pre>{@code
 * manager.getHome(TermsListHome.class)
 * }</pre> or for javascript
 * <pre>{@code
 * manager.getHome(com.stibo.core.domain.termslist.TermsListHome)
 * }</pre>
 */
public abstract interface TermsListHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Gets terms list with supplied id
   * @param id The id of terms list
   * @return terms list with supplied id or null if not found
   */
  public abstract com.stibo.core.domain.termslist.TermsList getTermsListByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\translation\TranslatableNode.java
====================
package com.stibo.core.domain.translation;

/**
 *A node that is under workspace-aware revision control and can be dimension dependent; in short, with translation-features.
 */
public abstract interface TranslatableNode extends com.stibo.core.domain.workspaceaware.WorkspaceAwareRevisableNode {
  
  /**
   *The status of the translation (started, dirty or uptodate)
   * @return (started, dirty or uptodate)
   */
  public abstract com.stibo.core.domain.NodeTranslationStatus getCurrentTranslationStatus();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\unstable\localizablemessage\AbstractLocalizableMessage.java
====================
package com.stibo.core.domain.unstable.localizablemessage;

public abstract class AbstractLocalizableMessage extends java.lang.Object {
  
  public void addParameter(java.lang.String param,java.lang.Object value) {}
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\validator\info\ValidatorInfo.java
====================
package com.stibo.core.domain.validator.info;

/**
 *This interface contains methods returning validator information
 */
public abstract interface ValidatorInfo {
  
  /**
   *Returns the validator maximum length or null if none is configured.
   * Notice that if called for a list of values based attribute,
   * the validator maximum length of the list of values, if any, will be returned.
   *
   * @return The maximum length of the validator
   */
  public abstract java.lang.Integer getValidatorMaximumLength();
  
  /**
   *Returns the validator maximum value or null if none is configured.
   * Notice that if called for a list of values based attribute,
   * the validator maximum value of the list of values, if any, will be returned.
   * @return The maximum value of the validator
   */
  public abstract java.math.BigDecimal getValidatorMaximumValue();
  
  /**
   *Returns the validator minimum value or null if none is configured.
   * Notice that if called for a list of values based attribute,
   * the validator minimum value of the list of values, if any, will be returned.
   *
   * @return The minimum value of the validator
   */
  public abstract java.math.BigDecimal getValidatorMinimumValue();
  
  /**
   *Returns the validator name.
   * Notice that if called for a list of values based attribute,
   * the validator name of the list of values, if any, will be returned.
   *
   * @return The name of the validator
   */
  public abstract java.lang.String getValidatorName();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\validatorexception\ValueIDValidatorException.java
====================
package com.stibo.core.domain.validatorexception;

/**
 *Exception thrown when adding non-unique valueIDs to hard LOVs or valueIDs that is inconsistent with the hard LOVs useValueID flag.
 */
public abstract class ValueIDValidatorException extends com.stibo.core.domain.ValidatorException {
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\value\simplevaluepair\SimpleValuePair.java
====================
package com.stibo.core.domain.value.simplevaluepair;

/**
 *This was originally created to be mapped into survivorship rules, and can be used to represent 2 values for 2 nodes which have to be compared.
 * This could be used by simplevalue pair bind contract, to bind ind values for attributes to a business condition.
 *
 * @see SimpleValuePairBindContract
 */
public abstract interface SimpleValuePair {
  
  /**
   *Value 1 to be sent thru
   * @return returns value1
   */
  public abstract java.lang.String getValue1();
  
  /**
   *Value 2 to be sent thru
   * @return returns value2
   */
  public abstract java.lang.String getValue2();
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\workspaceaware\ApprovalStatus.java
====================
package com.stibo.core.domain.workspaceaware;

/**
 *ApprovalStatus.
 */
public enum ApprovalStatus {
  /**
   *Status for node that has never been approved, ie. has no approved data at all.
   */
  NotInApproved("Not in Approved workspace"), 
  /**
   *Status for node that is out of sync with the approved, ie. has unapproved data in context.
   */
  PartlyApproved("Partly approved"), 
  /**
   *Status for node that is context/partially approved, ie. has unapproved data in other context, but seen from this context no unapproved data.
   */
  ContextApproved("Approved in current context"), 
  /**
   *Status for node that is completely approved, ie. approved as seen from all contexts.
   */
  CompletelyApproved("Completely Approved");
  /**
   *Approval status name.
   */
  private java.lang.String name;
  /**
   *Returns the String representation of the ApprovalStatus.
   * @return String representation of ApprovalStatus.
   */
  public java.lang.String toString() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  private ApprovalStatus(java.lang.String name) {}
  
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\workspaceaware\ApproveStatus.java
====================
package com.stibo.core.domain.workspaceaware;

/**
 *Approve status. Can be non approved, context approved or complete approved.
 */
public enum ApproveStatus {
  /**
   *Status for node that is not approved, ie. has unapproved data in context.
   */
  None("Not Approved"), 
  /**
   *Status for node that is context/partially approved, ie. has unapproved data in other context, but seen from this context no unapproved data.
   */
  Context("Context Approved"), 
  /**
   *Status for node that is completely approved, ie. approved as seen from all contexts.
   */
  Complete("Complete Approved");
  /**
   *Approve status name.
   */
  private java.lang.String name;
  /**
   *Return a string form of the ApproveStatus
   * @return String format of the ApproveStatus.
   */
  public java.lang.String toString() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  private ApproveStatus(java.lang.String name) {}
  
  
}


====================
FILE PATH: .\com.stibo.core.domain-sources\com\stibo\core\domain\workspaceaware\WorkspaceAwareRevisableNode.java
====================
package com.stibo.core.domain.workspaceaware;

/**
 *A node that is under revision control and can be dimension dependent. This is the common supertype for
 * Products, Classifications and Assets, and now also some SetupNodes plus what may come.
 */
public abstract interface WorkspaceAwareRevisableNode extends com.stibo.core.domain.RevisableNode {
  
  /**
   *Approves this node in current context.
   * <p>
   * Method must be called from the Main workspace. Otherwise a runtime exception will be thrown.
   * <p>
   * A full approval will be attempted and an exception will be raised if the node cannot be synchronized to the
   * Approved workspace (e.g. due to the parent not being present in the Approved workspace, missing mandatory data
   * or an approval validator condition evaluating to false).
   * <p>
   * A best effort is made to approve as much as possible. If certain parts of the object cannot be approved, the
   * return set will contain a {@link com.stibo.core.domain.synchronize.exception.SynchronizeException} for each
   * failing part object.
   * An example of this could be a reference to a node that itself does not yet exist in the Approved workspace.
   * @return a set of synchronize exceptions; one for each part object that could not be synchronized; empty set if
   * all went well
   * @throws com.stibo.core.domain.approve.ApproveBulkValidationException if e.g. there are missing mandatory data or
   * an approval validator condition evaluates to false
   * 
   * @throws com.stibo.core.domain.synchronize.exception.SynchronizeException if e.g. the parent node is not present
   * in the Approved workspace
   * @throws RuntimeException if current workspace is not "Main"
   */
  public abstract java.util.Collection<com.stibo.core.domain.synchronize.exception.SynchronizeException> approve() throws com.stibo.core.domain.synchronize.exception.SynchronizeException,com.stibo.core.domain.approve.ApproveBulkValidationException;
  
  /**
   *Approve the specified objects (values/names/references) for this revisable node.
   * The objects to approve for this node carries the a set of dimension
   * points indentifying which contexts to approve in, ie. the method is
   * independent of the current viewing context.
   * Regarding workspaces: this method will always approve
   * the data from maintenance "Main" to "Approved". Current workspace MUST be Main, otherwise an exception is thrown.
   *
   * @param setOfPartObjects The objects to approve on this revisable node. This Set should only
   *                            contain objects owned by this node - (
   *                            this is always true if it only contains object received from query to get
   *                            non approved objects.
   * @return the return value is a set of synchronize exceptions. In no exceptions has occurred during appproval
   * this collection will be empty. (E.g. at synchronze exception happen when trying to approve a child product
   * which has a parent that has not yet been approved.
   * @throws com.stibo.core.domain.approve.ApproveBulkValidationException if a validation error occurs during approval (see subclasses of ApproveValidationException)
   * @throws com.stibo.core.domain.synchronize.exception.SynchronizeException covers various cases that might arise during approved see doc of SynchronizeException classe
   * @throws RuntimeException if current workspace is not Main.
   */
  public abstract java.util.Collection<com.stibo.core.domain.synchronize.exception.SynchronizeException> approve(java.util.Set<com.stibo.core.domain.partobject.PartObject> setOfPartObjects) throws com.stibo.core.domain.synchronize.exception.SynchronizeException,com.stibo.core.domain.approve.ApproveBulkValidationException;
  
  /**
   *Gets the approval status
   * @return approval status
   */
  public abstract com.stibo.core.domain.workspaceaware.ApprovalStatus getApprovalStatus();
  
  /**
   *Deprecated legacy method for getting the approval status<p/>
   * @return approval status
   * @deprecated use WorksapceAwareRevisableNode.getApprovalStatus() instead.
   */
  public abstract com.stibo.core.domain.workspaceaware.ApproveStatus getApproveStatus2();
  
  /**
   *Get set of PartObject instances representing the parts of this node having changes that is not approved.
   * Note: The part-object does not necessarily tell what changed in that part. 
   * E.g. a reference may both have been created or had changed a meta-attribute value.
   * Such differences can be discovered by comparing the retrieved part from the Main and the Approved workspace.   
   * @return Set of unapproved PartObjects (empty set if non objects)
   */
  public abstract java.util.Set<com.stibo.core.domain.partobject.PartObject> getNonApprovedObjects();
  
}


====================
FILE PATH: .\com.stibo.exportservices-sources\com\stibo\exportservices\descriptor\ExportServiceDescriptor.java
====================
package com.stibo.exportservices.descriptor;

/**
 *Service descriptor to use when running an export
 */
public final class ExportServiceDescriptor implements com.stibo.core.domain.backgroundprocess.service.ServiceDescriptor<com.stibo.exportservices.descriptor.ExportServiceDescriptor.Parameter> {
  
  /**
   *Parameters to start an export
   */
  public static class Parameter {
    
    /**
     *The id of the export configuration
     */
    public java.lang.String configurationID;
    
    /**
     *The root nodes to export
     */
    public java.util.List<java.lang.String> nodeURLs;
    
  }
  
}


====================
FILE PATH: .\com.stibo.framework-sources\com\stibo\framework\localization\localizer\Localizer.java
====================
package com.stibo.framework.localization.localizer;

/**
 *Interface for localizing of messages having the {@link com.stibo.framework.localization.Localizable} annotation.
 */
public abstract interface Localizer {
  
  /**
   *<p>Localize an object o.
   * <p>If the object has the annotation {@link com.stibo.framework.localization.Localizable}, the object will be formatted according to the format specified there.
   * Otherwise a default formatting will be used, which should not be relied upon.
   * @param o the object to format. Must be able to handle null as input.
   * @return The formatted version of o
   */
  public abstract java.lang.String localize(java.lang.Object o);
  
}


====================
FILE PATH: .\com.stibo.framework-sources\com\stibo\framework\localization\simple\SimpleLocalizerFactory.java
====================
package com.stibo.framework.localization.simple;

/**
 *This factory can be used for obtaining a simple {@link com.stibo.framework.localization.localizer.Localizer} instantiated
 * with a specific locale.
 * The {@link com.stibo.framework.localization.localizer.Localizer} can be used for obtaining locale-specific texts on @{@link com.stibo.framework.localization.Localizable} objects.
 */
public class SimpleLocalizerFactory {
  
  /**
   *Returns a {@link com.stibo.framework.localization.localizer.Localizer} instance set to a specific locale passed as a parameter.
   * @param locale Locale to set on {@link com.stibo.framework.localization.localizer.Localizer}.
   * @return {@link com.stibo.framework.localization.localizer.Localizer} instantiated to a specified locale to be used for localizing objects.
   */
  public com.stibo.framework.localization.localizer.Localizer getLocalizer(java.util.Locale locale) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Delete.java
====================
package com.stibo.gateway.rest;

/**
 *Delete REST request
 */
public abstract interface Delete extends com.stibo.gateway.rest.Request<com.stibo.gateway.rest.Delete> {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Get.java
====================
package com.stibo.gateway.rest;

/**
 *Get REST request
 */
public abstract interface Get extends com.stibo.gateway.rest.Request<com.stibo.gateway.rest.Get> {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Head.java
====================
package com.stibo.gateway.rest;

/**
 *Head REST request
 */
public abstract interface Head extends com.stibo.gateway.rest.Request<com.stibo.gateway.rest.Head> {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Options.java
====================
package com.stibo.gateway.rest;

/**
 *Options REST request
 */
public abstract interface Options extends com.stibo.gateway.rest.Request<com.stibo.gateway.rest.Options> {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Post.java
====================
package com.stibo.gateway.rest;

/**
 *Post REST request
 */
public abstract interface Post extends com.stibo.gateway.rest.RequestWithBody<com.stibo.gateway.rest.Post> {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Put.java
====================
package com.stibo.gateway.rest;

/**
 *Put REST request
 */
public abstract interface Put extends com.stibo.gateway.rest.RequestWithBody<com.stibo.gateway.rest.Put> {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\Request.java
====================
package com.stibo.gateway.rest;

/**
 *Base REST request
 */
public abstract interface Request<T extends com.stibo.gateway.rest.Request> {
  
  /**
   *Add ACCEPT HTTP header for telling which content type we expect HTTP response to be delivered in.
   * Will overwrite any existing ACCEPT header.
   * @param contentType accepted response content type
   * @return this request object
   */
  public abstract T acceptContentType(java.lang.String contentType);
  
  /**
   *Add a HTTP header entry.
   * If value is null then all headers with supplied name will be removed.
   * Will overwrite any existing header with same name.
   * @param name name of HTTP header
   * @param value value of HTTP header
   * @return this request object
   */
  public abstract T header(java.lang.String name,java.lang.String value);
  
  /**
   *Invoke the HTTP request.
   * At this point the request is composed and send to server.
   * Will return the HTTP response.
   * If response HTTP code is below 200 or greater than 299 then a RESTGatewayStatusCodeException is thrown.
   * Otherwise RESTGatewayException could be thrown if IO problems occurred.
   * @return HTTP response as a string
   * @throws com.stibo.gateway.rest.RESTGatewayException thrown if other errors occur.
   */
  public abstract java.lang.String invoke() throws com.stibo.gateway.rest.RESTGatewayException;
  
  /**
   *Invoke the HTTP request.
   * At this point the request is composed and send to server.
   * Will return the HTTP response.
   * If response HTTP code is below 200 or greater than 299 then a RESTGatewayStatusCodeException is thrown.
   * Will also throw a GatewayIntegrationEndpointDisabled if gateway is not enabled.
   * Otherwise RESTGatewayException could be thrown if IO problems occurred.
   * @return HTTP response as a byte array
   * @throws com.stibo.gateway.rest.RESTGatewayException thrown if other errors occur.
   */
  public abstract byte[] invokeBytes() throws com.stibo.gateway.rest.RESTGatewayException;
  
  /**
   *Set the path part of the URL.
   * Will encode characters according the URL standard (using UTF8 charset).
   * Will NOT encode "/" as it is the path element separator.
   * Calling this or pathElements() twice will simply overwrite the path.
   * @param path an array of path elements appended together
   * @return this request object
   * @see T pathElements(String...)
   */
  public abstract T path(java.lang.String path);
  
  /**
   *Set the path part of the URL.
   * Will put a '/' (forward slash) between supplied path elements.
   * Will encode characters according the URL standard (using UTF8 charset).
   * Will also encode "/" characters.
   * Calling this or path() twice will simply overwrite the path.
   * @param path an array of path elements appended together
   * @return this request object
   * @see T path(String)
   */
  public abstract T pathElements(java.lang.String... path);
  
  /**
   *Sets the query part of the URL.
   * Each map entry will expand to "name=value" in URL with correct separators and encoding.
   * Calling this twice will simply overwrite the path query part.
   * @param pathQuery the path query to use
   * @return this request object
   */
  public abstract T pathQuery(java.util.Map<java.lang.String,java.lang.String> pathQuery);
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\RequestWithBody.java
====================
package com.stibo.gateway.rest;

/**
 *Base REST request that carries a body section
 */
public abstract interface RequestWithBody<T extends com.stibo.gateway.rest.RequestWithBody> extends com.stibo.gateway.rest.Request<T> {
  
  /**
   *Will set the body of the HTTP request.
   * Calling either body or urlEncodedBody methods twice will overwrite last body value.
   * @param body body as a byte array
   * @return this request object
   */
  public abstract T body(byte[] body);
  
  /**
   *Will set the body of the HTTP request.
   * Calling either body or urlEncodedBody methods twice will overwrite last body value.
   * @param body body as a string
   * @return this request object
   */
  public abstract T body(java.lang.String body);
  
  /**
   *Will set the content type of the body of the HTTP request.
   * Calling either body or urlEncodedBody methods twice will overwrite last body content type value.
   * @param contentType the content type of the body
   * @return this request object
   */
  public abstract T bodyContentType(java.lang.String contentType);
  
  /**
   *Will set the body of the HTTP request as a URL encoded body.
   * This will also set the content-mime type to "application/x-www-form-urlencoded" - not changing charset of content type.
   * Calling either body or urlEncodedBody methods twice will overwrite last body value.
   * @param body body as a string
   * @return this request object
   */
  public abstract T urlEncodedBody(java.util.Map<java.lang.String,java.lang.String> body);
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\REST.java
====================
package com.stibo.gateway.rest;

/**
 *API for accessing external systems through gateway integration endpoints using REST.
 */
public abstract interface REST {
  
  /**
   *Returns a REST DELETE request object.
   * Build up the request and finally call an invoke method for sending the request.
   * JS Example: delete().path("products").pathQuery({ workspace: "Approved", context: "GL"}).body("Test").invoke();
   * @return request object
   */
  public abstract com.stibo.gateway.rest.Delete delete();
  
  /**
   *Returns a REST GET request object.
   * Build up the request and finally call an invoke method for sending the request.
   * JS Example: get().path("products").pathQuery({ workspace: "Approved", context: "GL"}).invoke();
   * @return request object
   */
  public abstract com.stibo.gateway.rest.Get get();
  
  /**
   *Returns a REST HEAD request object.
   * Build up the request and finally call an invoke method for sending the request.
   * JS Example: head().path("products").pathQuery({ workspace: "Approved", context: "GL"}).invoke();
   * @return request object
   */
  public abstract com.stibo.gateway.rest.Head head();
  
  /**
   *Returns a REST OPTIONS request object.
   * Build up the request and finally call an invoke method for sending the request.
   * JS Example: options().path("products").pathQuery({ workspace: "Approved", context: "GL"}).invoke();
   * @return request object
   */
  public abstract com.stibo.gateway.rest.Options options();
  
  /**
   *Returns a REST POST request object.
   * Build up the request and finally call an invoke method for sending the request.
   * JS Example: post().path("products").pathQuery({ workspace: "Approved", context: "GL"}).invoke();
   * @return request object
   */
  public abstract com.stibo.gateway.rest.Post post();
  
  /**
   *Returns a REST PUT request object.
   * Build up the request and finally call an invoke method for sending the request.
   * JS Example: put().path("products").pathQuery({ workspace: "Approved", context: "GL"}).body("Test").invoke();
   * @return request object
   */
  public abstract com.stibo.gateway.rest.Put put();
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\RESTGatewayException.java
====================
package com.stibo.gateway.rest;

/**
 *Base exception from REST gateway integration endpoints.
 */
public class RESTGatewayException extends java.lang.RuntimeException {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\RESTGatewayIOException.java
====================
package com.stibo.gateway.rest;

/**
 *Exception from REST gateway integration endpoints when invoking HTTP request
 * that produces underlying IO exception.
 */
public class RESTGatewayIOException extends com.stibo.gateway.rest.RESTGatewayException {
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\RESTGatewayStatusCodeException.java
====================
package com.stibo.gateway.rest;

/**
 *Exception from REST gateway integration endpoints when invoking HTTP request
 * that returns HTTP return code outside 200-300 range.
 */
public class RESTGatewayStatusCodeException extends com.stibo.gateway.rest.RESTGatewayException {
  
  /**
   *Get the HTTP status code from the operation
   * @return HTTP status code from the operation
   */
  public int getHttpStatusCode() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.gateway.rest-sources\com\stibo\gateway\rest\exception\RESTGatewayStatusCodeWithBodyException.java
====================
package com.stibo.gateway.rest.exception;

/**
 *Exception from REST gateway integration endpoints when invoking HTTP request
 * that returns HTTP return code outside 200-300 range.
 */
public class RESTGatewayStatusCodeWithBodyException extends com.stibo.gateway.rest.RESTGatewayStatusCodeException {
  
  /**
   *Get the Body of the response
   * @return string response body
   */
  public java.lang.String getBody() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\datamap\GDSNDataMap.java
====================
package com.stibo.gdsn2.domain.datamap;

/**
 *For a Business Action used by the GDSN Provider, this bind is used to get the value of a specific XPath.
 * The XPath value can subsequently be used to retrieve the corresponding string in the GDSN XML file.
 */
public class GDSNDataMap {
  
  /**
   *Get the content of parts of the inbound XML file, by evaluating an XPath expression. The
   * XPath expression is configured for the business action on the GDSN Provider Inbound format
   * configuration. Each XPath configured for the business action is identified by a key.
   *
   * @param key Use the XPath expression configured for the business action identified by this key
   * @return The result as a String of evaluating the XPath or the empty string if the XPath does not evaluate
   */
  public java.lang.String get(java.lang.String key) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Get the content of parts of the inbound XML file, by evaluating an XPath configuration. The
   * XPath configuration is configured for the business action on the GDSN Provider Inbound format
   * configuration and identified by a key.
   *
   * The XPath configuration is in two parts: One that specifies an XPath to a tag in the XML file (called a block) and
   * one that extract the contents of a XML tag given by the tag specified by the first XPath (the block).
   *
   * For each occuriences of the XML block the second XPath is evaluated to a string and the resulting
   * list of strings is returned.
   *
   * @param blockKey Use the XPath block configuration with this key configured for the business action
   * @return The result of evaluting the XPath block configuration on the inbound XML file or the empty list
   */
  public java.util.List<java.lang.String> getBlockValues(java.lang.String blockKey) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\model\GDSNProduct.java
====================
package com.stibo.gdsn2.domain.model;

/**
 *The GDSN Product.
 */
public abstract interface GDSNProduct extends com.stibo.core.domain.Product {
  
  /**
   *Returns the registration for the specified target market and recipient.
   *
   * @param targetMarket the target market to get the registration for
   * @param informationProviderGLN The GLN of the information provider, ie. the data source/publisher that holds and maintain the product information.
   * @return null if there are no registrations for the specified target market and recipient.
   */
  public abstract com.stibo.gdsn2.domain.model.registration.GDSNRegistration getGDSNRegistration(com.stibo.gdsn2.domain.model.configuration.GDSNTargetMarket targetMarket,java.lang.String informationProviderGLN);
  
  /**
   *Accessor for the GDSN registrations associated with this product.
   * @return set containing registrations.
   */
  public abstract java.util.Set<com.stibo.gdsn2.domain.model.registration.GDSNRegistration> getGDSNRegistrations();
  
  /**
   *Accessor for all target markets for which this product has been registered.
   * Will return an empty set if the product has not been registered in any target markets.
   * @return all target markets this product has been registered in or the empty set if the product has not been registered in any target markets yet
   */
  public abstract java.util.Set<com.stibo.gdsn2.domain.model.configuration.GDSNTargetMarket> getGDSNTargetMarkets();
  
  /**
   *Accessor for the Global Trade Item Number (GTIN) of this product.
   * @return the product's GTIN.
   */
  public abstract java.lang.String getProductGTIN();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\model\configuration\GDSNProviderDatapool.java
====================
package com.stibo.gdsn2.domain.model.configuration;

/**
 *The GDSN Data Pool where all where all necessary information to perform business
 * transactions between trading partners is exchanged in a standardized way
 */
public abstract interface GDSNProviderDatapool extends com.stibo.core.domain.entity.Entity {
  
  /**
   *Accessor for the Global Location Number (GLN) of this data pool.
   * @return the GLN of the data pool
   */
  public abstract java.lang.String getPoolGLN();
  
  /**
   *Accessor for the 2 character country code used by GDSN.
   * @param gdsnTargetMarket 2 character country code used by GDSN.
   * @return a target market matching the specified GDSN target market code.
   */
  public abstract com.stibo.gdsn2.domain.model.configuration.GDSNTargetMarket getTargetMarket(java.lang.String gdsnTargetMarket);
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\model\configuration\GDSNRecipient.java
====================
package com.stibo.gdsn2.domain.model.configuration;

/**
 *The GDSN recipient.
 */
public abstract interface GDSNRecipient extends com.stibo.core.domain.entity.Entity {
  
  /**
   *Accessor for the recipients data pool.
   * @return the recipients data pool
   */
  public abstract com.stibo.gdsn2.domain.model.configuration.GDSNProviderDatapool getDatapool();
  
  /**
   *Accessor for the Global Location Number (GLN) of this recipient.
   * @return the GLN of the recipient
   */
  public abstract java.lang.String getRecipientGLN();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\model\configuration\GDSNTargetMarket.java
====================
package com.stibo.gdsn2.domain.model.configuration;

/**
 *The GDSN target market.
 */
public abstract interface GDSNTargetMarket extends com.stibo.core.domain.entity.Entity {
  
  /**
   *Accessor for the country code of this target market.
   * @return the GDSN target market country code
   */
  public abstract java.lang.String getTargetMarketCountryCode();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\model\registration\GDSNRegistration.java
====================
package com.stibo.gdsn2.domain.model.registration;

/**
 *GDSN Registration
 */
public abstract interface GDSNRegistration extends com.stibo.core.domain.entity.Entity {
  
  /**
   *Accessor for the product involved in this this GDSN registration.
   * @return the product of the registration
   */
  public abstract com.stibo.gdsn2.domain.model.GDSNProduct getGDSNProduct();
  
  /**
   *Accessor for the Global Location Number (GLN) of the information provider in this GDSN registration.
   * @return The GLN of the information provider, ie. the data source/publisher that holds and maintain the product information.
   */
  public abstract java.lang.String getInformationProviderGLN();
  
  /**
   *Accessor for the registration status of this GDSN registration.
   * @return the registration status
   */
  public abstract com.stibo.gdsn2.domain.model.registration.GDSNRegistrationStatus getRegistrationStatus();
  
  /**
   *Accessor for the target market of this GDSN registration.
   * @return the target market of the registration
   */
  public abstract com.stibo.gdsn2.domain.model.configuration.GDSNTargetMarket getTargetMarket();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\model\registration\GDSNRegistrationStatus.java
====================
package com.stibo.gdsn2.domain.model.registration;

/**
 *Registration status of this object.
 */
public enum GDSNRegistrationStatus {
  
  /**
   *Not registered.
   */
  Not_Registered, 
  /**
   *Registration Pending.
   */
  Registration_Pending, 
  /**
   *Registration Completed.
   */
  Registration_Completed, 
  /**
   *Registration Failed.
   */
  Registration_Failed, 
  /**
   *Update Pending.
   */
  Update_Pending, 
  /**
   *Update Failed.
   */
  Update_Failed, 
  /**
   *Unregister completed.
   */
  Unregister_Completed, 
  /**
   *To be unregistered.
   */
  To_be_Unregistered, 
  /**
   *Unregister pending.
   */
  Unregister_Pending, 
  /**
   *Unregister failed.
   */
  Unregister_Failed;
  
}


====================
FILE PATH: .\com.stibo.gdsn2.domain-sources\com\stibo\gdsn2\domain\validationlogger\ValidationLogger.java
====================
package com.stibo.gdsn2.domain.validationlogger;

/**
 *ValidationLogger is used to log information from validation conditions during runtime. Messages are written to the
 * background processor logs and products are logged to a separate file for later use.
 */
public abstract interface ValidationLogger {
  
  /**
   *Will write a message to the background processor log and add the product to the failed products list.
   * @param failedProduct a product that has to be added to the failed products list
   * @param messageObject a localized message or String
   */
  public abstract void failedProduct(com.stibo.gdsn2.domain.model.GDSNProduct failedProduct,java.lang.Object messageObject);
  
  /**
   *Will write a message to the background processor log.
   * @param messageObject a localized message or String
   */
  public abstract void logInfo(java.lang.Object messageObject);
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\cicinformationbuilder\CICReviewInformationBuilder.java
====================
package com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder;

/**
 *A builder class for setting the CIC review information for a GDSN product.
 * The builder is created using the setCICReview method on a GDSNReceiverHierarchyMember object.
 * When the needed cic information is set on the builder, the cic information is stored by calling the apply method.
 */
public abstract interface CICReviewInformationBuilder {
  
  /**
   *Applies all values in the builder to the GDSNProduct by setting the CIC review status information for the product.
   * Note this does not set the CIC status code for the product. This is done using the setCICStatus on a GDSNReceiverHierarchyTop node.
   */
  public abstract void apply();
  
  /**
   *Set the additional information that should be set when the CIC review is created for the product
   *
   * @param additionalInformation The new additional information
   *
   * @return The current CICReviewStatusConfiguration
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder.CICReviewInformationBuilder withAdditionalStatusLongDescription(java.lang.String additionalInformation);
  
  /**
   *Set the corrective action information that should be set when the CIC review is create for the product
   *
   * @param correctiveAction The new corrective action
   *
   * @return The current CICReviewStatusConfiguration
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder.CICReviewInformationBuilder withCorrectiveActionCode(java.lang.String correctiveAction);
  
  /**
   *Set the expected corrective information
   *
   * @param expectedCorrectiveInformation The new expected corrective information
   *
   * @return The current CICReviewStatusConfiguration
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder.CICReviewInformationBuilder withExpectedCorrectiveInformation(java.lang.String expectedCorrectiveInformation);
  
  /**
   *Set the CIC status code that should be set when the CIC review is created for the product
   *
   * @param statusCode The new CIC status code
   *
   * @return The current CICReviewStatusConfiguration
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder.CICReviewInformationBuilder withStatusCode(java.lang.String statusCode);
  
  /**
   *The CIC status code description must not be used for CIC status. Attribute was removed from component model.
   * User is not allowed to provide custom value here, since the description is defined by LOV.
   *
   * @param statusCodeDescription The new CIC status code
   *
   * @return The current CICReviewStatusConfiguration
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder.CICReviewInformationBuilder withStatusCodeDescription(java.lang.String statusCodeDescription);
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\cicstatus\CICStatus.java
====================
package com.stibo.gdsn2.receiver.domain.model.cicstatus;

/**
 *The enum represents the possible status values for a CIC object
 */
public enum CICStatus {
  
  /**
   *Use to set the status to RECEIVED
   */
  RECEIVED, 
  /**
   *Use to set the status to REVIEW
   */
  REVIEW, 
  /**
   *Use to set the status to REJECTED
   */
  REJECTED, 
  /**
   *Use to set the status to SYNCHRONISED
   */
  SYNCHRONISED;
  public java.lang.String getId() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\cicstatusbuilder\CICReceivedStatusBuilder.java
====================
package com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder;

/**
 *A builder class for setting the CIC status of a packaging hierarchy to RECEIVED. The status is set, when the apply method
 * is called.
 */
public abstract interface CICReceivedStatusBuilder {
  
  /**
   *Set the CIC status given by the builder.
   */
  public abstract void apply();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\cicstatusbuilder\CICRejectedStatusBuilder.java
====================
package com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder;

/**
 *A builder class for setting the CIC status of a packaging hierarchy to REJECTED. The status is set, when the apply method
 * is called.
 */
public abstract interface CICRejectedStatusBuilder {
  
  /**
   *Set the CIC status given by the builder.
   */
  public abstract void apply();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\cicstatusbuilder\CICReviewStatusBuilder.java
====================
package com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder;

/**
 *A builder class for setting the CIC status of a packaging hierarchy to REVIEW. The status is set, when the apply method
 * is called.
 */
public abstract interface CICReviewStatusBuilder {
  
  /**
   *Set the CIC status given by the builder.
   */
  public abstract void apply();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\cicstatusbuilder\CICSynchronisedStatusBuilder.java
====================
package com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder;

/**
 *A builder class for setting the CIC status of a packaging hierarchy to SYNCHRONISED. The status is set, when the apply method
 * is called.
 */
public abstract interface CICSynchronisedStatusBuilder {
  
  /**
   *Set the CIC status given by the builder.
   */
  public abstract void apply();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\packaging\GDSNReceiverLowerLevelElement.java
====================
package com.stibo.gdsn2.receiver.domain.model.packaging;

/**
 *Describes the elements in a GDSN packaging hierarchy. The class gives a child element in the
 * packaging hierarchy and the quantity of next lower level of the child
 */
public abstract interface GDSNReceiverLowerLevelElement {
  
  /**
   *Get the GDSN product that is a child node in the packaging hierarchy.
   *
   * @return A GDSN product that is a child node in the packaging hierarchy
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverPackagingMember getGDSNPackagingChild();
  
  /**
   *Get the GDSN products that are parent to this node in the packaging hierarchy. If this node is the top node, an empty
   * collection is returned.
   *
   * @return A collection of GDSNReceiverPackingMember that is parents for this node or the empty set if this is the top node
   */
  public abstract java.util.Collection<com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverPackagingMember> getGDSNPackagingParents();
  
  /**
   *Get the quantity of next lower level value for the child node
   *
   * @return The quantity of next lower level value
   */
  public abstract double getGDSNPackagingQuantity();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\packaging\GDSNReceiverPackagingMember.java
====================
package com.stibo.gdsn2.receiver.domain.model.packaging;

/**
 *A Product that is part of the GDSN packaging hierarchy. A GDSN packaging hierarchy consists of a number of GDSNReceiverPackagingMembers.
 * The top node of the packaging hierarchy is also a GDSNReceiverPackagingMember. Use the asTop method to get the top node as a GDSNReceiverPackagingTop.
 */
public abstract interface GDSNReceiverPackagingMember extends com.stibo.core.domain.Product {
  
  /**
   *Get this packing member as a GDSNReceiverPackingTop object, if this is a packaging top. If this is not a packaging top
   * member a null is returned.
   *
   * @return This member as a packaging top if a packaging top, otherwise null
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverPackagingTop asTop();
  
  /**
   *Get the lower level nodes for this GDSN product
   *
   * @return The lower level nodes
   */
  public abstract java.util.Collection<com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverLowerLevelElement> getLowerLevelElements();
  
  /**
   *Get all the packaging top GDSN products for this packaging element
   *
   * @return All top GDSN products for this packaging element
   */
  public abstract java.util.Collection<com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverPackagingTop> getPackagingTopNodes();
  
  /**
   *Set the CIC review information for this GDSN product. This is done by setting the required
   * information on the returned CICReviewStatusBuilder and then call the apply() method on the builder.
   *
   * @return A builder where the CIC review information may be set and applied to the product
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicinformationbuilder.CICReviewInformationBuilder setCICReviewInformation();
  
}


====================
FILE PATH: .\com.stibo.gdsn2.receiver.domain-sources\com\stibo\gdsn2\receiver\domain\model\packaging\GDSNReceiverPackagingTop.java
====================
package com.stibo.gdsn2.receiver.domain.model.packaging;

/**
 *The top GDSN product of a packaging hierarchy
 */
public abstract interface GDSNReceiverPackagingTop extends com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverPackagingMember {
  
  /**
   *Get the CIC status of the packaging hierarchy
   *
   * @return The CIC status of the packaging hierarchy, or null if no CIC status has been set for the product or if the product is not the top of the hierarchy.
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicstatus.CICStatus getPackagingCICStatus();
  
  /**
   *Get all the GDSN products in the packaging hierarchy. Not including the top node.
   *
   * @return All the GDSN products in the packaging hierarchy
   */
  public abstract java.util.Collection<com.stibo.gdsn2.receiver.domain.model.packaging.GDSNReceiverLowerLevelElement> getPackagingHierarchy();
  
  /**
   *Send a CIC message for packaging hierarchy. The CIC review GDSN message will include all review messages for the
   * all products in the packaging hierarchy.
   *
   * The GDSN CIC message will be generated using the given outbound template
   *
   * @param outboundTemplate Use this outbound template when generating the GDSN cic message
   */
  public abstract void sendCIC(java.lang.String outboundTemplate);
  
  /**
   *Clear the review status and the review information for the packaging hierarchy. Should be
   * called when a user have validate that the products in the packaging hierarchy that is out for review
   * have been updated by a CIN import and that the product values now are corrected according to the original
   * CIC review message
   */
  public abstract void setCICReviewDone();
  
  /**
   *Set the CIC status to RECEIVED by returning a CIC status review builder that set the CIC status of the packaging hierarchy
   *
   * @return A review builder that sets the review status of the GDSN product when the apply method on the builder is called.
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder.CICReceivedStatusBuilder setCICStatusToReceived();
  
  /**
   *Set the CIC status to REJECTED by returning a CIC status review builder that set the CIC status of the packaging hierarchy
   *
   * @return A review builder that sets the review status of the GDSN product when the apply method on the builder is called.
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder.CICRejectedStatusBuilder setCICStatusToRejected();
  
  /**
   *Set the CIC status to REVIEW by returning a CIC status review builder that set the CIC status of the packaging hierarchy
   *
   * @return A review builder that sets the review status of the GDSN product when the apply method on the builder is called.
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder.CICReviewStatusBuilder setCICStatusToReview();
  
  /**
   *Set the CIC status to SYNCHRONISED by returning a CIC status review builder that set the CIC status of the packaging hierarchy
   *
   * @return A review builder that sets the review status of the GDSN product when the apply method on the builder is called.
   */
  public abstract com.stibo.gdsn2.receiver.domain.model.cicstatusbuilder.CICSynchronisedStatusBuilder setCICStatusToSynchronised();
  
}


====================
FILE PATH: .\com.stibo.integration.kafka.domain-sources\com\stibo\integration\kafka\domain\metadata\ConsumerRecord.java
====================
package com.stibo.integration.kafka.domain.metadata;

/**
 *Metadata class matching the methods on org.apache.kafka.clients.consumer.ConsumerRecord except for value
 * as that's the content of the message.
 */
public abstract interface ConsumerRecord extends com.stibo.core.domain.integrationendpoint.streaming.domain.StreamingMessageMetadata {
  
  /**
   *Headers Iterable
   * @return headers
   */
  public abstract com.stibo.integration.kafka.domain.metadata.Headers headers();
  
  /**
   *Get the UTF-8 encoded key for this record.
   * Will only work for UTF-8 encoded keys.
   * @return key
   */
  public abstract java.lang.String key();
  
  /**
   *Get offset of this message
   * @return offset
   */
  public abstract long offset();
  
  /**
   *Get partion this message came from
   * @return partition
   */
  public abstract int partition();
  
  /**
   *Get Kafka Topic name
   * @return kafka topic
   */
  public abstract java.lang.String topic();
  
}


====================
FILE PATH: .\com.stibo.integration.kafka.domain-sources\com\stibo\integration\kafka\domain\metadata\Header.java
====================
package com.stibo.integration.kafka.domain.metadata;

/**
 *interface matching org.apache.kafka.common.header.Header
 */
public abstract interface Header {
  
  /**
   *Get the key
   * @return String
   */
  public abstract java.lang.String key();
  
  /**
   *Get the value
   * @return byte[]
   */
  public abstract byte[] value();
  
}


====================
FILE PATH: .\com.stibo.integration.kafka.domain-sources\com\stibo\integration\kafka\domain\metadata\Headers.java
====================
package com.stibo.integration.kafka.domain.metadata;

/**
 *Headers class equivalent of Kafka org.apache.kafka.common.header.Header.Headers class
 */
public abstract class Headers implements java.lang.Iterable<com.stibo.integration.kafka.domain.metadata.Header> {
  
}


====================
FILE PATH: .\com.stibo.lookuptable-sources\com\stibo\lookuptable\domain\LookupTableHome.java
====================
package com.stibo.lookuptable.domain;

/**
 *Home for transformation look-up tables.
 * Transformation look-up tables are Assets which can be used as look-up tables,
 * with inner mappings from input values to output values.
 */
public abstract interface LookupTableHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Returns lookup value in transformation look-up table inside Asset with supplied identifier.
   * @param assetID The identifier of the Asset containing the transformation look-up table.
   * @param value The value which should be looked up in the look-up table.
   * @return The associated value from the look-up table for the value.
   */
  public abstract java.lang.String getLookupTableValue(java.lang.String assetID,java.lang.String value);
  
}


====================
FILE PATH: .\com.stibo.mail-sources\com\stibo\mail\domain\Attachment.java
====================
package com.stibo.mail.domain;

/**
 *Class responsible for creating and adding attachments to mail.
 */
public abstract interface Attachment {
  
  /**
   *Attaches new attachment to mail currently being built
   * based on the provided data.
   * @return mail
   */
  public abstract com.stibo.mail.domain.Mail attach();
  
  /**
   *Sets a description for the attachment (optional).
   * @param description attachment description
   * @return current attachment
   */
  public abstract com.stibo.mail.domain.Attachment description(java.lang.String description);
  
  /**
   *Sets the attachment content to be the content of the
   * supplied asset overwriting any existing content. If the
   * asset has no content then nothing is done (no content is saved,
   * if there exists previous content it won't be deleted).
   * @param asset asset to add content from
   * @return current attachment
   */
  public abstract com.stibo.mail.domain.Attachment fromAsset(com.stibo.core.domain.Asset asset);
  
  /**
   *Sets the attachment content to be the content of the supplied
   * WorkflowAttachmentContent overwriting any existing content.
   * @param workflowAttachmentContent workflow attachment content
   * @return current attachment
   */
  public abstract com.stibo.mail.domain.Attachment fromWorkflowAttachmentContent(com.stibo.core.domain.state.WorkflowAttachmentContent workflowAttachmentContent);
  
  /**
   *Sets a name for the attachment.
   * @param name attachment name
   * @return current attachment
   */
  public abstract com.stibo.mail.domain.Attachment name(java.lang.String name);
  
}


====================
FILE PATH: .\com.stibo.mail-sources\com\stibo\mail\domain\Mail.java
====================
package com.stibo.mail.domain;

/**
 *Builder-style interface for creating and sending mails.
 */
public abstract interface Mail {
  
  /**
   *Adds a blind carbon copy recipient (if address is already on
   * list it won't be duplicated).
   * @param emailAddress valid mail address
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail addBcc(java.lang.String emailAddress);
  
  /**
   *Adds a blind carbon copy recipient (if address is already on
   * list it won't be duplicated).
   * @param emailAddress valid mail address
   * @param name name of the recipient
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail addBcc(java.lang.String emailAddress,java.lang.String name);
  
  /**
   *Adds a carbon copy recipient (if address is already on
   * list it won't be duplicated).
   * @param emailAddress valid mail address
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail addCc(java.lang.String emailAddress);
  
  /**
   *Adds a carbon copy recipient (if address is already on
   * list it won't be duplicated).
   * @param emailAddress valid mail address
   * @param name name of the recipient
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail addCc(java.lang.String emailAddress,java.lang.String name);
  
  /**
   *Adds a recipient (if address is already on list it
   * won't be duplicated).
   * @param emailAddress valid mail address
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail addTo(java.lang.String emailAddress);
  
  /**
   *Adds a recipient (if address is already on list it
   * won't be duplicated).
   * @param emailAddress valid mail address
   * @param name name of the recipient
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail addTo(java.lang.String emailAddress,java.lang.String name);
  
  /**
   *Starts the subprocess to create a new attachment
   * and attach it to mail.
   * @return attachment
   */
  public abstract com.stibo.mail.domain.Attachment attachment();
  
  /**
   *Sets the sender overriding any previously set address.
   * If no sender is set, STEP will attempt to use the value of
   * the configuration property "Mail.DefaultFromMailAddress".
   * @param emailAddress valid mail address
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail from(java.lang.String emailAddress);
  
  /**
   *Sets the sender overriding any previously set address.
   * If no sender is set, STEP will attempt to use the value of
   * the configuration property "Mail.DefaultFromMailAddress".
   * @param emailAddress valid mail address
   * @param name name of the sender
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail from(java.lang.String emailAddress,java.lang.String name);
  
  /**
   *Sets the mail body to the supplied HTML text overriding
   * any previously set message body text.
   * @param htmlMessage html message
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail htmlMessage(java.lang.String htmlMessage);
  
  /**
   *Sets the mail body to the supplied plain text overriding
   * any previously set message body text.
   * @param plainMessage plain message text
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail plainMessage(java.lang.String plainMessage);
  
  /**
   *Sends the mail using the SMTP server specified with the "Mail.MailServerURL" configuration property.
   * @throws java.lang.RuntimeException when created email is invalid or an error occurred when sending the email
   */
  public abstract void send() throws java.lang.RuntimeException;
  
  /**
   *Sets the supplied text as the mail subject overriding
   * any previously set mail subject.
   * @param subject mail subject
   * @return current mail
   */
  public abstract com.stibo.mail.domain.Mail subject(java.lang.String subject);
  
}


====================
FILE PATH: .\com.stibo.mail-sources\com\stibo\mail\home\MailHome.java
====================
package com.stibo.mail.home;

/**
 *Main interface for mail related functionality.
 */
public abstract interface MailHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Method for obtaining a Mail instance used for creating and sending a mail.
   * @return mail instance
   */
  public abstract com.stibo.mail.domain.Mail mail();
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\goldenrecord\merged\MergedGoldenRecord.java
====================
package com.stibo.matching.domain.goldenrecord.merged;

/**
 *Represents the golden record used in Merge Golden Record match action
 */
public abstract interface MergedGoldenRecord extends com.stibo.core.domain.RevisableNode {
  
  /**
   *This method allows adding source information to a merge golden record.
   * This does not add any underlying source record data and will not create
   * source revisions.
   * See 'Unmerging source records without any underlying source record data' in the Online Help
   * @param sourceSystemID ID of the source system
   * @param sourceRecordID source record ID
   */
  public abstract void addSourceInformation(java.lang.String sourceSystemID,java.lang.String sourceRecordID);
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\goldenrecord\merged\home\MergedGoldenRecordHome.java
====================
package com.stibo.matching.domain.goldenrecord.merged.home;

/**
 *Home for merge golden record utility methods
 */
public abstract interface MergedGoldenRecordHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Search the database for not-deactivated Merge Golden Record with specified source information
   * If more than one record matches the criteria the oldest (first entered in database) will be returned
   * @param sourceSystemID STEP ID of Source System record. Required value; omitting will produce null-result.
   * @param sourceRecordID Source Record ID. Required value; omitting will produce null-result.
   * @param goldenRecordObjectType Required object-type for of the requested Golden Record.
   *                               Omitting will produce null-result.
   *                               Must be Merged Golden Record object type or exception will be thrown
   * @return the oldest Golden Record matching the criteria or null
   */
  public abstract com.stibo.core.domain.Node getGoldenRecordBySourceInformation(java.lang.String sourceSystemID,java.lang.String sourceRecordID,com.stibo.core.domain.ObjectType goldenRecordObjectType);
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\javascript\MatchingFunctionsContext.java
====================
package com.stibo.matching.domain.javascript;

/**
 *Interface providing matching functions that can
 * be used to define difference between compared nodes
 * during matching phase
 */
public abstract interface MatchingFunctionsContext {
  
  /**
   *Damerau Levenshtein Distance between first and second
   * @param first first element to calculate distance
   * @param second second element to calculate distance
   * @return Damerau Levenshtein Distance between first and second
   *
   * @see <a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance</a>
   */
  public abstract int damerauLevenshteinDistance(java.lang.String first,java.lang.String second);
  
  /**
   *Damerau Levenshtein Distance between first and second with limited by limit
   * @param first first element to calculate distance
   * @param second second element to calculate distance
   * @param limit limit on maximum distance between calculated elements
   * @return Damerau Levenshtein Distance between first and second limited by limit
   *
   * @see <a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance</a>
   */
  public abstract int damerauLevenshteinDistanceLimited(java.lang.String first,java.lang.String second,int limit);
  
  /**
   *Levenshtein Distance between first and second
   * @param first first element to calculate distance
   * @param second second element to calculate distance
   * @return Levenshtein Distance between first and second
   *
   * @see <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">https://en.wikipedia.org/wiki/Levenshtein_distance</a>
   */
  public abstract int levenshteinDistance(java.lang.String first,java.lang.String second);
  
  /**
   *Levenshtein Distance between first and second with limited by limit
   * @param first first element to calculate distance
   * @param second second element to calculate distance
   * @param limit limit on maximum distance between calculated elements
   * @return Levenshtein Distance between first and second limited by limit
   *
   * @see <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">https://en.wikipedia.org/wiki/Levenshtein_distance</a>
   */
  public abstract int levenshteinDistanceLimited(java.lang.String first,java.lang.String second,int limit);
  
  /**
   *Convert string to metaphone3
   * @param string element to be indexed by their English pronunciation
   * @return metaphone value of string.
   *
   * @see <a href="https://en.wikipedia.org/wiki/Metaphone">https://en.wikipedia.org/wiki/Metaphone</a>
   */
  public abstract java.lang.String metaphone3(java.lang.String string);
  
  /**
   *Convert string to alternate metaphone3
   * @param string element to be indexed by its English pronunciation
   * @return alternate metaphone value of string.
   */
  public abstract java.lang.String metaphone3alternate(java.lang.String string);
  
  /**
   *Convert string to soundex
   * @param string element to be indexed by sound
   * @return Soundex value of string.
   *
   * @see <a href="https://en.wikipedia.org/wiki/Soundex">https://en.wikipedia.org/wiki/Soundex</a>
   */
  public abstract java.lang.String soundex(java.lang.String string);
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\matchexpression\MatchExpressionContext.java
====================
package com.stibo.matching.domain.matchexpression;

/**
 *The Expression Context is used when evaluating a match expression. It provides access to the two nodes that are
 * to be compared.
 * When doing a comparison, one object is called FIRST and the other is called SECOND.
 * There is no guarantee which becomes FIRST or SECOND, but the roles are fixed for all
 * expressions involved during the comparison of two objects.
 */
public abstract interface MatchExpressionContext {
  
  /**
   *Evaluate and expression in the current object context
   * @param expressionID ID of an expression to evaluate
   * @return Result of the evaluation
   */
  public abstract java.lang.Object evaluate(java.lang.String expressionID);
  
  /**
   *Evaluate an expression in a given context.
   * This version of evaluate is primarily a convenience for JavaScript - contextObject can be supplied as a string.
   * @param expressionID ID of an expression to evaluate
   * @param contextObject the object in which context the expression must be evaluated, either "first" or "second".
   * @return Result of the evaluation.
   */
  public abstract java.lang.Object evaluate(java.lang.String expressionID,java.lang.String contextObject);
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\matchexpression\businessfunction\comparator\MatchResult.java
====================
package com.stibo.matching.domain.matchexpression.businessfunction.comparator;

/**
 *Support for return type as a matching score from the Business Function.
 * 
 * Example:
 *
 * <pre>{@code
 *     var result = new com.stibo.matching.domain.matchexpression.businessfunction.comparator.MatchResult();
 *     result.withScore(42);
 *     return result;
 *
 * }</pre>
 */
public class MatchResult {
  
  /**
   *Returns the score of the match result
   *
   * @return This MatchResult's score
   */
  public double getScore() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Sets the score of the match result
   *
   * @param score The score of the match result
   *
   * @return This MatchResult
   */
  public com.stibo.matching.domain.matchexpression.businessfunction.comparator.MatchResult withScore(double score) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Empty constructor for a return type with a match score. Sets the initial score to 0.
   */
  public MatchResult() {}
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\matchingalgorithm\MatchingAlgorithmAspect.java
====================
package com.stibo.matching.domain.matchingalgorithm;

/**
 *Interface for Matching Algorithm.
 */
public abstract interface MatchingAlgorithmAspect extends com.stibo.core.domain.Node {
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\matchingalgorithm\MatchingAlgorithmHome.java
====================
package com.stibo.matching.domain.matchingalgorithm;

/**
 *Home for Matching Algorithm.
 */
public abstract interface MatchingAlgorithmHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Returns the MatchingAlgorithm object corresponding to the identifier supplied.
   * @param id The identifier of the MatchingAlgorithm object.
   * @return The appropriate MatchingAlgorithm object or <code>null</code> if not found.
   */
  public abstract com.stibo.matching.domain.matchingalgorithm.MatchingAlgorithmAspect getMatchingAlgorithmByID(java.lang.String id);
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\rankscorable\RankScorable.java
====================
package com.stibo.matching.domain.rankscorable;

/**
 *Represents a node that can be matched to other nodes by a matching algorithm.
 */
public abstract interface RankScorable extends com.stibo.core.domain.RevisableNode {
  
  /**
   *Get all rank scores with this node in given Matching Algorithm
   * Will not return rankscores if confirmed duplicate or non-duplicate exists for pair.
   * @param matchingAlgorithm the duplicate matchingAlgorithm
   * @return rank scores
   */
  public abstract java.util.Collection<com.stibo.matching.domain.rankscorable.RankScore> getRankScores(com.stibo.matching.domain.matchingalgorithm.MatchingAlgorithmAspect matchingAlgorithm);
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\rankscorable\RankScore.java
====================
package com.stibo.matching.domain.rankscorable;

/**
 *Represent a comparison of two objects with a given Matching Algorithm.
 */
public abstract interface RankScore {
  
  /**
   *Get how well the nodes compared.
   * NOTE: this method returns a Java native double.
   * So be aware of potential rounding problems when comparing this number to another number.
   * Especially be careful if doing calculations with number and using the == operator -
   * in such cases double-rounding might produce un-expected results.
   * @return number indicating how well nodes compared.
   */
  public abstract double getEquality();
  
  /**
   *Get one of the nodes in this comparison.
   * @return node
   */
  public abstract com.stibo.matching.domain.rankscorable.RankScorable getNode1();
  
  /**
   *Get the other node in this comparison.
   * @return node
   */
  public abstract com.stibo.matching.domain.rankscorable.RankScorable getNode2();
  
}


====================
FILE PATH: .\com.stibo.matching.domain-sources\com\stibo\matching\domain\survivorshipbind\SurvivorshipContext.java
====================
package com.stibo.matching.domain.survivorshipbind;

/**
 *A bind for javascript business action survivorship rule that make it possible to detect most recent between nodes and data container objects.
 */
public abstract interface SurvivorshipContext {
  
  /**
   *Gets DataContainerObject where attribute is most recent from both data containers. it's optional to supply a last edit date attribute
   * @param target DataContainer to be compared to source
   * @param source DataContainer to be compared to target
   * @param attribute the attribute to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @param incomingEmptyValues If true, any empty values (e.g. <Value AttributeID="XYZ"></Value>) in incoming records will be used to determine most recent value for the data container attribute. If false, it will ignore empty values for most recent.
   *
   * @return most recent DataContainerObject
   */
  public abstract com.stibo.core.domain.datacontainerobject.DataContainerObject getMostRecentDCAttribute(com.stibo.core.domain.datacontainerobject.DataContainerObject target,com.stibo.core.domain.datacontainerobject.DataContainerObject source,com.stibo.core.domain.Attribute attribute,com.stibo.core.domain.Attribute lastEditDateAttribute,boolean incomingEmptyValues);
  
  /**
   *Gets DataContainerObject where attribute is most recent from both data containers. it's optional to supply a last edit date attribute
   * @param target DataContainer to be compared to source
   * @param source DataContainer to be compared to target
   * @param attributeGroup the attribute group to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @param incomingEmptyValues If true, any empty values (e.g. <Value AttributeID="XYZ"></Value>) in incoming records will be used to determine most recent value for the data container attribute. If false, it will ignore empty values for most recent.
   *
   * @return most recent DataContainerObject
   */
  public abstract com.stibo.core.domain.datacontainerobject.DataContainerObject getMostRecentDCAttributeGroup(com.stibo.core.domain.datacontainerobject.DataContainerObject target,com.stibo.core.domain.datacontainerobject.DataContainerObject source,com.stibo.core.domain.AttributeGroup attributeGroup,com.stibo.core.domain.Attribute lastEditDateAttribute,boolean incomingEmptyValues);
  
  /**
   *Gets node where dataContainerType is most recent from both data containers. it's optional to supply a last edit date attribute
   * @param target DataContainer to be compared to source
   * @param source DataContainer to be compared to target
   * @param referenceType the reference type to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @return most recent DataContainerObject
   */
  public abstract com.stibo.core.domain.datacontainerobject.DataContainerObject getMostRecentDCRefType(com.stibo.core.domain.datacontainerobject.DataContainerObject target,com.stibo.core.domain.datacontainerobject.DataContainerObject source,com.stibo.core.domain.ReferenceType referenceType,com.stibo.core.domain.Attribute lastEditDateAttribute);
  
  /**
   *Gets node where attribute is most recent from both nodes. it's optional to supply a last edit date attribute
   * @param target node to be compared to source
   * @param source node to be compared to target
   * @param attribute the attribute to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @param incomingEmptyValues If true, any empty values (e.g. <Value AttributeID="XYZ"></Value>) in incoming records will be used to determine most recent value for the attribute. If false, it will ignore empty values for most recent.
   * @return most recent node
   */
  public abstract com.stibo.core.domain.Node getMostRecentNodeAttribute(com.stibo.core.domain.Node target,com.stibo.core.domain.Node source,com.stibo.core.domain.Attribute attribute,com.stibo.core.domain.Attribute lastEditDateAttribute,boolean incomingEmptyValues);
  
  /**
   *Gets node where attribute is most recent from both nodes. it's optional to supply a last edit date attribute
   * @param target node to be compared to source
   * @param source node to be compared to target
   * @param attributeGroup the attribute group to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @param incomingEmptyValues If true, any empty values (e.g. <Value AttributeID="XYZ"></Value>) in incoming records will be used to determine most recent value for the attribute. If false, it will ignore empty values for most recent.
   * @return most recent node
   */
  public abstract com.stibo.core.domain.Node getMostRecentNodeAttributeGroup(com.stibo.core.domain.Node target,com.stibo.core.domain.Node source,com.stibo.core.domain.AttributeGroup attributeGroup,com.stibo.core.domain.Attribute lastEditDateAttribute,boolean incomingEmptyValues);
  
  /**
   *Gets node where dataContainerType is most recent from both nodes. it's optional to supply a last edit date attribute
   * @param target node to be compared to source
   * @param source node to be compared to target
   * @param dataContainerType the data container type to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @return most recent node
   */
  public abstract com.stibo.core.domain.Node getMostRecentNodeDCType(com.stibo.core.domain.Node target,com.stibo.core.domain.Node source,com.stibo.core.domain.datacontainertype.DataContainerType dataContainerType,com.stibo.core.domain.Attribute lastEditDateAttribute);
  
  /**
   *Gets node where referenceType is most recent from both nodes. it's optional to supply a last edit date attribute
   * @param target node to be compared to source
   * @param source node to be compared to target
   * @param referenceType the reference type to check for newest change
   * @param lastEditDateAttribute optional date attribute containing a last edit date or null if no date is available. If there are a manual edit that are newer than
   *                              the date in LastEditDateAttribute, it will use the manual edit date instead.
   * @return most recent node
   */
  public abstract com.stibo.core.domain.Node getMostRecentNodeRefType(com.stibo.core.domain.Node target,com.stibo.core.domain.Node source,com.stibo.core.domain.ReferenceType referenceType,com.stibo.core.domain.Attribute lastEditDateAttribute);
  
  /**
   *Checks if this survivorship rule is currently in a merge scenario.
   * @return Return true in context of merge of existing golden records or when match and merge importer associates an incoming Entity with an existing golden record by match scoring above auto-link threshold.
   * Return false in the context of update to an existing golden record by STEP object ID or Source Record ID during import via Match and Merge Importer.
   */
  public abstract boolean isMerge();
  
}


====================
FILE PATH: .\com.stibo.outbound.businessactionpreprocessor-sources\com\stibo\outbound\businessactionpreprocessor\Event.java
====================
package com.stibo.outbound.businessactionpreprocessor;

/**
 *Event representing the modification of a node.
 */
public abstract interface Event {
  
  /**
   *Will return the node this event is about. It will be returned by manager set to workspace/context corresponding
   * to the exported data.
   * @return The node this event is about
   */
  public abstract com.stibo.core.domain.Node getNode();
  
  /**
   *Access the event type of the event
   * @return The event type of the event
   */
  public abstract com.stibo.core.domain.eventqueue.SimpleEventType getSimpleEventType();
  
}


====================
FILE PATH: .\com.stibo.outbound.businessactionpreprocessor-sources\com\stibo\outbound\businessactionpreprocessor\EventBatch.java
====================
package com.stibo.outbound.businessactionpreprocessor;

/**
 *A batch that used when an event queue is selected as data source for an outbound integration endpoint.
 * Can be bound as java script variable by selecting Current Event Batch
 */
public abstract interface EventBatch {
  
  /**
   *Add a new node that will be exported in addition to the events in the batch.
   * @param newNode Add this node to the batch so it is exported when the events in the batch is exported - null will be skipped
   */
  public abstract void addAdditionalNode(com.stibo.core.domain.Node newNode);
  
  /**
   *Return a read-only view of the events in the batch.
   * @return a read-only list of events in the event batch
   */
  public abstract java.util.List<com.stibo.outbound.businessactionpreprocessor.Event> getEvents();
  
  /**
   *Remove the specified event the events in the batch. The event that is requested to be removed
   * has to be one of the events in the batch.
   * @param eventToRemove Remove this event from the events in the batch
   */
  public abstract void removeEvent(com.stibo.outbound.businessactionpreprocessor.Event eventToRemove);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\address\Address.java
====================
package com.stibo.partydatamatching.domain.address;

/**
 *Represent a Address in party data matching
 */
public abstract interface Address {
  
  /**
   *Get the city on the address object
   * @return the city
   */
  public abstract java.lang.String getCity();
  
  /**
   *Get the country on the address object
   * @return the country
   */
  public abstract java.lang.String getCountry();
  
  /**
   *Get the country ISO on the address object
   * @return the country ISO in ISO 3166-1 alpha-2
   */
  public abstract java.lang.String getCountryISO();
  
  /**
   *Get the postcode on the address object
   * @return the postcode
   */
  public abstract java.lang.String getPostcode();
  
  /**
   *Get the region on the address object
   * @return the region
   */
  public abstract java.lang.String getRegion();
  
  /**
   *Get the full street information on the address object, every address element bellow postcode will end up here
   * @return the street
   */
  public abstract java.lang.String getStreet();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\address\AddressBuilder.java
====================
package com.stibo.partydatamatching.domain.address;

/**
 *Address builder use for building address objects in party data matching
 */
public abstract interface AddressBuilder {
  
  /**
   *build the address
   *
   * @return the built address
   */
  public abstract com.stibo.partydatamatching.domain.address.Address build();
  
  /**
   *Set City on the Address object
   * @param city the city
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder setCity(java.lang.String city);
  
  /**
   *Set Country on the Address object
   * @param country the country
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder setCountry(java.lang.String country);
  
  /**
   *Set CountryISO on the Address object
   * @param countryISO the countryISO
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder setCountryISO(java.lang.String countryISO);
  
  /**
   *Set Postcode on the Address object
   * @param postcode the postcode
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder setPostcode(java.lang.String postcode);
  
  /**
   *Set Region on the Address object
   * @param region the region
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder setRegion(java.lang.String region);
  
  /**
   *Set the full street information on the Address object, the full street contains every address element bellow postcode
   * @param street the street
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder setStreet(java.lang.String street);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\email\Email.java
====================
package com.stibo.partydatamatching.domain.email;

/**
 *Represent an Email in party data matching
 */
public abstract interface Email {
  
  /**
   *Get the Email
   * @return the email
   */
  public abstract java.lang.String getEmail();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\email\EmailBuilder.java
====================
package com.stibo.partydatamatching.domain.email;

/**
 *Builder for Email party data matching
 */
public abstract interface EmailBuilder {
  
  /**
   *Build organization name object
   *
   * @return Email object
   */
  public abstract com.stibo.partydatamatching.domain.email.Email build();
  
  /**
   *Set the organization email
   *
   * @param email value
   * @return this
   */
  public abstract com.stibo.partydatamatching.domain.email.EmailBuilder setEmail(java.lang.String email);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\home\PartyDataMatchingHome.java
====================
package com.stibo.partydatamatching.domain.home;

/**
 *Party data matching home
 */
public abstract interface PartyDataMatchingHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Create Address builder object
   *
   * @return AddressBuilder object for further building
   */
  public abstract com.stibo.partydatamatching.domain.address.AddressBuilder createAddress();
  
  /**
   *Create Email builder object
   *
   * @return EmailBuilder object for further building
   */
  public abstract com.stibo.partydatamatching.domain.email.EmailBuilder createEmail();
  
  /**
   *Create Name builder object
   *
   * @return NameBuilder object for further building
   */
  public abstract com.stibo.partydatamatching.domain.name.NameBuilder createName();
  
  /**
   *Create Organization Name builder object
   *
   * @return OrganizationNameBuilder object for further building
   */
  public abstract com.stibo.partydatamatching.domain.organizationname.OrganizationNameBuilder createOrganizationName();
  
  /**
   *Create Phone builder object
   *
   * @return PhoneBuilder object for further building
   */
  public abstract com.stibo.partydatamatching.domain.phone.PhoneBuilder createPhone();
  
  /**
   *Create StdAddress builder object
   *
   * @return StdAddressBuilder object for further building
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder createStandardizedAddress();
  
  /**
   *Retrieves alias groups for a given word from an asset holding nickname lookup tables
   *
   * @param asset The asset from which alias groups are to be retrieved
   * @param word 	The word for which alias groups are to be obtained
   * @return A Set containing Lists of Strings representing alias groups associated with the input word.
   * 		   Returns an empty Set if no alias groups are found for the given word in the specified asset.
   */
  public abstract java.util.Set<java.util.List<java.lang.String>> getAliasGroups(com.stibo.core.domain.Asset asset,java.lang.String word);
  
  /**
   *parse phone string and create Phone object
   *
   * @param numberToParse     number that we are attempting to parse. This can contain formatting such
   *                          as <pre>+</pre>, <pre>(</pre> and -, as well as a phone number extension. It can also be provided in RFC3966
   *                          format.
   * @param defaultCountryISO region that we are expecting the number to be from. This is only used if
   *                          the number being parsed is not written in international format. The country_code for the
   *                          number in this case would be stored as that of the default region supplied. If the number
   *                          is guaranteed to start with a '+' followed by the country calling code, then Null can be supplied if no country code is known.
   *                          It is  possible to provide country by country ISO code in ISO 3166-1 alpha-2 or country calling code
   * @return return phone object. If phone object country code is empty then the parsing went wrong and the national number contains the input string
   */
  public abstract com.stibo.partydatamatching.domain.phone.Phone parsePhone(java.lang.String numberToParse,java.lang.String defaultCountryISO);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\name\Name.java
====================
package com.stibo.partydatamatching.domain.name;

/**
 *Represent a individual name in party data matching
 */
public abstract interface Name {
  
  /**
   *Get the First Name on the name object
   * @return the first name
   */
  public abstract java.lang.String getFirstName();
  
  /**
   *Get the Last Name on the name object
   * @return the last name
   */
  public abstract java.lang.String getLastName();
  
  /**
   *Get the Middle Name on the name object
   * @return the middle name
   */
  public abstract java.lang.String getMiddleName();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\name\NameBuilder.java
====================
package com.stibo.partydatamatching.domain.name;

/**
 *Name builder use for building name objects in party data matching
 */
public abstract interface NameBuilder {
  
  /**
   *build the name
   *
   * @return the built name
   */
  public abstract com.stibo.partydatamatching.domain.name.Name build();
  
  /**
   *Set First Name on the Name object
   *
   * @param firstName the first name
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.name.NameBuilder setFirstName(java.lang.String firstName);
  
  /**
   *Set Last Name on the Name object
   *
   * @param lastName the last name
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.name.NameBuilder setLastName(java.lang.String lastName);
  
  /**
   *Set Middle Name on the Name object
   *
   * @param middleName the middle name
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.name.NameBuilder setMiddleName(java.lang.String middleName);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\normalizer\NormalizedValue.java
====================
package com.stibo.partydatamatching.domain.normalizer;

/**
 *Value after normalization process. Intent to store both values after normalisation: original one and normalized.
 * <p>
 * getSource - value before normalization
 * getNormalizedValue - normalized value
 */
public abstract interface NormalizedValue<T extends java.lang.Object> {
  
  /**
   *Returns normalized value.
   *
   * @return normalized value
   */
  public abstract T getNormalizedValue();
  
  /**
   *Returns original value before normalization. If the value being normalized several times with a different normalizers, it is expected that first (original) value being returned.
   *
   * @return value before normalization
   */
  public abstract T getSource();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\normalizer\NormalizedValueBuilder.java
====================
package com.stibo.partydatamatching.domain.normalizer;

/**
 *Builder for Normalized Value party data matching
 */
public abstract interface NormalizedValueBuilder<T extends java.lang.Object> {
  
  /**
   *Build NormalizedValue object
   *
   * @return NormalizedValue object
   */
  public abstract com.stibo.partydatamatching.domain.normalizer.NormalizedValue<T> build();
  
  /**
   *Set normalized value
   *
   * @param value normalized value
   *
   * @return this
   */
  public abstract com.stibo.partydatamatching.domain.normalizer.NormalizedValueBuilder<T> setNormalizedValue(T value);
  
  /**
   *Set original value being normalized
   *
   * @param value source value
   *
   * @return this
   */
  public abstract com.stibo.partydatamatching.domain.normalizer.NormalizedValueBuilder<T> setSourceValue(T value);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\organizationname\OrganizationName.java
====================
package com.stibo.partydatamatching.domain.organizationname;

/**
 *Represent an Organization Name in party data matching
 */
public abstract interface OrganizationName {
  
  /**
   *Get the Organization Name
   * @return the organization name
   */
  public abstract java.lang.String getOrganizationName();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\organizationname\OrganizationNameBuilder.java
====================
package com.stibo.partydatamatching.domain.organizationname;

/**
 *Organization Name builder use for building organziation name objects in party data matching
 */
public abstract interface OrganizationNameBuilder {
  
  /**
   *Build organization name object
   *
   * @return OrganizationName object
   */
  public abstract com.stibo.partydatamatching.domain.organizationname.OrganizationName build();
  
  /**
   *Set the organization name
   *
   * @param name organization name
   */
  public abstract com.stibo.partydatamatching.domain.organizationname.OrganizationNameBuilder setOrganizationName(java.lang.String name);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\phone\Phone.java
====================
package com.stibo.partydatamatching.domain.phone;

/**
 *Represent a Phone number in party data matching
 */
public abstract interface Phone {
  
  /**
   *Get the Country Code on the phone object
   * @return the country code
   */
  public abstract java.lang.String getCountryCode();
  
  /**
   *Get the National Number on the phone object
   * @return the National Number code
   */
  public abstract java.lang.String getNationalNumber();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\phone\PhoneBuilder.java
====================
package com.stibo.partydatamatching.domain.phone;

/**
 *Phone builder use for building phone objects in party data matching
 */
public abstract interface PhoneBuilder {
  
  /**
   *build the phone
   *
   * @return the built phone
   */
  public abstract com.stibo.partydatamatching.domain.phone.Phone build();
  
  /**
   *Set Country Code on phone object
   *
   * @param countryCode must be a number or empty
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.phone.PhoneBuilder setCountryCode(java.lang.String countryCode);
  
  /**
   *Set National Number on phone object
   *
   * @param nationalNumber the national number
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.phone.PhoneBuilder setNationalNumber(java.lang.String nationalNumber);
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\stdaddress\StandardizedAddress.java
====================
package com.stibo.partydatamatching.domain.stdaddress;

/**
 *Builds an instance of {@link StandardizedAddress} with the set fields.
 * <p>
 * The following table describes the mapping of address components:
 * </p>
 * <table border="1">
 *   <tr>
 *     <th>Address Component</th>
 *     <th>Comment</th>
 *     <th>Address Component Model</th>
 *     <th>Loqate Mapping</th>
 *     <th>Address Builder Methods</th>
 *   </tr>
 *   <tr>
 *     <td>street</td>
 *     <td>(*1) Special concatenation</td>
 *     <td>setStreet</td>
 *     <td></td>
 *     <td>setStreet</td>
 *   </tr>
 *   <tr>
 *     <td>postcode</td>
 *     <td>Input Zip (Rename to Input PostCode?)</td>
 *     <td>PostalCode[in]</td>
 *     <td>setPostcode</td>
 *     <td>setPostcode</td>
 *   </tr>
 *   <tr>
 *     <td>city</td>
 *     <td>Input City</td>
 *     <td>Locality[in]</td>
 *     <td>setCity</td>
 *     <td>setCity</td>
 *   </tr>
 *   <tr>
 *     <td>region</td>
 *     <td>Names? Input State</td>
 *     <td>AdministrativeArea[in]</td>
 *     <td>setRegion</td>
 *     <td>setRegion</td>
 *   </tr>
 *   <tr>
 *     <td>country</td>
 *     <td>Input Country</td>
 *     <td>Country[in]</td>
 *     <td>setCountry</td>
 *     <td>setCountry</td>
 *   </tr>
 *   <tr>
 *     <td>countryiso</td>
 *     <td>Country ISO Code</td>
 *     <td>(Not mapped to Loqate)</td>
 *     <td>setCountryISO</td>
 *     <td>setCountryISO</td>
 *   </tr>
 *   <tr>
 *     <td>stdstreet</td>
 *     <td>New</td>
 *     <td>Standardized Street + Standardized Organization ?</td>
 *     <td>DeliveryAddress[out]</td>
 *     <td>setStdStreet</td>
 *   </tr>
 *   <tr>
 *     <td>stdpostcode</td>
 *     <td>New</td>
 *     <td>Standardized Zip (Rename to Std. PostCode?)</td>
 *     <td>PostalCode[out]</td>
 *     <td>setStdPostcode</td>
 *   </tr>
 *   <tr>
 *     <td>stdcity</td>
 *     <td>New</td>
 *     <td>Standardized City</td>
 *     <td>Locality[out]</td>
 *     <td>setStdCity</td>
 *   </tr>
 *   <tr>
 *     <td>stdcountryiso</td>
 *     <td>New</td>
 *     <td>Standardized Country ISO Code</td>
 *     <td>ISO3166-2[out]</td>
 *     <td>setStdCountryISO</td>
 *   </tr>
 *   <tr>
 *     <td>stdregion</td>
 *     <td>New. Not used?</td>
 *     <td>Standardized Region</td>
 *     <td>SuperAdministrativeArea[out]</td>
 *     <td>setStdRegion</td>
 *   </tr>
 * </table>
 *
 * @return an instance of {@link StandardizedAddress}
 */
public abstract interface StandardizedAddress extends com.stibo.partydatamatching.domain.address.Address {
  
  /**
   *Get the standardized city on the address object.
   * @return the standardized city
   */
  public abstract java.lang.String getStdCity();
  
  /**
   *Get the standardized country ISO on the address object.
   * @return the standardized country ISO
   */
  public abstract java.lang.String getStdCountryISO();
  
  /**
   *Get the standardized postcode on the address object.
   * @return the standardized postcode
   */
  public abstract java.lang.String getStdPostcode();
  
  /**
   *Get the standardized region on the address object.
   * @return the standardized region
   */
  public abstract java.lang.String getStdRegion();
  
  /**
   *Get the standardized street on the address object.
   * @return the standardized street
   */
  public abstract java.lang.String getStdStreet();
  
}


====================
FILE PATH: .\com.stibo.partydatamatching.domain-sources\com\stibo\partydatamatching\domain\stdaddress\StandardizedAddressBuilder.java
====================
package com.stibo.partydatamatching.domain.stdaddress;

public abstract interface StandardizedAddressBuilder extends com.stibo.partydatamatching.domain.address.AddressBuilder {
  
  /**
   *Set City on the Address object
   * @param city the city
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setCity(java.lang.String city);
  
  /**
   *Set Country on the Address object
   * @param country the country
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setCountry(java.lang.String country);
  
  /**
   *Set CountryISO on the Address object
   * @param countryISO the countryISO
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setCountryISO(java.lang.String countryISO);
  
  /**
   *Set Postcode on the Address object
   * @param postcode the postcode
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setPostcode(java.lang.String postcode);
  
  /**
   *Set Region on the Address object
   * @param region the region
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setRegion(java.lang.String region);
  
  /**
   *Set the standardized city on the address object.
   * @param stdCity the standardized city
   * @return the builder instance
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setStdCity(java.lang.String stdCity);
  
  /**
   *Set the standardized country ISO on the address object.
   * @param stdCountryISO the standardized country ISO
   * @return the builder instance
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setStdCountryISO(java.lang.String stdCountryISO);
  
  /**
   *Set the standardized postcode on the address object.
   * @param stdPostcode the standardized postcode
   * @return the builder instance
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setStdPostcode(java.lang.String stdPostcode);
  
  /**
   *Set the standardized region on the address object.
   * @param stdRegion the standardized region
   * @return the builder instance
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setStdRegion(java.lang.String stdRegion);
  
  /**
   *Set the standardized street on the address object.
   * @param stdStreet the standardized street
   * @return the builder instance
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setStdStreet(java.lang.String stdStreet);
  
  /**
   *Set the full street information on the Address object, the full street contains every address element bellow postcode
   * @param street the street
   * @return this builder
   */
  public abstract com.stibo.partydatamatching.domain.stdaddress.StandardizedAddressBuilder setStreet(java.lang.String street);
  
}


====================
FILE PATH: .\com.stibo.publishing.background.services-sources\com\stibo\publishing\background\services\flatplan\MountDocumentForPlanServiceDescriptor.java
====================
package com.stibo.publishing.background.services.flatplan;

public class MountDocumentForPlanServiceDescriptor implements com.stibo.core.domain.backgroundprocess.service.ServiceDescriptor<com.stibo.publishing.background.services.flatplan.MountDocumentForPlanServiceDescriptor.Parameter> {
  
  /**
   *Parameters for Mount Doc For Plan.
   */
  public static class Parameter {
    
    /**
     *Whether to create a PDF of the document or not, null means false.
     */
    public java.lang.String createPDF;
    
    /**
     *Predefined Adobe PDF settings. Can be null.
     */
    public java.lang.String pdfProfile;
    
    /**
     *The first planned page to be mounted
     */
    public java.lang.String plannedPageURL;
    
    /**
     *The version to use when obtaining tables, etc.
     */
    public java.lang.String versionURL;
    
  }
  
}


====================
FILE PATH: .\com.stibo.publishing.background.services-sources\com\stibo\publishing\background\services\framework\CreatePDFServiceDescriptor.java
====================
package com.stibo.publishing.background.services.framework;

public class CreatePDFServiceDescriptor implements com.stibo.core.domain.backgroundprocess.service.ServiceDescriptor<com.stibo.publishing.background.services.framework.CreatePDFServiceDescriptor.Parameter> {
  
  /**
   *Parameters for Create PDF.
   */
  public static class Parameter {
    
    /**
     *Whether to attach the file to the background process unencoded or not (Workflow requires the file to be encoded).
     */
    public java.lang.Boolean attachUnencoded;
    
    /**
     *ID of the plugin called to name the produced PDF and/or handle any additional processing.
     */
    public java.lang.String deliveryPluginID;
    
    /**
     *The publication document or first planned page to create from
     */
    public java.lang.String inputURL;
    
    /**
     *Predefined Adobe PDF settings. Can be null.
     */
    public java.lang.String pdfProfile;
    
    /**
     *The version to use when obtaining tables, etc.
     */
    public java.lang.String versionURL;
    
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\condition\Condition.java
====================
package com.stibo.query.condition;

/**
 *Interface representing a completed condition that can be evaluated as part of a query
 * specification.
 * <p>
 * The interface provides functionality for combining multiple conditions using logical operators
 * like OR and AND.
 * <p>
 * Notice that it is the sequence in which the logical operator methods are executed that
 * determines the logic; not the standard Java logical operator precedence.
 * Following this, the condition X.or(Y).and(Z) will match objects for which X or Y is true and for
 * which Z is also true.
 * <p>
 * See the Javadoc for {@link com.stibo.query.home.QueryHome} for a full example illustrating how
 * to construct and execute a query.
 */
public abstract interface Condition<A1 extends com.stibo.core.domain.DomainObject> {
  
  /**
   *Returns a condition matching objects for which the condition the method is invoked on is
   * true and the condition provided as parameter is not true.
   * <p>
   * I.e., the compound condition X.except(Y) will match objects for which X is true and for
   * which Y is not true.
   * @param c2  the second condition to be "subtracted" from the former
   * @return a condition for objects adhering to the preceding but not the following requirement
   */
  public default <A2 extends com.stibo.core.domain.DomainObject,R extends A1>com.stibo.query.condition.Condition<R> except(com.stibo.query.condition.Condition<A2> c2) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns a condition representing the disjunctive union of the condition for which the method
   * is invoked and the condition provided as parameter.
   * <p>
   * I.e., the compound condition X.exclusiveOr(Y) will match objects for which X or Y is true
   * but not objects for which both X and Y are true.
   * @param c2  the second condition
   * @return a condition for objects adhering to one but not both of the requirements
   */
  public default <A2 extends com.stibo.core.domain.DomainObject>com.stibo.query.condition.Condition<? super A1> exclusiveOr(com.stibo.query.condition.Condition<A2> c2) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns a condition representing the union of the condition for which the method is invoked
   * and the condition provided as parameter.
   * <p>
   * I.e., the compound condition X.or(Y) will match objects for which X or Y is true including
   * objects for which both X and Y are true.
   * @param c2  the second condition
   * @return a condition for objects adhering to one or both of the requirements
   */
  public default <A2 extends com.stibo.core.domain.DomainObject>com.stibo.query.condition.Condition<? super A1> or(com.stibo.query.condition.Condition<A2> c2) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Returns a condition representing the intersection between the condition for which the method
   * is invoked and the condition provided as parameter.
   * <p>
   * I.e., the compound condition X.and(Y) will match objects for which both X and Y are true.
   * @param c2  the second condition
   * @return a condition for objects adhering to both requirements
   */
  public default <R extends A1>com.stibo.query.condition.Condition<R> and(com.stibo.query.condition.Condition<? super R> c2) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\condition\Conditions.java
====================
package com.stibo.query.condition;

/**
 *Interface providing access to the different types of conditions a query specification can be
 * composed of.
 * <p>
 * Most conditions are constructed via a builder pattern where several steps are required before
 * they can be meaningfully evaluated.
 * Built conditions can be combined in different ways using the methods in the
 * {@link com.stibo.query.condition.Condition} interface to form complex conditions.
 * <p>
 * See the Javadoc for {@link com.stibo.query.home.QueryHome} for a full example illustrating how
 * to construct and execute a query.
 */
public abstract interface Conditions {
  
  /**
   *Use this method to group sub-queries into one, allowing their execution to take place before
   * adjacent conditions.
   * Think of the group() as a set of parentheses that cluster a complex expression, or as a
   * replacement for the common operator-precedence normally found in programming languages.
   * @param grouped  a composite query
   * @return the same composite query, which will be executed as a whole
   */
  public static <A extends java.lang.Object>A group(A grouped) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query task of workflow-nodes of the specified type in the matching specific criteria.
   *
   * @param nodeClass  the type of objects in workflow to query
   * @return a builder for constructing a workflowable node condition
   */
  public static <T extends com.stibo.core.domain.state.Task,S extends com.stibo.core.domain.WorkflowableNode>com.stibo.query.task.TaskWorkflowableConditionBuilder<T> workflowNodes(java.lang.Class<S> nodeClass) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query tasks by their assignee.
   * @return a condition matching tasks matching the given assignees
   */
  public static <T extends com.stibo.core.domain.state.Task>com.stibo.query.node.NodesOnlyConditionBuilder<com.stibo.core.domain.Assignee,T> assignee() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by data containers of the specified type(s) matching specific criteria.
   *
   * @param types  the data container types to query objects about; at least one must be provided
   * @return a builder for constructing a data container object condition
   */
  public static <T extends com.stibo.core.domain.hasdatacontainers.HasDataContainers>com.stibo.query.datacontainer.DataContainerConditionBuilder<T> hasDataContainer(com.stibo.core.domain.datacontainertype.DataContainerType... types) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by outgoing references of the specified type(s) matching specific criteria.
   *
   * @param types  the reference types to query objects about; at least one must be provided
   * @return a builder for constructing a reference object condition
   */
  public static <T extends com.stibo.core.domain.ReferenceSource>com.stibo.query.reference.ReferenceConditionBuilder<T> hasReference(com.stibo.core.domain.ReferenceType... types) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by their {@link com.stibo.core.domain.Node} ID.
   * @return a builder for constructing an ID condition
   */
  public static <T extends com.stibo.core.domain.Node>com.stibo.query.idname.IDConditionBuilder<T> id() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by incoming references of the specified type(s) matching specific criteria.
   *
   * @param types  the reference types to query objects about; at least one must be provided
   * @return a builder for constructing a reference object condition
   */
  public static <T extends com.stibo.core.domain.ReferenceTarget>com.stibo.query.reference.ReferencedByConditionBuilder<T> isReferenced(com.stibo.core.domain.ReferenceType... types) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by their {@link com.stibo.core.domain.Node} name.
   * @return a builder for constructing a name condition
   */
  public static <T extends com.stibo.core.domain.Node>com.stibo.query.idname.NameConditionBuilder<T> name() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query tasks by their states.
   * @return a condition matching tasks matching the given states
   *
   * If you search for states without restricting to a specific workflow, the query
   * will be very in-efficient on some platforms - so please help yourself and your
   * colleagues by always defining the workflow of interest before adding this state-criteria.
   */
  public static <T extends com.stibo.core.domain.state.Task>com.stibo.query.state.StatesConditionBuilder<com.stibo.core.domain.state.State,T> state() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query tasks by their statusFlag.
   * @return a condition matching tasks matching the given statusFlags
   */
  public static <T extends com.stibo.core.domain.state.Task>com.stibo.query.node.NodesOrNoneConditionBuilder<com.stibo.core.domain.state.StatusFlag,T> statusFlag() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by values for the supplied attribute.
   * @param attribute  the attribute to query values for
   * @return a builder for constructing a value condition
   */
  public static <T extends com.stibo.core.domain.BaseObject>com.stibo.query.value.ValueConditionBuilder<T> valueOf(com.stibo.core.domain.Attribute attribute) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query tasks by their workflow.
   * @return a condition matching tasks belonging to the workflow
   */
  public static <T extends com.stibo.core.domain.state.Task>com.stibo.query.node.NodeConditionBuilder<com.stibo.core.domain.state.Workflow,T> workflow() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by their position in the hierarchy.
   * 	@return a builder for constructing a hierarchy condition
   */
  public static com.stibo.query.hierarchy.HierarchyConditionBuilder hierarchy() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by their object type.
   * @param objectType  the object type to match
   * @return a condition matching objects of the supplied type
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.ObjectTypeable> objectType(com.stibo.core.domain.ObjectType objectType) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by object type.
   * <p>
   * Matches objects that are of one of the supplied types.
   * @param objectTypes  the object types to match against
   * @return a condition matching objects of one of the supplied types
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.ObjectTypeable> objectType(com.stibo.core.domain.ObjectType... objectTypes) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects by object type.
   * <p>
   * Matches objects of one of the types in the supplied set.
   * @param objectTypes  the set of object types to match against
   * @return a condition matching objects of one of the supplied types
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.ObjectTypeable> objectType(java.util.Set<com.stibo.core.domain.ObjectType> objectTypes) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects referenced by specified source.
   * <p>
   * This condition can be used inside the where-clause of isReferenced() condition.
   *
   * @param source  the object that references the queried objects
   * @return a condition matching reference objects with the supplied source
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.Reference> sourceIs(com.stibo.core.domain.ReferenceSource source) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects referenced by objects satisfying the source condition.
   * <p>
   * This condition can be used inside the where-clause of a isReferenced() condition.
   *
   * @param sourceCondition  the condition reference sources must match
   * @return a condition matching reference objects satisfying the supplied source condition
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.Reference> sourceMatches(com.stibo.query.condition.Condition<? super com.stibo.core.domain.ReferenceSource> sourceCondition) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects that reference the specified target.
   * <p>
   * This condition can be used inside the where-clause of a hasReferences() condition.
   *
   * @param target  the reference target
   * @return a condition matching reference objects with the supplied target
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.Reference> targetIs(com.stibo.core.domain.ReferenceTarget target) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Query objects with references to objects satisfying the target condition.
   * <p>
   * This condition can be used inside the where-clause of a hasReferences() condition.
   *
   * @param targetCondition  the condition reference targets must match
   * @return a condition matching reference objects satisfying the supplied target condition
   */
  public static com.stibo.query.condition.Condition<com.stibo.core.domain.Reference> targetMatches(com.stibo.query.condition.Condition<? super com.stibo.core.domain.ReferenceTarget> targetCondition) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\conditionbuilder\ConditionBuilder.java
====================
package com.stibo.query.conditionbuilder;

/**
 *A common placeholder for building all condition builders.
 * <p>
 * Model-wise this interface is insignificant, it is only here for generic signatures being passed
 * around syntactically.
 */
public abstract interface ConditionBuilder<A1 extends com.stibo.core.domain.DomainObject> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\datacontainer\DataContainerConditionBuilder.java
====================
package com.stibo.query.datacontainer;

/**
 *The conditions available for data containers, including the ability to inherit data.
 */
public abstract interface DataContainerConditionBuilder<T extends com.stibo.core.domain.hasdatacontainers.HasDataContainers> extends com.stibo.query.datacontainer.DataContainerConditionWhereBuilder<T>, com.stibo.query.features.instancecount.InstanceCountFeature<T,com.stibo.query.features.instancecount.InstanceCountConditionBuilder<T,com.stibo.query.datacontainer.DataContainerConditionWhereBuilder<T>>>, com.stibo.query.features.inheritance.InheritanceFeature<T,com.stibo.query.datacontainer.DataContainerConditionWhereBuilder<T>> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\datacontainer\DataContainerConditionWhereBuilder.java
====================
package com.stibo.query.datacontainer;

/**
 *The conditions available for data containers/composites.
 */
public abstract interface DataContainerConditionWhereBuilder<T extends com.stibo.core.domain.hasdatacontainers.HasDataContainers> extends com.stibo.query.conditionbuilder.ConditionBuilder<T>, com.stibo.query.features.inheritance.InheritanceFeature<T,com.stibo.query.datacontainer.DataContainerConditionWhereBuilder<T>> {
  
  /**
   *Method for specifying the where condition for a data container's query specification.
   * <p>
   * Condition must be constructed starting with one of the static methods on the
   * {@link com.stibo.query.condition.Conditions} interface.
   * @param whereClause  the potentially complex condition to be matched, applicable to data containers of the given type.
   * @return a condition matching data containers satisfying the supplied condition
   */
  public default com.stibo.query.condition.Condition<T> where(com.stibo.query.condition.Condition<? super com.stibo.core.domain.datacontainerobject.DataContainerObject> whereClause) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\date\DateConditionBuilder.java
====================
package com.stibo.query.date;

/**
 *Interface providing query options specific to date validated attributes.
 * <p>
 * Date validated attributes, are attributes with validation base type "ISO Date and Time" and "ISO Date".
 * <p>
 * Use the standard text search features for other date validation base types.
 */
public abstract interface DateConditionBuilder<T extends com.stibo.core.domain.BaseObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values that are greater than or equal to <tt>startDate</tt> and
   * less than or equal to <tt>endDate</tt>.
   * <p>
   * Values for the <tt>startDate</tt> and <tt>endDate</tt> parameters must be supplied in the
   * format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param startDate  the date that values must be greater than or equal to
   * @param endDate  the date that values must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(java.lang.String startDate,java.lang.String endDate) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values that are greater than or equal to <tt>startDate</tt> and
   * less than or equal to <tt>endDate</tt>.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param startDate  the date that values must be greater than or equal to
   * @param endDate  the date that values must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(java.util.Date startDate,java.util.Date endDate) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values equal to the supplied date.
   * <p>
   * Value for the <tt>date</tt> parameter must be supplied in the format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param date  the date to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.lang.String date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values equal to the supplied date.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param date  the date to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.util.Date date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values greater than the supplied date.
   * <p>
   * Value for the <tt>date</tt> parameter must be supplied in the format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param date  the date that values must be greater than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(java.lang.String date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values greater than the supplied date.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param date  the date that values must be greater than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(java.util.Date date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values greater than or equal to the supplied date.
   * <p>
   * Value for the <tt>date</tt> parameter must be supplied in the format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param date  the date that values must be greater than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(java.lang.String date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values greater than or equal to the supplied date.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param date  the date that values must be greater than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(java.util.Date date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values less than the supplied date.
   * <p>
   * Value for the <tt>date</tt> parameter must be supplied in the format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param date  the date that values must be less than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(java.lang.String date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values less than the supplied date.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param date  the date that values must be less than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(java.util.Date date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values less than or equal to the supplied date.
   * <p>
   * Value for the <tt>date</tt> parameter must be supplied in the format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param date  the date that values must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(java.lang.String date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values less than or equal to the supplied date.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param date  the date that values must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(java.util.Date date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values different from the supplied date.
   * <p>
   * Notice that the method will not match empty values, only actual values different from the supplied date.
   * <p>
   * Value for the <tt>date</tt> parameter must be supplied in the format "yyyy-MM-dd HH:mm:ss" or "yyyy-MM-dd".
   * @param date  the date that matches must not equal
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.lang.String date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches "ISO Date and Time" and "ISO Date" values different from the supplied date.
   * <p>
   * Notice that the method will not match empty values, only actual values different from the supplied date.
   * <p>
   * Notice that the server time zone is used when date and time information is obtained from
   * passed Date and that the value of supplied date will be rounded down (truncated) to seconds.
   * @param date  the date that matches must not equal
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.util.Date date) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\features\casespecific\CaseSpecificFeature.java
====================
package com.stibo.query.features.casespecific;

/**
 *Interface for accessing query features specific to text casing.
 * <p>
 * Text searches will be case specific unless {@link #ignoreCase} is called prior to using the
 * methods in the {@link com.stibo.query.text.TextConditionBuilder} interface.
 */
public abstract interface CaseSpecificFeature<T extends com.stibo.core.domain.DomainObject,I extends com.stibo.query.text.TextConditionBuilder<T>> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Makes the text search non-case specific.
   * @return a text condition builder
   */
  public default I ignoreCase() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\features\inheritance\InheritanceFeature.java
====================
package com.stibo.query.features.inheritance;

/**
 *Interface for accessing features specific to hierarchical inheritance.
 */
public abstract interface InheritanceFeature<T extends com.stibo.core.domain.BaseObject,I extends com.stibo.query.conditionbuilder.ConditionBuilder<T>> {
  
  /**
   *Makes the condition being built match hierarchically inherited data in addition to locally defined data.
   * <p>
   * Object type validity is not taken into account meaning that e.g. a value query can match (product) objects of a type for which the attribute is not valid.
   * For product overrides, data inherited from an overridden product will be treated as if it was hierarchically inherited.
   * <p>
   * Examples:
   * <p>
   * Below matches products for which the value 'ABC' for attribute 'attr' is either locally defined or inherited.
   * <pre>
   * import com.stibo.query.home.QueryHome;
   * import static com.stibo.query.condition.Conditions.*;
   * //...
   *
   * QueryHome qh = manager.getHome(QueryHome.class);
   *
   * QuerySpecification&lt;Product&gt; querySpecification = qh.queryFor(Product.class).where(
   *     valueOf(attr).inherited().eq("ABC")
   * );
   * </pre>
   * <p>
   * Below matches enities that have a local or inherited reference of reference type 'refType' to 'targetNode'.
   * <pre>
   * import com.stibo.query.home.QueryHome;
   * import static com.stibo.query.condition.Conditions.*;
   * //...
   *
   * QueryHome qh = manager.getHome(QueryHome.class);
   *
   * QuerySpecification&lt;Entity&gt; querySpecification = qh.queryFor(Entity.class).where(
   *     hasReference(refType).inherited().where(
   *         targetIs(targetNode)
   *     )
   * );
   * </pre>
   *
   * @return a condition builder interface
   */
  public default I inherited() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\features\instancecount\InstanceCountConditionBuilder.java
====================
package com.stibo.query.features.instancecount;

/**
 *Comparators used for instance-counting criteria only.
 */
public abstract interface InstanceCountConditionBuilder<T extends com.stibo.core.domain.DomainObject,I extends com.stibo.query.conditionbuilder.ConditionBuilder<T>> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches values equal to the supplied count.
   * <p>
   * @param value  the value to match
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I eq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values equal to the supplied count.
   * @param value  the value to match
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I eq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are greater than the supplied count.
   * <p>
   * @param value  the value that matches must be greater than
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I gt(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are greater than the supplied count.
   * @param value  the value that matches must be greater than
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I gt(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are greater than or equal to the supplied count.
   * <p>
   * @param value  the value that matches must be greater than or equal to
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I gteq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are greater than or equal to the supplied count.
   * @param value  the value that matches must be greater than or equal to
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I gteq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are less than the supplied count.
   * <p>
   * @param value  the value that matches must be less than
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I lt(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are less than the supplied count.
   * @param value  the value that matches must be less than
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I lt(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are less than or equal to the supplied count.
   * <p>
   * @param value  the value that matches must be less than or equal to
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I lteq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values that are less than or equal to the supplied count.
   * @param value  the value that matches must be less than or equal to
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I lteq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values different from the supplied count.
   * <p>
   * Notice that the method will not match empty values, only set values without units different
   * from the supplied count.
   * @param value  the value matches must not equal
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I neq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches values different from the supplied count.
   * <p>
   * Notice that the method will not match empty values, only set values without units different
   * from the supplied count.
   * @param value  the value matches must not equal
   * @return a preliminary condition that can be completed with a where-clause
   */
  public default I neq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\features\instancecount\InstanceCountFeature.java
====================
package com.stibo.query.features.instancecount;

/**
 *Interface for counting and comparing instances
 */
public abstract interface InstanceCountFeature<T extends com.stibo.core.domain.DomainObject,I extends com.stibo.query.conditionbuilder.ConditionBuilder<T>> {
  
  /**
   *Makes the instance-criteria match a given amount.
   * <p>
   * As an example, the query below will match products that have exactly two data container objects of type 'dcType' for which the value of attribute 'attr' is 'ABC'.
   * <pre>
   * import com.stibo.query.home.QueryHome;
   * import static com.stibo.query.condition.Conditions.*;
   * //...
   *
   * QueryHome qh = manager.getHome(QueryHome.class);
   *
   * QuerySpecification&lt;Product&gt; querySpecification = qh.queryFor(Product.class).where(
   *     hasDataContainer(dcType).instanceCount().eq(2).where(
   *         valueOf(attr).eq("ABC")
   *     )
   * );
   * </pre>
   *
   * @return a condition builder interface
   */
  public default I instanceCount() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\hierarchy\HierarchyConditionBuilder.java
====================
package com.stibo.query.hierarchy;

/**
 *Interface providing access to functionality for constructing hierarchy conditions.
 */
public abstract interface HierarchyConditionBuilder extends com.stibo.query.conditionbuilder.ConditionBuilder<com.stibo.core.domain.datanode.DataNode> {
  
  /**
   *Matches any object below and including supplied <tt>top</tt>.
   * <p>
   * Will for data tree nodes match products below product and classification <tt>top</tt> nodes,
   * classifications below classifications, assets below classifications and entities below
   * entities.
   * <p>
   * Notice that the method will not, for products below classifications, respect
   * {@link com.stibo.core.domain.ClassificationProductLinkType} inheritance settings.
   * I.e. a product is considered to be below a classification if any product higher in the
   * hierarchy is linked into the classification or a sub-classification, regardless of the
   * inheritance mode setting.
   * @param top  the start/top node defining the hierarchy
   * @return a condition matching nodes to which you can hierarchically traverse to from the given top
   */
  public default <T extends com.stibo.core.domain.datanode.DataNode>com.stibo.query.condition.Condition<T> simpleBelow(com.stibo.core.domain.datanode.DataNode top) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\home\QueryHome.java
====================
package com.stibo.query.home;

/**
 *Main entry point for constructing and executing queries.
 * <p>
 * Queries always have the form {@code queryFor([class type extending BaseObject]).where([Condition])}
 * and return a {@link com.stibo.query.home.QuerySpecification} from which a {@link com.stibo.core.domain.query.Query}
 * containing matching objects of the specified type can be obtained.
 * <p>
 * Conditions are constructed starting with one of the static methods on the {@link com.stibo.query.condition.Conditions}
 * interface and can be combined via the methods on the {@link com.stibo.query.condition.Condition}
 * interface.
 * <p>
 * In Java code, a query that matches entities of object type "location" with the value "No" for attribute
 * "active" could be formulated as follows ("manager" = {@link com.stibo.core.domain.Manager}):
 * <pre>
 * import com.stibo.query.home.QueryHome;
 * import static com.stibo.query.condition.Conditions.*;
 * //...
 *
 * QueryHome qh = manager.getHome(QueryHome.class);
 *
 * QuerySpecification&lt;Entity&gt; querySpecification = qh.queryFor(Entity.class).where(
 *     valueOf(active).eq("No")
 *     .and(objectType(location))
 * );
 *
 * Query&lt;Entity&gt; result = querySpecification.execute();
 * </pre>
 * <p>
 * In JavaScript, {@link com.stibo.query.home.QueryHome} can be accessed via the "Query Home" bind
 * or via {@link com.stibo.core.domain.Manager#getHome} while static methods on the
 * {@link com.stibo.query.condition.Conditions} interface must be accessed as illustrated below
 * ({@link com.stibo.query.home.QueryHome} here obtained via manager):
 * <pre>
 * var c = com.stibo.query.condition.Conditions;
 * var h = manager.getHome(com.stibo.query.home.QueryHome);
 * var querySpecification = h.queryFor(com.stibo.core.domain.entity.Entity).where(
 *     c.valueOf(active).eq("No")
 *     .and(c.objectType(location))
 * );
 * var result = querySpecification.execute();
 * </pre>
 */
public abstract interface QueryHome extends com.stibo.core.domain.home.Home {
  
  /**
   *Starting point for constructing a query restricted to return STEP objects of class
   * <tt>baseObjectSubClass</tt> that match a where-condition.
   * <p>
   * Build unto the returned {@link QuerySpecificationBuilder} in order to complete the
   * specification.
   * <p>
   * Notice that in current release, <tt>baseObjectSubClass</tt> must be a concrete type like
   * e.g. {@link com.stibo.core.domain.Product}, {@link com.stibo.core.domain.entity.Entity},
   * {@link com.stibo.core.domain.Asset}, {@link com.stibo.core.domain.Classification},
   * {@link com.stibo.core.domain.Attribute}, {@link com.stibo.core.domain.Unit} or
   * {@link com.stibo.core.domain.ReferenceType}.
   * In particular, it is of yet not possible to query for references, links and data container
   * objects or instances of "abstract" interfaces like {@link com.stibo.core.domain.datanode.DataNode}.
   * @param baseObjectSubClass  a class restricting the return types of the query to a subset of STEP objects.
   * @return a {@link QuerySpecificationBuilder} that must be used to further define the query
   */
  public abstract <BO extends com.stibo.core.domain.Node>com.stibo.query.home.QuerySpecificationBuilder<BO> queryFor(java.lang.Class<BO> baseObjectSubClass);
  
  /**
   *Starting point for constructing a query restricted to return workflow tasks that match a where-condition.
   * <p>
   * Build unto the returned {@link QuerySpecificationBuilder} in order to complete the
   * specification.
   * <p>
   * @return a {@link QuerySpecificationBuilder} that must be used to further define the query
   */
  public abstract com.stibo.query.home.QuerySpecificationBuilder<com.stibo.core.domain.state.Task> queryWorkflowTasks();
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\home\QuerySpecification.java
====================
package com.stibo.query.home;

/**
 *The specification of a query that it is possible to execute to produce a result
 * {@link com.stibo.core.domain.query.Query}.
 * <p/>
 * See the Javadoc for {@link com.stibo.query.home.QueryHome} for a full example illustrating how
 * to construct and execute a query.
 * <p/>
 * Notice that data changed in the current transaction is not necessarily included.
 * The result of the query can be consistent with last committed or can include all changes done in transaction.
 * Or it may include some parts of current transactional changes while not including others.
 */
public abstract interface QuerySpecification<T extends com.stibo.core.domain.DomainObject> {
  
  /**
   *Produces a result {@link com.stibo.core.domain.query.Query} from the query specification.
   * <p>
   * The query will be executed with the permissions of and in the context / workspace of the
   * {@link com.stibo.core.domain.Manager} via which {@link com.stibo.query.home.QueryHome} has been obtained.
   * @return a {@link com.stibo.core.domain.query.Query} containing objects matching the query
   * specification
   */
  public abstract com.stibo.core.domain.query.Query<T> execute();
  
  /**
   *Sets the maximum time in seconds that the query is allowed to run.
   * <p/>
   * Due to network latency, vendor-specific implementations and more, the actual running time may
   * exceed the specified max.
   * <br/>
   * There is therefore no guarantee that the query will stop immediately after the specified max,
   * but it will be <i>requested</i> to stop; also guaranteed is that it will be allowed to run un-interrupted
   * at least for the specified amount of time.<br/>
   * The interruption itself is also vendor-specific and may stop the query immediately, or as soon
   * as the implementation finds it fitting.
   * <p/>
   * It is expected that the time spent consuming the retrieved data (within
   * the {@link com.stibo.core.domain.query.Query#forEach(QueryConsumer)} of the query)
   * is not counted as part of the elapsed query time, but this too is not guaranteed.
   * <p/>
   * Multiple invocations cause earlier set values to be overwritten.
   * @param seconds  the maximum execution time in seconds
   * @return the query specification
   */
  public abstract com.stibo.query.home.QuerySpecification<T> maxTime(int seconds);
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\home\QuerySpecificationBuilder.java
====================
package com.stibo.query.home;

/**
 *Interface providing functionality for specifying the condition of a query specification.
 * <p>
 * See the Javadoc for {@link com.stibo.query.home.QueryHome} for a full example illustrating how
 * to construct and execute a query.
 */
public abstract interface QuerySpecificationBuilder<T extends com.stibo.core.domain.DomainObject> {
  
  /**
   *Method for specifying the where condition for a query specification.
   * <p>
   * Condition must be constructed starting with one of the static methods on the
   * {@link com.stibo.query.condition.Conditions} interface.
   * @param condition  the potentially complex condition to be matched
   * @return an executable query specification
   */
  public abstract com.stibo.query.home.QuerySpecification<T> where(com.stibo.query.condition.Condition<? super T> condition);
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\idname\NameConditionBuilder.java
====================
package com.stibo.query.idname;

/**
 *Interface providing access to {@link com.stibo.core.domain.Node} name query options.
 * <p>
 * Name searches are by default case specific. This behavior can be changed via
 * {@link CaseSpecificFeature#ignoreCase}.
 */
public abstract interface NameConditionBuilder<T extends com.stibo.core.domain.Node> extends com.stibo.query.text.TextConditionBuilder<T>, com.stibo.query.features.casespecific.CaseSpecificFeature<T,com.stibo.query.idname.NameConditionBuilder<T>> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\idname\IDConditionBuilder.java
====================
package com.stibo.query.idname;

/**
 *Interface providing access to {@link com.stibo.core.domain.Node} ID query options.
 * <p>
 * ID searches will always be case specific.
 */
public abstract interface IDConditionBuilder<T extends com.stibo.core.domain.Node> extends com.stibo.query.text.TextConditionBuilder<T> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\lov\LOVValueConditionBuilder.java
====================
package com.stibo.query.lov;

/**
 *Interface providing query options specific to attributes using a List-Of-Value.
 * <p>
 * LOV validated attributes are those for which {@link com.stibo.core.domain.Attribute#hasLOV} is
 * <tt>true</tt>.
 */
public abstract interface LOVValueConditionBuilder<T extends com.stibo.core.domain.BaseObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches LOV values with the supplied value ID. Is case sensitive.
   * <p>
   * The plain {@code Conditions.valueOf(anAttribute).eq("aValue")} should be used for queries
   * matching the value part of an LOV value.
   * @param id  the value ID to match
   * @return a condition matching values with the supplied value ID
   */
  public default com.stibo.query.condition.Condition<T> id(java.lang.String id) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches LOV values equal to the supplied <tt>lovValue</tt>.
   * <p>
   * Supplied <tt>lovValue</tt> must be from the LOV associated with the attribute for which the
   * condition is constructed.
   * @param lovValue  the value to match
   * @return a condition matching values with the supplied value ID
   */
  public default com.stibo.query.condition.Condition<T> lovValue(com.stibo.core.domain.ListOfValuesValue lovValue) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\node\NodeConditionBuilder.java
====================
package com.stibo.query.node;

/**
 *Interface providing access to basic node query features.
 *
 * Used for specific sub-queries only.
 */
public abstract interface NodeConditionBuilder<A1 extends com.stibo.core.domain.Node,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.node.NodeOnlyConditionBuilder<A1,T> {
  
  /**
   *Matches node with given ID
   * <p>
   * @param externalID the node's ID to match with
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.lang.String externalID) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\node\NodeOnlyConditionBuilder.java
====================
package com.stibo.query.node;

/**
 *Interface providing access to basic node query features.
 *
 * Used for specific sub-queries only.
 */
public abstract interface NodeOnlyConditionBuilder<A1 extends com.stibo.core.domain.Node,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches node given
   * <p>
   * @param node the node to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(A1 node) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\node\NodesConditionBuilder.java
====================
package com.stibo.query.node;

/**
 *Interface providing access to basic node query features for multiple nodes.
 *
 * Used for specific sub-queries only.
 */
public abstract interface NodesConditionBuilder<A1 extends com.stibo.core.domain.Node,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.node.NodesOnlyConditionBuilder<A1,T>, com.stibo.query.node.NodeConditionBuilder<A1,T> {
  
  /**
   *Matches nodes with given IDs
   * <p>
   * @param externalIDs the nodes' IDs to match with
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> havingIDs(java.lang.String... externalIDs) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\node\NodesOnlyConditionBuilder.java
====================
package com.stibo.query.node;

/**
 *Interface providing access to basic node query features for multiple nodes.
 *
 * Used for specific sub-queries only.
 */
public abstract interface NodesOnlyConditionBuilder<A1 extends com.stibo.core.domain.Node,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.node.NodeOnlyConditionBuilder<A1,T> {
  
  /**
   *Matches nodes given
   * <p>
   * @param nodes the nodes to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> in(A1... nodes) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\node\NodesOrNoneConditionBuilder.java
====================
package com.stibo.query.node;

/**
 *Interface providing access to basic node query features for multiple, singular or absent nodes.
 *
 * Used for specific sub-queries only.
 */
public abstract interface NodesOrNoneConditionBuilder<A1 extends com.stibo.core.domain.Node,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.node.NoneConditionBuilder<A1,T>, com.stibo.query.node.NodesConditionBuilder<A1,T> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\node\NoneConditionBuilder.java
====================
package com.stibo.query.node;

/**
 *Interface providing access to basic node query features.
 *
 * Used for specific sub-queries only.
 */
public abstract interface NoneConditionBuilder<A1 extends com.stibo.core.domain.Node,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches where there are no nodes
   * <p>
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> none() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\numeric\NumericConditionBuilder.java
====================
package com.stibo.query.numeric;

/**
 *Interface providing query options specific to numerically validated attributes.
 * <p>
 * Numerically validated attributes are attributes with validation base type "Integer", "Number",
 * "Fraction", "Numeric Text"
 * <p>
 * Notice that queries without units will only match values without units and vice versa
 * (<tt>eq(5)</tt> is in this regard the same as <tt>eq(5, null)</tt>)
 */
public abstract interface NumericConditionBuilder<T extends com.stibo.core.domain.BaseObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches numeric values that are greater than or equal to <tt>minvalue</tt> and less
   * than or equal to <tt>maxvalue</tt>.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * If units are supplied, the method will only match values with units and vice versa.
   * <tt>minunit</tt> and a <tt>maxunit</tt> must either both be supplied or both be null.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" is between "0.3 m" and "0.6 m").
   * @param minvalue  the values that matches must be greater than or equal to
   * @param minunit  the unit that <tt>minvalue</tt> is supplied in, can be null if <tt>maxunit</tt> is also null
   * @param maxvalue  the values that matches must be less than or equal to
   * @param maxunit  the unit that <tt>maxvalue</tt> is supplied in, can be null if <tt>minunit</tt> is also null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(java.lang.String minvalue,com.stibo.core.domain.Unit minunit,java.lang.String maxvalue,com.stibo.core.domain.Unit maxunit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than or equal to <tt>minvalue</tt> and less than or equal to <tt>maxvalue</tt>.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * @param minvalue  the values that matches must be greater than or equal to
   * @param maxvalue  the values that matches must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(java.lang.String minvalue,java.lang.String maxvalue) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values  that are greater than or equal to <tt>minvalue</tt> and less
   * than or equal to <tt>maxvalue</tt>.
   * <p>
   * If units are supplied, the method will only match values with units and vice versa.
   * <tt>minunit</tt> and a <tt>maxunit</tt> must either both be supplied or both be null.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" is between "0.3 m" and "0.6 m").
   * @param minvalue  the values that matches must be greater than or equal to
   * @param minunit  the unit that <tt>minvalue</tt> is supplied in, can be null if <tt>maxunit</tt> is also null
   * @param maxvalue  the values that matches must be less than or equal to
   * @param maxunit  the unit that <tt>maxvalue</tt> is supplied in, can be null if <tt>minunit</tt> is also null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(java.math.BigDecimal minvalue,com.stibo.core.domain.Unit minunit,java.math.BigDecimal maxvalue,com.stibo.core.domain.Unit maxunit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than or equal to <tt>minvalue</tt> and
   * less than or equal to <tt>maxvalue</tt>.
   * @param minvalue  the values that matches must be greater than or equal to
   * @param maxvalue  the values that matches must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(java.math.BigDecimal minvalue,java.math.BigDecimal maxvalue) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than or equal to <tt>minvalue</tt> and less
   * than or equal to <tt>maxvalue</tt>.
   * <p>
   * If units are supplied, the method will only match values with units and vice versa.
   * <tt>minunit</tt> and a <tt>maxunit</tt> must either both be supplied or both be null.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" is between "0.3 m" and "0.6 m").
   * @param minvalue  the values that matches must be greater than or equal to
   * @param minunit  the unit that <tt>minvalue</tt> is supplied in, can be null if <tt>maxunit</tt> is also null
   * @param maxvalue  the values that matches must be less than or equal to
   * @param maxunit  the unit that <tt>maxvalue</tt> is supplied in, can be null if <tt>minunit</tt> is also null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(long minvalue,com.stibo.core.domain.Unit minunit,long maxvalue,com.stibo.core.domain.Unit maxunit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than or equal to <tt>minvalue</tt> and less than or equal to <tt>maxvalue</tt>.
   * @param minvalue  the values that matches must be greater than or equal to
   * @param maxvalue  the values that matches must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> between(long minvalue,long maxvalue) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units equal to the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * @param value  the value to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values equal to the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" = "0.5 m").
   * @param value  the value to match
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.lang.String value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units equal to the supplied value.
   * @param value  the value to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.math.BigDecimal value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values equal to the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" = "0.5 m").
   * @param value  the value to match
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.math.BigDecimal value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units equal to the supplied value.
   * @param value  the value to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values equal to the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" = "0.5 m").
   * @param value  the value to match
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(long value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * @param value  the value that matches must be greater than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "0.6 m" &gt; "50 cm").
   * @param value  the value that matches must be greater than
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(java.lang.String value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than the supplied value.
   * @param value  the value that matches must be greater than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(java.math.BigDecimal value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "0.6 m" &gt; "50 cm").
   * @param value  the value that matches must be greater than
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(java.math.BigDecimal value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than the supplied value.
   * @param value  the value that matches must be greater than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "0.6 m" &gt; "50 cm").
   * @param value  the value that matches must be greater than
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gt(long value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than or equal to the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * @param value  the value that matches must be greater than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than or equal to the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "0.6 m" &gt;= "50 cm").
   * @param value  the value that matches must be greater than or equal to
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(java.lang.String value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than or equal to the supplied value.
   * @param value  the value that matches must be greater than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(java.math.BigDecimal value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than or equal to the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "0.6 m" &gt;= "50 cm").
   * @param value  the value that matches must be greater than or equal to
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(java.math.BigDecimal value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are greater than or equal to the supplied value.
   * @param value  the value that matches must be greater than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are greater than or equal to the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "0.6 m" &gt;= "50 cm").
   * @param value  the value that matches must be greater than or equal to
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> gteq(long value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are less than the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * @param value  the value that matches must be less than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are less than the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" &lt; "0.6 m").
   * @param value  the value that matches must be less than
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(java.lang.String value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are less than the supplied value.
   * @param value  the value that matches must be less than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(java.math.BigDecimal value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are less than the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" &lt; "0.6 m").
   * @param value  the value that matches must be less than
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(java.math.BigDecimal value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are less than the supplied value.
   * @param value  the value that matches must be less than
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are less than the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" &lt; "0.6 m").
   * @param value  the value that matches must be less than
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lt(long value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are less than or equal to the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * @param value  the value that matches must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are less than or equal to the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" &lt;= "0.6 m").
   * @param value  the value that matches must be less than or equal to
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(java.lang.String value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are less than or equal to the supplied value.
   * @param value  the value that matches must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(java.math.BigDecimal value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are less than or equal to the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" &lt;= "0.6 m").
   * @param value  the value that matches must be less than or equal to
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(java.math.BigDecimal value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units that are less than or equal to the supplied value.
   * @param value  the value that matches must be less than or equal to
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values that are less than or equal to the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units and vice versa.
   * <p>
   * Can match values with different units given that these can be converted to the same base
   * unit (i.e., "50 cm" &lt;= "0.6 m").
   * @param value  the value that matches must be less than or equal to
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> lteq(long value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units different from the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * Notice that the method will not match empty values, only set values without units different
   * from the supplied value.
   * @param value  the value matches must not equal
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values different from the supplied value.
   * <p>
   * The supplied value will be converted to a {@link java.math.BigDecimal} using the
   * {@code BigDecimal(String val)} constructor after which the method has the same semantics as
   * the "BigDecimal" and "long" variants.
   * <p>
   * Notice that the method will not match empty values, only actual values different
   * from the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units that are different from
   * the supplied unit and vice versa.
   * <p>
   * Can perform unit conversions for values with units that can be converted to the same base
   * unit as the supplied unit (i.e., "0.5 cm" != "0.5 m").
   * @param value  the value matches must not equal
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.lang.String value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units different from the supplied value.
   * <p>
   * Notice that the method will not match empty values, only set values without units different
   * from the supplied value.
   * @param value  the value matches must not equal
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.math.BigDecimal value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values different from the supplied value.
   * <p>
   * Notice that the method will not match empty values, only actual values different
   * from the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units that are different from
   * the supplied value and vice versa.
   * <p>
   * Can perform unit conversions for values with units that can be converted to the same base
   * unit as the supplied unit (i.e., "0.5 cm" != "0.5 m").
   * @param value  the value matches must not equal
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.math.BigDecimal value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values without units different from the supplied value.
   * <p>
   * Notice that the method will not match empty values, only set values without units different
   * from the supplied value.
   * @param value  the value matches must not equal
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(long value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches numeric values different from the supplied value.
   * <p>
   * Notice that the method will not match empty values, only actual values different
   * from the supplied value.
   * <p>
   * If a unit is supplied, the method will only match values with units that are different from
   * the supplied unit and vice versa.
   * <p>
   * Can perform unit conversions for values with units that can be converted to the same base
   * unit as the supplied unit (i.e., "0.5 cm" != "0.5 m").
   * @param value  the value matches must not equal
   * @param unit  the unit <tt>value</tt> is supplied in, can be null
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(long value,com.stibo.core.domain.Unit unit) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\reference\ReferenceConditionBuilder.java
====================
package com.stibo.query.reference;

/**
 *The conditions available for references, including the ability to inherit data.
 */
public abstract interface ReferenceConditionBuilder<T extends com.stibo.core.domain.Node> extends com.stibo.query.reference.ReferenceConditionWhereBuilder<T>, com.stibo.query.features.inheritance.InheritanceFeature<T,com.stibo.query.reference.ReferenceConditionWhereBuilder<T>> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\reference\ReferenceConditionWhereBuilder.java
====================
package com.stibo.query.reference;

/**
 *The conditions available for references.
 */
public abstract interface ReferenceConditionWhereBuilder<T extends com.stibo.core.domain.Node> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Method for specifying the where condition for a cross-reference query specification.
   * <p>
   * Condition must be constructed starting with one of the static methods on the
   * {@link com.stibo.query.condition.Conditions} interface.
   * @param whereClause  the potentially complex condition to be matched, applicable to references of the given type.
   * @return a condition matching reference objects satisfying the supplied condition
   */
  public default com.stibo.query.condition.Condition<T> where(com.stibo.query.condition.Condition<? super com.stibo.core.domain.Reference> whereClause) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\reference\ReferencedByConditionBuilder.java
====================
package com.stibo.query.reference;

/**
 *The conditions available for referenced by query.
 */
public abstract interface ReferencedByConditionBuilder<T extends com.stibo.core.domain.Node> extends com.stibo.query.reference.ReferenceConditionWhereBuilder<T> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\state\StateConditionBuilder.java
====================
package com.stibo.query.state;

/**
 *Interface providing access to basic state query features.
 */
public abstract interface StateConditionBuilder<A1 extends com.stibo.core.domain.state.State,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches state given
   * <p>
   * @param state the node to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(A1 state) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches state with given ID
   * <p>
   * @param externalID the state's ID to match with
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.lang.String externalID) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\state\StatesConditionBuilder.java
====================
package com.stibo.query.state;

/**
 *Interface providing access to basic node query features for multiple states.
 *
 * Used for specific sub-queries only.
 */
public abstract interface StatesConditionBuilder<A1 extends com.stibo.core.domain.state.State,T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.state.StateConditionBuilder<A1,T> {
  
  /**
   *Matches states with given IDs
   * <p>
   * @param externalIDs the states' IDs to match with
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> havingIDs(java.lang.String... externalIDs) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches states given
   * <p>
   * @param states the states to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> in(A1... states) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\task\TaskConditionBuilder.java
====================
package com.stibo.query.task;

/**
 *The condition available for tasks.
 */
public abstract interface TaskConditionBuilder<T extends com.stibo.core.domain.state.Task> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\task\TaskWorkflowableConditionBuilder.java
====================
package com.stibo.query.task;

/**
 *The conditions available for workflowable nodes in Tasks.
 */
public abstract interface TaskWorkflowableConditionBuilder<T extends com.stibo.core.domain.state.Task> extends com.stibo.query.task.TaskWorkflowableConditionWhereBuilder<T> {
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\task\TaskWorkflowableConditionWhereBuilder.java
====================
package com.stibo.query.task;

/**
 *The conditions available for workflow-able nodes in tasks.
 */
public abstract interface TaskWorkflowableConditionWhereBuilder<T extends com.stibo.core.domain.state.Task> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Method for specifying the where condition for a workflowable node query specification.
   * <p>
   * Condition must be constructed starting with one of the static methods on the
   * {@link Conditions} interface.
   * @param whereClause  the potentially complex condition to be matched, applicable to nodes of the given class.
   * @return a condition matching nodes satisfying the supplied condition
   */
  public default com.stibo.query.condition.Condition<T> where(com.stibo.query.condition.Condition<? super com.stibo.core.domain.WorkflowableNode> whereClause) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\text\TextConditionBuilder.java
====================
package com.stibo.query.text;

/**
 *Interface providing access to basic text query features.
 */
public abstract interface TextConditionBuilder<T extends com.stibo.core.domain.DomainObject> extends com.stibo.query.conditionbuilder.ConditionBuilder<T> {
  
  /**
   *Matches textual data that equals the supplied value. Notice that unlike the like operator, wildcard characters
   * and backslash character should not be escaped.
   * <p>
   * A runtime exception will be thrown if supplied value exceeds 1999 bytes meaning that it is
   * not possible to get exact matches on values exceeding this limit.
   * Use {@link #like} for partial matches within the first 400 bytes of existing values.
   * <p>
   * Notice that the method, when used in value conditions, will not match values with units.
   * Use the methods in {@link com.stibo.query.numeric.NumericConditionBuilder} for matching
   * values with units.
   * @param value  the textual value to match
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> eq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches textual data that has a value.
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> exists() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches textual data that equals the supplied expression.
   * <p>
   * The wildcards "*" (any number of characters) and "?" (single character) can be used in the expression.
   * Wildcard characters can be escaped using "\". I.e. {@code like("\\?*")} will match values starting with a question mark.
   * Notice that backslash character ("\") needs to be escaped if searching for that character.
   * <p>
   * Method will only look for texts matching the supplied expression within the first 400 bytes of existing values.
   * <p>
   * Notice that queries starting with a wildcard typically will not perform well.
   * <p>
   * Further notice that the method, when used in value conditions, will not match values with units.
   * Use the methods in {@link com.stibo.query.numeric.NumericConditionBuilder} for matching
   * values with units.
   * @param expression The pattern to match
   * @return a completed condition
   * @throws  IllegalArgumentException if expression is null
   */
  public default com.stibo.query.condition.Condition<T> like(java.lang.String expression) {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Matches textual data that is different from the supplied value.
   * <p>
   * The method will not match empty values, only actual values different from the supplied value.
   * <p>
   * A runtime exception will be thrown if supplied value exceeds 1999 bytes.
   * <p>
   * Notice that when the method is used in value conditions, e.g. "neq("22")" will match the value "22 cm".
   * Use the methods in {@link com.stibo.query.numeric.NumericConditionBuilder} to have units considered.
   * @param value  the value that the textual data must not equal
   * @return a completed condition
   */
  public default com.stibo.query.condition.Condition<T> neq(java.lang.String value) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.query-sources\com\stibo\query\value\ValueConditionBuilder.java
====================
package com.stibo.query.value;

/**
 *Common interface for constructing value conditions.
 * <p>
 * Interface offers methods for accessing attribute type specific query features.
 * <p>
 * By default text comparisons are case sensitive.
 * Use {@link CaseSpecificFeature#ignoreCase} prior to the methods in this
 * interface to make the conditions non-case sensitive.
 * <p>
 * By default inheritance is not considered.
 * For value conditions, use {@link InheritanceFeature#inherited} prior to
 * the methods in this interface to match inherited values also.
 * <p>
 * Notice that value searches will not hit calculated values.
 */
public abstract interface ValueConditionBuilder<T extends com.stibo.core.domain.BaseObject> extends com.stibo.query.text.TextConditionBuilder<T>, com.stibo.query.features.inheritance.InheritanceFeature<T,com.stibo.query.value.ValueConditionBuilder<T>>, com.stibo.query.features.casespecific.CaseSpecificFeature<T,com.stibo.query.text.TextConditionBuilder<T>> {
  
  /**
   *Provides access to value query options specific to date validated attributes.
   * <p>
   * Date validated attributes, are attributes with validation base type "ISO Date and Time".
   * <p>
   * A runtime exception will be thrown if the method is invoked for attributes of other validation
   * base types.
   * @return a builder for constructing a date value condition
   */
  public default com.stibo.query.date.DateConditionBuilder<T> date() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Provides access to value query options specific to LOV validated attributes.
   * <p>
   * LOV validated attributes, are attributes for which {@link com.stibo.core.domain.Attribute#hasLOV} is true.
   * <p>
   * A runtime exception will be thrown if the method is invoked for non LOV based attributes.
   * @return a builder for constructing an LOV value condition
   */
  public default com.stibo.query.lov.LOVValueConditionBuilder<T> lov() {
    throw new java.lang.UnsupportedOperationException();
  }
  
  /**
   *Provides access to value query options specific to numerically validated attributes.
   * <p>
   * Numerically validated attributes are attributes with validation base type "Integer", "Number",
   * "Fraction", "Numeric Text"
   * <p>
   * A runtime exception will be thrown if the method is invoked for attributes of other validation
   * base types.
   * @return a builder for constructing a numeric value condition
   */
  public default com.stibo.query.numeric.NumericConditionBuilder<T> numeric() {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.services.base-sources\com\stibo\services\base\approverecursive\ApproveRecursiveServiceDescriptor.java
====================
package com.stibo.services.base.approverecursive;

/**
 *Service descriptor to use when running an approve recursive.
 */
public class ApproveRecursiveServiceDescriptor implements com.stibo.core.domain.backgroundprocess.service.ServiceDescriptor<com.stibo.services.base.approverecursive.ApproveRecursiveServiceDescriptor.Parameter> {
  
  /**
   *Parameters for approve recursive.
   */
  public static class Parameter {
    
    /**
     *The Context to use when approving.
     */
    public com.stibo.core.domain.Context context;
    
    /**
     *The list of nodes to approve.
     */
    public java.util.List<? extends com.stibo.core.domain.WorkspaceRevisableNode> nodes;
    
  }
  
}


====================
FILE PATH: .\com.stibo.sufficiency-sources\com\stibo\sufficiency\bindcontext\SufficiencyCheckActionContext.java
====================
package com.stibo.sufficiency.bindcontext;

/**
 *Sufficiency Check Action Context.
 */
public abstract interface SufficiencyCheckActionContext {
  
  /**
   *Returns PDX channel identifier
   *
   * @return channel ID
   */
  public abstract java.lang.String getChannelID();
  
  /**
   *Returns nodes for this action.
   *
   * @return list of nodes
   */
  public abstract java.util.List<? extends com.stibo.core.domain.Node> getNodes();
  
  /**
   *Returns recipient mails list
   *
   * @return list of recipients
   */
  public abstract java.util.List<java.lang.String> getRecipientMails();
  
}


====================
FILE PATH: .\com.stibo.valuegenerator.domain-sources\com\stibo\valuegenerator\domain\businessrule\IntegratedValueGeneratorsInput.java
====================
package com.stibo.valuegenerator.domain.businessrule;

/**
 *This class is used by the Value Generators for storing results of each of the integrated Value Generators.
 * The results will be sent to the Value Generator business function using an input parameter.
 */
public class IntegratedValueGeneratorsInput {
  
  /**
   *Gets the value generated by the provided Value Generator.
   *
   * @param valueGeneratorID Value Generator ID
   * @return The value generated by the Value Generator
   */
  public java.lang.String getGeneratorValue(java.lang.String valueGeneratorID) {
    throw new java.lang.UnsupportedOperationException();
  }
  
}


====================
FILE PATH: .\com.stibo.valuegenerator.domain-sources\com\stibo\valuegenerator\domain\businessrule\ValueReleaseOutput.java
====================
package com.stibo.valuegenerator.domain.businessrule;

/**
 *This class is used by the Value Generator as a return type of the business function.
 */
public class ValueReleaseOutput implements java.io.Serializable {
  
}


====================
FILE PATH: .\com.stibo.valuegenerator.domain-sources\com\stibo\valuegenerator\domain\businessrule\ValueReleaseOutputBuilder.java
====================
package com.stibo.valuegenerator.domain.businessrule;

/**
 *This interface is used by the Value Generator for storing values that will be released by the integrated Value Generators.
 * The results will be returned by the business function.
 */
public abstract interface ValueReleaseOutputBuilder {
  
  /**
   *Puts the value to be released by the provided Value Generator.
   *
   * @param valueGeneratorID Value Generator ID
   * @param value            The value to release
   */
  public abstract void addValueToRelease(java.lang.String valueGeneratorID,java.lang.String value);
  
  /**
   *Creates the business function returning type object with the values to be released by the integrated Value Generators.
   *
   * @return The business function returning type object
   */
  public abstract com.stibo.valuegenerator.domain.businessrule.ValueReleaseOutput createOutput();
  
}


====================
FILE PATH: .\com.stibo.valuegenerator.domain-sources\com\stibo\valuegenerator\domain\configuration\ValueGeneratorConfiguration.java
====================
package com.stibo.valuegenerator.domain.configuration;

/**
 *Interface for value generator configuration using which we can generate value for a given node.
 * Value generator objects are modeled as setup entities and can be obtained
 * via the SetupEntityHome.getSetupEntityByID(String id) method.
 */
public abstract interface ValueGeneratorConfiguration extends com.stibo.core.domain.setupentity.SetupEntity {
  
  /**
   *Gets the value generator evaluator, using which value can be generated as well as be released.
   *
   * @return The evaluator for the value generator
   */
  public abstract com.stibo.valuegenerator.domain.evaluator.ValueGeneratorEvaluator getValueGeneratorEvaluator();
  
}


====================
FILE PATH: .\com.stibo.valuegenerator.domain-sources\com\stibo\valuegenerator\domain\evaluator\ValueGeneratorEvaluator.java
====================
package com.stibo.valuegenerator.domain.evaluator;

/**
 *Value generator evaluator interface is used by the value generator configuration to generate and release the value.
 * To generate or release the value, the value generator evaluator uses a specific type of value generator that is stored in the value generator configuration.
 */
public abstract interface ValueGeneratorEvaluator {
  
  /**
   *Check if the provided value is unique for the value generator.
   *
   * @param value Value to check the uniqueness
   * @return True if the value is unique, otherwise return false
   */
  public abstract boolean isUniqueValue(java.lang.String value);
  
}


====================
FILE PATH: .\com.stibo.webui.bindaction-sources\com\stibo\webui\bindaction\server\context\WebUiContext.java
====================
package com.stibo.webui.bindaction.server.context;

/**
 *Bindable context type the gives business actions access to the Web UI.
 */
public abstract interface WebUiContext {
  
  /**
   *Get screen ID.
   *
   * @return the ID of the current screen being displayed in the Web UI
   */
  public abstract java.lang.String getScreenId();
  
  /**
   *Get the set of nodes which are selected from the node picker in webUI
   * @return set of selected nodes in node picker
   */
  public abstract java.util.Set<? extends com.stibo.core.domain.Node> getSelectedSetOfNodes();
  
  /**
   *Get the current selected nodes in the Web UI. If the action is used as a
   * button in a node editor, the selection will be the current single node.
   * If used as a toolbar action, this method will return the nodes selected
   * in the node list.
   *
   * @return list of current selected nodes
   */
  public abstract java.util.List<com.stibo.core.domain.Node> getSelection();
  
  /**
   *Navigate to a different screen with a new selection.
   *
   * @param screenId If null, the page simply reloads the current screen. (That
   * is, if selection is also null or set to the current node)
   * @param selection The node to use as selection in the navigation. If null, no node
   * selection is set
   */
  public abstract void navigate(java.lang.String screenId,com.stibo.core.domain.Node selection);
  
  /**
   *Navigate to a different screen with a new selection, including workflow information.
   *
   * @param screenId The screen to navigate to. If null, the resulting screen depends
   * on the selection
   * @param selection Node selection. Can be null in case only screen ID and workflow
   * information is relevant. If both screenId and selection is null, then the current
   * node is used as selection
   * @param workflowState add workflow state information to the selection -- cannot be null
   */
  public abstract void navigate(java.lang.String screenId,com.stibo.core.domain.Node selection,com.stibo.core.domain.state.State workflowState);
  
  /**
   *Navigates to a URL.
   *
   * @param url URL to navigate to
   * @param openNew if true the navigation will happen in a new window/tab
   */
  public abstract void navigateUrl(java.lang.String url,boolean openNew);
  
  /**
   *Display an alert.
   *
   * @param severity Severity level to use. Can be <code>null</code>, which
   * will use INFO. The following values are valid:
   * 	<ul>
   * 	    <li>INFO</li>
   * 	    <li>ACKNOWLEDGMENT</li>
   * 	    <li>WARNING</li>
   * 	    <li>ERROR</li>
   * 	</ul>
   * @param localizableHeadline The localizable headline of the alert. The headline is rendered as HTML
   */
  public abstract void showAlert(java.lang.String severity,java.lang.Object localizableHeadline);
  
  /**
   *Display an alert.
   *
   * @param severity Severity level to use. Can be <code>null</code>, which
   * will use INFO. The following values are valid:
   * 	<ul>
   * 	    <li>INFO</li>
   * 	    <li>ACKNOWLEDGMENT</li>
   * 	    <li>WARNING</li>
   * 	    <li>ERROR</li>
   * 	</ul>
   * @param localizableHeadline The localizable headline of the alert
   * @param localizableMessage The localizable message body in the alert. The message is rendered as HTML
   */
  public abstract void showAlert(java.lang.String severity,java.lang.Object localizableHeadline,java.lang.Object localizableMessage);
  
  /**
   *Display an alert.
   *
   * @param severity Severity level to use. Can be <code>null</code>, which
   * will use INFO. The following values are valid:
   * 	<ul>
   * 	    <li>INFO</li>
   * 	    <li>ACKNOWLEDGMENT</li>
   * 	    <li>WARNING</li>
   * 	    <li>ERROR</li>
   * 	</ul>
   * @param headline The headline of the alert
   * @param message The message body in the alert. The message is rendered as HTML
   */
  public abstract void showAlert(java.lang.String severity,java.lang.String headline,java.lang.String message);
  
}

</body>
</html>
